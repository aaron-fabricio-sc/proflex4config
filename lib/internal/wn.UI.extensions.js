/**
 @preserve
 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

 This software is the confidential and proprietary information
 of Diebold Nixdorf.
 You shall not disclose such Confidential Information and shall
 use it only in accordance with the terms of the license agreement
 you entered into with Diebold Nixdorf.


$MOD$ wn.UI.extensions.js 4.3.1-210203-21-1b8704b6-1a04bc7d
 */
import{default as Promise}from"../../lib/internal/wn.UI.bluebird.enhanced.js";const filters=["whenAvailable rejected due to deactivation"];let EXTENSIONS=null;const getExtensions=({Wincor:e,LogProvider:t}={})=>{const n=t;window.addEventListener("unhandledrejection",(function(t){const o=n;t.preventDefault();const i=t.detail?t.detail.reason:"unknown",r=t.detail?t.detail.promise:{};let s;if(r._trace&&(s=r._trace.stack),!s&&t.detail&&t.detail.reason&&t.detail.reason.stack&&(s=t.detail.reason.stack),e.UI.longStackTraces||t.detail&&"object"==typeof t.detail.reason){filters.reduce(((e,t)=>e&&(!i||"string"!=typeof i||!i.includes(t))),!0)&&o.error("Promise unhandledrejection reason: "+i+(s?" \n"+s:""))}else o.LOG_ERROR&&o.log(o.LOG_ERROR,"Promise unhandledrejection reason: "+i+(s?" \n"+s:""))})),window.addEventListener("rejectionhandled",(function(t){const o=n;t.preventDefault();const i=t.detail?t.detail.promise:{},r=t.detail?t.detail.reason:"unknown";let s;i._trace&&(s=i._trace.stack),!s&&t.detail&&t.detail.reason&&t.detail.reason.stack&&(s=t.detail.reason.stack),e.UI.longStackTraces||t.detail&&"object"==typeof t.detail.reason?e.UI.Diagnostics.LogProvider.error("Promise rejectionhandled reason: "+r+(s?" \n"+s:"")):o.LOG_ERROR&&o.log(o.LOG_ERROR,"Promise rejectionhandled reason: "+r+(s?" \n"+s:""))})),Promise.setScheduler&&Promise.config({warnings:!1,longStackTraces:!!e.UI.longStackTraces,cancellation:!1,monitoring:!1}),e.UI.promise=e.UI.promise||function(e){return new Promise(e)},e.UI.Promise=e.UI.Promise||Promise,e.UI.Promise.getStackTrace=e.UI.Promise.getStackTrace||function(t,n=!1){if(!e.UI.longStackTraces)return null;const o=e.UI.Diagnostics.LogProvider;if(!t||!t.then)return o.error("Wincor.UI.Promise.getStackTrace: invalid argument for promise"),null;let i=null;return t._trace&&(i=t._trace.stack),i&&n&&o.error(`Promise stack: ${i}`),i};let o=0;function i(t,n){let i;o+=1,"string"!=typeof t&&"number"!=typeof t||(i=t),this.id=(i||"gen")+"_"+o,this.resolve=void 0,this.reject=void 0,this.promise=e.UI.promise(((e,t)=>{if(this.resolve=function(t){e(t)},this.reject=function(e){t(e)},n&&"function"==typeof n)return n(e,t)}))}e.UI.deferred=e.UI.deferred||function(e,t){return new i(e,t)},e.UI.promisify=e.UI.promisify||function(t,n,o){return function(){try{const i=Array.prototype.slice.call(arguments,0),r="number"==typeof o&&o>=0?o:i.length;return e.UI.promise(function(o,s){try{i.splice(r,0,(function(e){o(e)})),t.apply(n,i)}catch(n){e.UI.Diagnostics.LogProvider.log("promisified function failed "+n+"\n originalFunc: "+t),s(`promisified function failed ${n}\n originalFunc: ${t}`)}}.bind(n))}catch(n){e.UI.Diagnostics.LogProvider.log("promisifying function failed "+n+"\n originalFunc: "+t)}}},e.UI.serializeProcessing=e.UI.serializeProcessing||function(t,n,o){return e.UI.promise((function(e,i){let r;r=o?Promise.all([o]):Promise.all([Promise.resolve()]);let s=0;const c=t.length,u=[];let a=!0;t.reduce((function(r,l){return a=!1,s++,r.then(function(i,r,s){const a=s?s[0]:void 0,l=Promise.all([n(i,r-1,t,a)]);return(r>1||o)&&u.push(a),r>=c&&l.then((function(t){u.push(t[0]),e(u)})),l}.bind(null,l,s),(function(){i("Wincor.UI.serializeProcessing promise rejected")}))}),r),a&&e()}))};let r=1;const s=function(t=!1){this.enqueuedJobs=[],this.mainPromise=Promise.resolve(),this.queueIsProcessing=!1,this.concurrency=t,this.name="AsyncJobQueue"+r++,this.stopOnError=!0,this.jobId=0,this.defaultJobTimeout=0,this.currentlyExecutingConcurrency="",this.cancelDfd=new i("AsyncJobQueue::cancel"),this.runningPromise=null,this.setConcurrency=function(e){return n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`> AsyncJobQueue::setConcurrency [${this.name}](${e})`),this.concurrency=!!e,n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::setConcurrency"),this},this.setName=function(e){return n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`> AsyncJobQueue::setName [${this.name}](${e})`),this.name=e,n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::setName"),this},this.setDefaultJobTimeout=function(e){return n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`> AsyncJobQueue::setDefaultJobTimeout [${this.name}](${e})`),this.defaultJobTimeout=e,n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::setDefaultJobTimeout"),this},this.setStopOnError=function(e=!0){return n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`> AsyncJobQueue::setStopOnError [${this.name}](${e})`),this.stopOnError=e,n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::setStopOnError"),this},this.isRunning=function(){return!!this.mainPromise&&this.mainPromise.isPending()},this._cleanUp=function(){this.jobId=0,this.enqueuedJobs=[],this.currentlyExecutingConcurrency="",this.queueIsProcessing=!1,this.runningPromise=null,this.cancelDfd.promise.catch((()=>{})),this.cancelDfd.reject("rejected due to _cleanUp called"),this.cancelDfd=new i("AsyncJobQueue::cancel")},this.workObjectsGenerator=function*(t,o){const i=this;let r,s,c,u,a,l,d,h;const m=this.cancelDfd.promise;function I(e,t,o,r){return n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${i.name}] starting timeout of jobId: ${e} ${t?" concurrencyId: "+t:""}`),Promise.delay(2*o.timeout).timeout(o.timeout,r)}for(;m.isPending()&&this.enqueuedJobs.length>0;){l=[];do{r=this.enqueuedJobs.pop(),s=r.workObject,u=r.concurrencyId,void 0!==u&&(this.currentlyExecutingConcurrency=u),c=typeof s,h=r.jobId;let t=!1,o=!1;if("object"===c&&s.then)o=!0,n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${this.name}] pushing promise with  jobId: ${h} ${u?" concurrencyId: "+u:""}`),d=s;else if("function"===c){n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${this.name}] executing func with  jobId: ${h} ${u?" concurrencyId: "+u:""}`);try{d=s(),n.LOG_DETAIL&&e.UI.longStackTraces&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${this.name}] function was: ${s.name}`),d&&d.then||(d=Promise.resolve())}catch(e){if(n.error("AsyncJobQueue::workObjectsGenerator ["+this.name+"] exception caught: "+e.message),this.stopOnError)throw e;t=!0,d=Promise.resolve()}}const m=e.UI.Promise.getStackTrace(d);if(n.LOG_DETAIL&&m&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${this.name}] stacktrace of this promise: ${m}`),!t&&r.timeout){const e=r.timeoutMessage||"jobId: "+h;o||r.timeoutStarter||"number"!=typeof r.timeout||(d=d.timeout(r.timeout,e)),"object"==typeof r.timeoutStarter&&r.timeoutStarter.then&&(d=Promise.race([d,r.timeoutStarter.then(I.bind(this,h,u,r,e))]))}d=d.then(function(e,t){n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${i.name}] finished jobId: ${e} ${t?" concurrencyId: "+t:""}`)}.bind(null,h,u)).catch((e=>{n.LOG_ERROR&&n.log(n.LOG_ERROR,`AsyncJobQueue::workObjectsGenerator [${i.name}] rejected jobId: ${h} ${u?" concurrencyId: "+u:""} with ${e}`);let t=r.continueOnErrors;if(!(!0===t||e&&Array.isArray(t)&&(t.includes(e)||t.includes(e.name))))throw e;n.error(`WARNING: AsyncJobQueue::workObjectsGenerator [${i.name}] Timeout of jobId: ${h} ${u?" concurrencyId: "+u:""}\nRecovering due to continueOnErrors=${t}`)})),l.push(d),this.concurrency&&(a=this.enqueuedJobs.length>0?this.enqueuedJobs[this.enqueuedJobs.length-1].concurrencyId:null)}while(this.concurrency&&void 0!==u&&u===a);1===l.length?(l[0].concurrencyId=u,yield l[0]):(l.concurrencyId=u,yield Promise.all(l))}m.isPending()?t():o(`workObjectsGenerator rejected because of an error=false or cancelPromise.isPending=${m.isPending()}`)},this.cancel=function(e){return new Promise((t=>{n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`> AsyncJobQueue::cancel [${this.name}]() - enqueuedJobs: ${this.enqueuedJobs.length}`),this.mainPromise&&this.mainPromise.isPending()?(this.mainPromise.then((()=>{n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::cancel resolved mainPromise")})).catch((()=>{n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::cancel rejected mainPromise")})).finally((()=>{t(),this._cleanUp()})),this.cancelDfd.reject(`AsyncJobQueue::cancel called for [${this.name}] by ${e}`),this.cancelDfd=new i("AsyncJobQueue::cancel"),this.workObjects.next()):(n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::cancel"),t())}))},this.add=function(e,t,o,r,s,c=!1){if(this.jobId++,this.queueIsProcessing||n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::add [${this.name}] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> start processing`),n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::add [${this.name}] Adding jobId: ${this.jobId} ${t?"concurrencyId: "+t:""}, current len: ${this.enqueuedJobs.length+(this.queueIsProcessing?"":" start processing")}`),this.queueIsProcessing&&"function"==typeof e){if(!this.concurrency||0===this.enqueuedJobs.length&&this.currentlyExecutingConcurrency===t)n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::add [${this.name}] (queue empty, last item processing) -> executing job with jobId: ${this.jobId}`),(e=e())&&e.then||(e=Promise.resolve());else if(this.concurrency&&this.enqueuedJobs.length>0){const o=0===this.enqueuedJobs.filter((e=>e.concurrencyId!==t)).length;this.currentlyExecutingConcurrency===t&&o&&(n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::add [${this.name}] (queue has all same ids) -> executing job with jobId: ${this.jobId}`),(e=e())&&e.then||(e=Promise.resolve()))}}else n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"AsyncJobQueue::add queue will start processing");const u={workObject:e,concurrencyId:t,jobId:this.jobId,timeout:o||this.defaultJobTimeout||0,timeoutMessage:r,timeoutStarter:s||0,continueOnErrors:c};return u.timeout||n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${this.name}] no timeout for jobId: ${this.jobId} ${t?" concurrencyId: "+t:""}`),!u.timeoutStarter&&u.timeout&&e.then&&(n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${this.name}] starting timeout (${u.timeout}) immediately for jobId: ${this.jobId} ${t?" concurrencyId: "+t:""}`),u.workObject=e.timeout(u.timeout,"string"==typeof r?r:void 0)),this.enqueuedJobs.unshift(u),this.queueIsProcessing||(this.queueIsProcessing=!0,this.mainDeferred=new i(this.name,((e,t)=>{this.workObjects=this.workObjectsGenerator((()=>{this.queueIsProcessing=!1,e()}),t);const o=e=>Promise.race([e,this.cancelDfd.promise]).then((t=>{let i=1;t&&t.length&&(i=t.length),n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator processNext [${this.name}] ${i} job(s) finished ${e.concurrencyId?"concurrencyId: "+e.concurrencyId:""} - remaining jobs:${this.enqueuedJobs.length}`);const r=this.workObjects.next();if(!r.done)return r.value.hasOwnProperty("concurrencyId")&&delete r.value.concurrencyId,this.runningPromise=r.value,o(r.value)})).catch((e=>{t(e)})),i=this.workObjects.next();return this.runningPromise=i.value,o(i.value)})),this.mainPromise=this.mainDeferred.promise,this.mainPromise.then((()=>{n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< [${this.name}] mainPromise resolved`)})).catch((e=>{n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< [${this.name}] mainPromise REJECTED with reason: ${e}`)})).finally((()=>{this._cleanUp()}))),this.mainPromise}};e.UI.AsyncJobQueue=e.UI.AsyncJobQueue||s;return e.QueryString=e.QueryString||new function(){this.stringify=function(e,t){let n="",o=!1;for(let i in e)e.hasOwnProperty(i)&&(o&&(n+="&"),o=!0,n+=t?`${i}=${e[i]}`:encodeURIComponent(`${i}=${e[i]}`));return n},this.parse=function(e){let t={};if(!e)return t;let n=decodeURIComponent(e).split("&");for(let e=n.length-1;e>=0;e--){let o=n[e].split("=");t[o[0]]=o[1]}return t},this.set=function(e,t,n){"object"==typeof e&&(n=t,t=e,e=null);let o=this.get(e);Object.assign(o,t);let i=this.getBaseUrl(e),r=this.stringify(o,n);return r?i+"?"+r:i},this.get=function(e){let t=e||window.location.href;if(-1===t.indexOf("?"))return{};let n=t.split("?").splice(1).join("?");return this.parse(decodeURI(n))},this.getBaseUrl=function(e){return e?e.split("?")[0]:window.location.href.split("?")[0]}},EXTENSIONS=EXTENSIONS||{QueryString:e.QueryString,Promises:{Promise:e.UI.Promise,promise:e.UI.promise,deferred:e.UI.deferred,promisify:e.UI.promisify,serializeProcessing:e.UI.serializeProcessing,AsyncJobQueue:s}},EXTENSIONS};export default getExtensions;