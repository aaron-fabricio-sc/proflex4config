/**
 @preserve
 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

 This software is the confidential and proprietary information
 of Diebold Nixdorf.
 You shall not disclose such Confidential Information and shall
 use it only in accordance with the terms of the license agreement
 you entered into with Diebold Nixdorf.


$MOD$ wn.UI.Service.BaseProxy.js 4.3.1-210127-21-34ae33df-1a04bc7d

*/
let _logger;const _shadowServices={crossCallTargets:{}},getBaseProxy=({Wincor:e,ext:r,jQuery:o,LogProvider:t}={})=>e.UI.Service.BaseProxy=class{constructor(){_logger=t,this.serviceName=""}ensureInterface(t,g){const l="SERVICE_EVENTS";let s=!1;const n=this;_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> BaseProxy::ensureInterface() for ${g.NAME}`),Object.keys(t).forEach((function(e){0===e.indexOf("Expand")&&Array.isArray(t[e].attributes)&&(_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::ensureInterface decompressing interface definition for : ${JSON.stringify(t[e])}`),t[e].attributes.forEach((function(r){_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::ensureInterface extending interface: ${r}`);let g={};Object.prototype.hasOwnProperty.call(t,r)&&(g=t[r]),t[r]={},o.extend(!0,t[r],t[e],g),delete t[r].attributes})),delete t[e])})),t=Object.assign({},t),_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::ensureInterface interface: ${JSON.stringify(t,null," ")}`);const a="shadowValue",c=[];Object.keys(t).forEach((function(o){const l=t[o].type;_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::ensureInterface() checking svcImpl for ${l} '${o}'`);let _=Object.prototype.hasOwnProperty.call(t[o],a);if(_||typeof g[o]===l||(_logger.error(`BaseProxy::ensureInterface() for ${g.NAME} failed on type inspection of ${o}`),s=!0),!s){let O;const E="function";if(O=l===E?!Object.prototype.hasOwnProperty.call(t[o],"traceable")||!0===t[o].traceable:Object.prototype.hasOwnProperty.call(t[o],"traceable")&&!0===t[o].traceable,_){const e=t[o].shadowValue;typeof e===l?(_shadowServices[n.NAME]||(_shadowServices[n.NAME]={}),_shadowServices[n.NAME][o]=e):l===E&&"string"==typeof e?(_shadowServices[n.NAME]||(_shadowServices[n.NAME]={}),_shadowServices[n.NAME][o]=new Function(e)):_=!1}if(_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::ensureInterface() proxy tracing is ${O?"enabled":"disabled"} for ${l} '${o}'`),l===E||n[o]&&!_){let r;if(l===E&&(!n[o]||_)){if(Object.prototype.hasOwnProperty.call(t[o],"callbackArgumentIndex")){_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::ensureInterface() generating promisificated proxy function for '${o}'`);const l=t[o].callbackArgumentIndex,s="number"==typeof l&&l>=0;r=function(...r){const t=s?l:r.length;return e.UI.promise((function(l,s){try{const s=r[t];s&&"function"!=typeof s&&e.UI.Service.Provider.propagateError("BaseProxy","ServiceCall - callback index is wrong either in interface or call...");const a=function(...e){const r=e.length<2?e[0]:e;O&&_logger.LOG_DETAIL&&_logger.log(_logger.LOG_DETAIL,`* ${n.NAME}::${o} returns ${JSON.stringify(r)}`),l(r),s&&s.apply(null,e)};r.length>t?r.splice(t,1,a):r[t]=a,O&&_logger.LOG_DETAIL&&_logger.log(_logger.LOG_DETAIL,`> ${n.NAME}::${o}()`),_?_shadowServices[n.NAME][o].apply(g,r):g[o].apply(g,r),O&&_logger.LOG_DETAIL&&_logger.log(_logger.LOG_DETAIL,`< ${n.NAME}::${o}`)}catch(t){_logger.error(`promisified function failed ${t}\n originalFunc: ${g[o]}\n\n called with:\n ${r.map((e=>"argument"+r.indexOf(e)+": "+e+"\n"))}`),e.UI.Service.Provider.propagateError("BaseProxy","ServiceCall",t),s()}}))},!1!==t[o].internal&&Object.defineProperty(n,o,{get:()=>r,set:e=>{_logger.error(`Tried to reassign ${n.NAME}::${o} ${_?"shadowed ":""}function to ${e}`)}})}else _logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::ensureInterface() generating standard proxy function for '${o}'`),r=function(...r){try{let e;return O&&_logger.LOG_DETAIL&&_logger.log(_logger.LOG_DETAIL,`> ${n.NAME}::${o}()`),e=_?_shadowServices[n.NAME][o].apply(g,r):g[o].apply(g,r),O&&_logger.LOG_DETAIL&&_logger.log(_logger.LOG_DETAIL,`< ${n.NAME}::${o} returns ${e}`),e}catch(t){return _logger.error(`standard proxy function caught exception ${t} \noriginalFunc: ${g[o]}\n\n called with:\n ${r.map((e=>"argument"+r.indexOf(e)+": "+e+"\n"))}`),e.UI.Service.Provider.propagateError("BaseProxy","ServiceCall",t),Promise.reject()}},!1!==t[o].internal&&Object.defineProperty(n,o,{get:()=>r,set:e=>{_logger.error(`Tried to reassign ${n.NAME}::${o} ${_?"shadowed ":""}function to ${e}`)}});(t[o].external||t[o].crossCall)&&(void 0===g.requestMap&&(g.requestMap=new Map),_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::ensureInterface() exposing proxy function for '${o}'`),g.requestMap.set(o,r))}}else{_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::ensureInterface() generating attribute accessor (get) for${_?" shadowed value":""} '${o}'`);const E={get:function(){const e=_?_shadowServices[n.NAME][o]:g[o];return O&&_logger.LOG_DETAIL&&_logger.log(_logger.LOG_DETAIL,`* ${n.NAME}::${o} accessor get returns${_?" shadowed value":""} '${e}'`),e}};if(!_&&t[o].serviceEvent){const l=o.toUpperCase()+"_CHANGED";g.SERVICE_EVENTS||(g.SERVICE_EVENTS={},t.SERVICE_EVENTS||(t.SERVICE_EVENTS={type:"object",crossCall:!!t[o].crossCall})),g.SERVICE_EVENTS[l]=l,t[o].crossCall||c.push(l),n.SERVICE_EVENTS||(n.SERVICE_EVENTS={}),n.SERVICE_EVENTS[l]=l;const s=g;_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`* BaseProxy::ensureInterface installing service attribute trap for ${s.NAME}::${o}`);let _=s[o];!Object.prototype.hasOwnProperty.call(t[o],a)&&t[o].serviceEvent&&(s.SERVICE_EVENTS||(s.SERVICE_EVENTS={}),s.SERVICE_EVENTS[l]=l),Object.defineProperty(s,o,{get:()=>_,set:t=>{_=t;let g=r.Promises.Promise.resolve();i.forEach((r=>{_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`* BaseProxy::ensureInterface crossCallAttribute ${s.NAME}::${o} changed sending to ${r}...`),g=d.add(function(r,t){return s.crossCallEvent.call(s,r,s.NAME,`${e.UI.Service.Provider.getInstanceName()}:${s.NAME}:${o}`,t).then((e=>{_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`* BaseProxy::ensureInterface received ack with rc=${e}`)})).catch((e=>{_logger.LOG_ERROR&&_logger.log(_logger.LOG_ERROR,`* BaseProxy::ensureInterface sending crossCallEvent rejected with ${e}`)}))}.bind(n,r,t),++I)})),g.then(function(e,r){e in this.SERVICE_EVENTS&&this.fireServiceEvent(e,r)}.bind(s,l,t)).catch((e=>{_logger.LOG_ERROR&&_logger.log(_logger.LOG_ERROR,`* BaseProxy::ensureInterface sending crossCallEvent rejected with ${e}`)}))}})}const S=!Object.prototype.hasOwnProperty.call(t[o],"writable")||t[o].writable;S?_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::ensureInterface() generating attribute accessor (set) for${_?" shadowed value":""} '${o}'`):_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::ensureInterface() generating failure accessor (set) for${_?" shadowed value":""} '${o}'`),E.set=function(e){O&&S&&_logger.LOG_DETAIL&&_logger.log(_logger.LOG_DETAIL,`* ${n.NAME}::${o} accessor set${_?" shadowed value":""} '${e}'`),S&&typeof e===t[o].type?_?_shadowServices[n.NAME][o]=e:g[o]=e:typeof e!==t[o].type?_logger.error(`Tried to set ${n.NAME}::${o} ${_?"shadowed ":""}property to wrong type '${typeof e}' with value: <${e}>! Type should be ${t[o].type}`):_logger.error(`Tried to set ${n.NAME}::${o} ${_?"shadowed ":""}readonly property to <${e}>`)},Object.defineProperty(n,o,E),"object"===l&&t[o].keys&&t[o].keys.forEach((function(e){_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::ensureInterface() checking for key '${e}' of object '${o}'`),null!==g[o]&&void 0!==g[o][e]||(_logger.error(`BaseProxy::ensureInterface() for ${g.NAME} failed due non existence of ${o}.${e}`),s=!0)}))}}}));const _=g,i=new Set([]);let O;function E(){if(_logger.log(_logger.LOG_INOUT,"> BaseProxy::readInstalledInstances"),O)return _logger.log(_logger.LOG_INOUT,`< BaseProxy::readInstalledInstances already done - returning ${JSON.stringify(O)}`),r.Promises.Promise.resolve(O);if(!e.applicationMode)return r.Promises.Promise.reject("remote instances not supported in designmode");const o=e.UI.Service.Provider.getInstanceName(),t=[],g=[];return["GUIAPP","GUIDM","GUIVIDEO","GUISOP"].filter((e=>e!==o)).forEach((r=>{const o=e.UI.Service.Provider.ConfigService.getConfiguration(`CCOPEN\\GUI\\${r}`,["Browser"]).then((e=>{_logger.log(_logger.LOG_INOUT,`. BaseProxy::readInstalledInstances checking 'Browser' config of ${r} -> ${JSON.stringify(e)}`),e.Browser&&t.push(r)}));g.push(o)})),r.Promises.Promise.all(g).then((()=>(O=t,_logger.log(_logger.LOG_INOUT,`< BaseProxy::readInstalledInstances returns ${JSON.stringify(t)}`),t))).catch((e=>{_logger.error(`BaseProxy::readInstalledInstances failed: ${e}`)}))}_.requestMap&&_.requestMap.set("getRemoteInterface",(function(e){let r;if(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"> BaseProxy::getRemoteInterface()"),e.caller&&e.acknowledgeId){_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> BaseProxy::createRemoteInterfaceObject() of ${_.NAME}`);try{r={};const e="DISPOSAL_TRIGGER_";if(t.SERVICE_EVENTS){r.SERVICE_EVENTS=o.extend({},t.SERVICE_EVENTS);let e={};Object.keys(_.SERVICE_EVENTS).forEach((r=>{c.includes(r)||(e[r]=_.SERVICE_EVENTS[r])})),r.SERVICE_EVENTS.value=e}Object.keys(t).forEach((g=>{if(g.startsWith(e)&&(r[g]=o.extend({},t[g]),r[g].value=_[g]),t[g].crossCall){if(g===l)return void _logger.error("createRemoteInterfaceObject SERVICE_EVENTS are generated automatically, crossCall marker not necessary");if(r[g]=o.extend({},t[g]),"function"!==t[g].type){if(r.SERVICE_EVENTS&&t[g].serviceEvent){const e=g.toUpperCase()+"_CHANGED";r.SERVICE_EVENTS.value[e]=e}r[g].value=_[g]}else if(0===i.size){_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`* BaseProxy::createRemoteInterfaceObject installing function trap for ${_.NAME}::${g}`);const e=_.requestMap.get(g);_.requestMap.set(g,(function(r){let o;if(r.caller&&r.acknowledgeId){try{o=e.apply(_,r.args)}catch(e){}o&&o.then?o.then((e=>{_.crossCallAcknowledge.call(_,r.caller,r.service,r.acknowledgeId,e).catch((e=>{_logger.LOG_ERROR&&_logger.log(_logger.LOG_ERROR,`* BaseProxy::ensureInterface sending crossCallAcknowledge rejected with ${e}`)}))})):_.crossCallAcknowledge.call(_,r.caller,r.service,r.acknowledgeId,o).catch((e=>{_logger.LOG_ERROR&&_logger.log(_logger.LOG_ERROR,`* BaseProxy::ensureInterface sending crossCallAcknowledge rejected with ${e}`)}))}else t[g].external&&e.call(_,r)}))}else _logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`* BaseProxy::createRemoteInterfaceObject already installed function trap for ${_.NAME}::${g}`)}}))}catch(r){_logger.error(`BaseProxy::createRemoteInterfaceObject getRemoteInterface event ${JSON.stringify(e)} exception ${r.message}!`)}i.add(e.caller),_.crossCallAcknowledge.call(_,e.caller,e.service,e.acknowledgeId,r).catch((e=>{_logger.error(e)})),_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< BaseProxy::createRemoteInterfaceObject sends:\n${JSON.stringify(r,null," ")}`)}else _logger.error("BaseProxy::getRemoteInterface functions are not externally usable!");_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"< BaseProxy::getRemoteInterface")})),_.requestMap&&_.requestMap.set("registerForServiceEvent",(function(r){let o;if(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> BaseProxy::registerForServiceEvent() requested by ${r.caller}`),r.caller&&r.acknowledgeId){try{const t=r.args[0],g=r.args[2];o=_.registerForServiceEvent.call(_,t,(g=>{let l=`${e.UI.Service.Provider.getInstanceName()}_${r.service}_${t}_EventReg_${o}`;_.crossCallEvent(r.caller,r.service,l,g).catch((e=>{_logger.LOG_ERROR&&_logger.log(_logger.LOG_ERROR,`* BaseProxy::ensureInterface sending crossCallEvent rejected with ${e}`)}))}),g)}catch(e){_logger.error(`BaseProxy::ensureInterface registerForServiceEvent event ${JSON.stringify(r)} exception ${e.message}!`)}_.crossCallAcknowledge.call(_,r.caller,r.service,r.acknowledgeId,o).catch((e=>{_logger.LOG_ERROR&&_logger.log(_logger.LOG_ERROR,`* BaseProxy::ensureInterface sending crossCallAcknowledge rejected with ${e}`)})).finally((()=>{_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< BaseProxy::registerForServiceEvent done for ${r.caller}`)}))}else _logger.error("BaseProxy::ensureInterface service event functions are not externally usable!")})),_.requestMap&&_.requestMap.set("deregisterFromServiceEvent",(function(e){let r;if(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> BaseProxy::deregisterFromServiceEvent() requested by ${e.caller}`),e.caller&&e.acknowledgeId){try{r=_.deregisterFromServiceEvent.apply(_,e.args)}catch(r){_logger.LOG_ERROR&&_logger.log(_logger.LOG_ERROR,`* BaseProxy::ensureInterface deregisterFromServiceEvent ${JSON.stringify(e)} exception ${r.message}!`)}_.crossCallAcknowledge.call(_,e.caller,e.service,e.acknowledgeId,r).catch((e=>{_logger.LOG_ERROR&&_logger.log(_logger.LOG_ERROR,`* BaseProxy::ensureInterface deregisterFromServiceEvent cca exception ${e}!`)})).finally((()=>{_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< BaseProxy::registerForServiceEvent done for ${e.caller}`)}))}else _logger.error("BaseProxy::ensureInterface service event functions are not externally usable!")}));let S=e=>r.Promises.promise(((o,t)=>(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> BaseProxy getRemoteInstance(${e})`),this.hasRemoteInstance(e).then((()=>{const g=_shadowServices.crossCallTargets[e];if(!g||!g[_.NAME]){_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,". BaseProxy getRemoteInstance remoteInterface currently unknown - requesting");const g=()=>(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"> BaseProxy getRemoteInterface()"),_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. getRemoteInterface from ${e}'s ${_.NAME}`),_.crossCall.call(_,e,"getRemoteInterface",[],_.NAME).catch((o=>(_logger.LOG_WARNING&&_logger.log(_logger.LOG_WARNING,`* BaseProxy::getRemoteInterface from ${e}'s ${_.NAME} returned ${o} - retrying in 2000ms`),r.Promises.Promise.resolve().delay(2e3).then(g)))));return g().then((t=>{_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"* BaseProxy received remoteInterface..."),_shadowServices.crossCallTargets[e]||(_shadowServices.crossCallTargets[e]={}),_shadowServices.crossCallTargets[e][_.NAME]||(_shadowServices.crossCallTargets[e][_.NAME]={}),Object.keys(t).forEach((function(r){let o=!0===t[r].traceable,g=!1!==t[r].traceable;if("function"!==t[r].type){let g;_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. BaseProxy getRemoteInstance() creating remote instance '${e}' crossCallAttribute for attr '${r}' current value: '${t[r].value}'`),g=_shadowServices.crossCallTargets[e][_.NAME][r]=t[r].value;const l=`${e}:${_.NAME}:${r}`;_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`* BaseProxy getRemoteInstance installing event-handler for crossCallAttributeChanged eventId: ${l}`),_.eventMap.set(l,(e=>{_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`* BaseProxy getRemoteInstance crossCallAttributeChanged received: ${JSON.stringify(e,null," ")}`),g=e.eventData,_.crossCallAcknowledge(e.caller,e.service,e.acknowledgeId,0)})),_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. BaseProxy getRemoteInstance() creating attribute accessor (get) '${e}' for '${r}' current value: '${t[r].value}'`);const s=t[r].crossCallWritable,a=t[r].type,c={get:()=>(o&&_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`* ${e}::${n.NAME}::${r} accessor get returns ${g}`),g),set:o=>{s?typeof o===a?g=o:_logger.error(`Tried to assign wrong type ${typeof o} val:'${o}' to remote instance attribute ${e}::${r}`):_logger.error(`Tried to set non writable remote instance attribute ${e}::${r} to '${o}'`)}};Object.defineProperty(_shadowServices.crossCallTargets[e][_.NAME],r,c)}else _logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. BaseProxy getRemoteInstance() creating remote instance '${e}' crossCall for function '${r}'`),_shadowServices.crossCallTargets[e][_.NAME][r]=(...o)=>(g&&_logger.LOG_DETAIL&&_logger.log(_logger.LOG_DETAIL,`> ${e}::${n.NAME}::${r}()`),_.crossCall.apply(_,[e,r,o,_.NAME]).then((o=>(g&&_logger.LOG_DETAIL&&_logger.log(_logger.LOG_DETAIL,`< ${e}::${n.NAME}::${r} returns ${JSON.stringify(o)}`),o))))})),function(e){_shadowServices.crossCallTargets[e]||(_shadowServices.crossCallTargets[e]={}),_shadowServices.crossCallTargets[e][_.NAME]||(_shadowServices.crossCallTargets[e][_.NAME]={}),_shadowServices.crossCallTargets[e][_.NAME].registerForServiceEvent&&_logger.error("BaseProxy::ensureInterface service event functions registerForServiceEvent are installed automatically when using cross calls. Please remove explicit configuration from interface!");let o=[];_shadowServices.crossCallTargets[e][_.NAME].registerForServiceEvent=(r,t,g)=>(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> ${e}::${_.NAME}::registerForServiceEvent(${r}, fx, ${g})`),_.crossCall.apply(_,[e,"registerForServiceEvent",[r,null,g],_.NAME]).then((g=>{const l=`${e}_${_.NAME}_${r}_EventReg_${g}`;return o.push(l),_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`* ${e}::${_.NAME}::registerForServiceEvent ${r} -> registered events '${JSON.stringify(o,null," ")}'`),_.eventMap.set(l,(r=>{_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`* ${e}::${_.NAME} received ccEvent:\n${JSON.stringify(r,null," ")}`),t(r.eventData),_.crossCallAcknowledge(r.caller,r.service,r.acknowledgeId,0)})),_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< ${e}::${_.NAME}::registerForServiceEvent(${r} returned regId ${g}`),g})).catch((e=>{_logger.error(e)}))),_shadowServices.crossCallTargets[e][_.NAME].deregisterFromServiceEvent&&_logger.error("BaseProxy::ensureInterface service event functions deregisterFromServiceEvent are installed automatically when using cross calls. Please remove explicit configuration from interface!"),_shadowServices.crossCallTargets[e][_.NAME].deregisterFromServiceEvent=t=>{_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> ${e}::${_.NAME}::deregisterFromServiceEvent(${t})`);let g=[],l=t;if("number"==typeof l){const r=`${e}_${_.NAME}_.*_EventReg_${l}`;_.eventMap.forEach(((e,o)=>{o.search(r)>-1&&g.push(o)})),l=[l]}else g=o,l=g.map((e=>parseInt(e.split("_").pop()))),o=[];return _logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`. ${e}::${_.NAME}::deregisterFromServiceEvent found in eventMap ${JSON.stringify(g,null," ")}`),_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`. ${e}::${_.NAME}::deregisterFromServiceEvent regIds ${JSON.stringify(l,null," ")}`),g.forEach((e=>{_.eventMap.delete(e)})),r.Promises.Promise.all(l.map((r=>_.crossCall.apply(_,[e,"deregisterFromServiceEvent",[r],_.NAME]).then((o=>(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< ${e}::${_.NAME}::deregisterFromServiceEvent(${r} returned success ${o}`),o)))))).then((e=>e.reduce(((e,r)=>e&&r),!0))).catch((e=>{_logger.error(e)}))}}(e),o(new Proxy(_shadowServices.crossCallTargets[e][_.NAME],{}))})).catch((e=>{_logger.error(e),t(e)}))}o(new Proxy(_shadowServices.crossCallTargets[e][_.NAME],{}))})).catch((e=>{_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. BaseProxy getRemoteInstance hasRemoteInstance rejected - reason: ${e}`),t(e)}))))).then((e=>(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< BaseProxy getRemoteInstance returns ${JSON.stringify(e,((e,r)=>"function"==typeof r?"function":r)," ")}`),e))),d=(new r.Promises.AsyncJobQueue).setConcurrency(!0),I=0;return this.getRemoteInstance=o=>{if(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> BaseProxy::getRemoteInstance(${o})`),d.name.startsWith("AsyncJobQueue")&&e.UI.Service.Provider.getInstanceName()){let r=`${e.UI.Service.Provider.getInstanceName()}:${_.NAME}`;_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`. BaseProxy::getRemoteInstance renaming jobQueue ${d.name}->${r}`),d.setName(r)}return r.Promises.promise(((e,r)=>{const t=this;d.add(function(o){return S.call(t,o).then((e=>(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"< BaseProxy::getRemoteInstance"),e))).then(e).catch((e=>{r(e)}))}.bind(t,o),++I)}))},this.hasRemoteInstance=e=>r.Promises.promise(((r,o)=>{_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"> BaseProxy::hasRemoteInstance"),E().then((t=>{_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< BaseProxy::hasRemoteInstance ${t.includes(e)}`),t.includes(e)?r(!0):o(`No remote instance of ${e} available!`)})).catch(o)})),this.getRemoteInstanceNames=()=>E(),_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< BaseProxy::ensureInterface returns ${!s}`),!s}getServiceName(){return this.serviceName}initializeService(t,g,l){return _logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"> BaseProxy::initializeService"),r.Promises.promise(((s,n)=>{const a=t;_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::initializeService loading service ${a.service}`),_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::initializeService loaded service ${a.service}`);let c=l;"function"==typeof this.setService&&this.setService(c),this.serviceName=c.NAME,c.NAME&&e.UI.Service[c.NAME]&&(e.UI.Service[c.NAME]=void 0);const _=a.interface||{};o.extend(!0,_,g.interface);const i=a.entryPoints;let O=!1;i&&Array.isArray(i)&&i.forEach(function(e){_logger.LOG_ANALYSE&&_logger.log(_logger.LOG_ANALYSE,`. BaseProxy::initializeService checking requestMap + eventMap for entrypoint '${e}'...`),c.requestMap.has(e)||c.eventMap.has(e)||(_logger.error(`BaseProxy::initializeService '${c.NAME}' missing entrypoint '${e}' in requestMap or eventMap!`),O=!0)}.bind(this));try{const e=r.Promises.deferred(`${c.NAME}_whenReady`);c.whenReady=e.promise,!O&&this.ensureInterface(_,c)?(c.installServiceEvents&&c.installServiceEvents(),s(e)):n()}catch(e){_logger.error(`BaseProxy::initializeService: ${e}`),n(e)}_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< BaseProxy::initializeService returns ${JSON.stringify(a)}`)}))}};export default getBaseProxy;