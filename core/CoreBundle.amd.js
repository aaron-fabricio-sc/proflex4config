define(function () { 'use strict';

	function createCommonjsModule(fn, basedir, module) {
		return module = {
			path: basedir,
			exports: {},
			require: function (path, base) {
				return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
			}
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var knockout = createCommonjsModule(function (module, exports) {
	/*!
	 * Knockout JavaScript library v3.5.1
	 * (c) The Knockout.js team - http://knockoutjs.com/
	 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
	 */

	(function() {(function(n){var A=this||(0, eval)("this"),w=A.document,R=A.navigator,v=A.jQuery,H=A.JSON;v||"undefined"===typeof jQuery||(v=jQuery);(function(n){n(module.exports||exports);})(function(S,T){function K(a,c){return null===a||typeof a in W?a===c:!1}function X(b,c){var d;return function(){d||(d=a.a.setTimeout(function(){d=n;b();},c));}}function Y(b,c){var d;return function(){clearTimeout(d);
	d=a.a.setTimeout(b,c);}}function Z(a,c){c&&"change"!==c?"beforeChange"===c?this.pc(a):this.gb(a,c):this.qc(a);}function aa(a,c){null!==c&&c.s&&c.s();}function ba(a,c){var d=this.qd,e=d[r];e.ra||(this.Qb&&this.mb[c]?(d.uc(c,a,this.mb[c]),this.mb[c]=null,--this.Qb):e.I[c]||d.uc(c,a,e.J?{da:a}:d.$c(a)),a.Ja&&a.gd());}var a="undefined"!==typeof S?S:{};a.b=function(b,c){for(var d=b.split("."),e=a,f=0;f<d.length-1;f++)e=e[d[f]];e[d[d.length-1]]=c;};a.L=function(a,c,d){a[c]=d;};a.version="3.5.1";a.b("version",
	a.version);a.options={deferUpdates:!1,useOnlyNativeEvents:!1,foreachHidesDestroyed:!1};a.a=function(){function b(a,b){for(var c in a)f.call(a,c)&&b(c,a[c]);}function c(a,b){if(b)for(var c in b)f.call(b,c)&&(a[c]=b[c]);return a}function d(a,b){a.__proto__=b;return a}function e(b,c,d,e){var l=b[c].match(q)||[];a.a.D(d.match(q),function(b){a.a.Na(l,b,e);});b[c]=l.join(" ");}var f=Object.prototype.hasOwnProperty,g={__proto__:[]}instanceof Array,h="function"===typeof Symbol,m={},k={};m[R&&/Firefox\/2/i.test(R.userAgent)?
	"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];m.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(m,function(a,b){if(b.length)for(var c=0,d=b.length;c<d;c++)k[b[c]]=a;});var l={propertychange:!0},p=w&&function(){for(var a=3,b=w.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:n}(),q=/\S+/g,t;return {Jc:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],
	D:function(a,b,c){for(var d=0,e=a.length;d<e;d++)b.call(c,a[d],d,a);},A:"function"==typeof Array.prototype.indexOf?function(a,b){return Array.prototype.indexOf.call(a,b)}:function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return -1},Lb:function(a,b,c){for(var d=0,e=a.length;d<e;d++)if(b.call(c,a[d],d,a))return a[d];return n},Pa:function(b,c){var d=a.a.A(b,c);0<d?b.splice(d,1):0===d&&b.shift();},wc:function(b){var c=[];b&&a.a.D(b,function(b){0>a.a.A(c,b)&&c.push(b);});return c},Mb:function(a,
	b,c){var d=[];if(a)for(var e=0,l=a.length;e<l;e++)d.push(b.call(c,a[e],e));return d},jb:function(a,b,c){var d=[];if(a)for(var e=0,l=a.length;e<l;e++)b.call(c,a[e],e)&&d.push(a[e]);return d},Nb:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a},Na:function(b,c,d){var e=a.a.A(a.a.bc(b),c);0>e?d&&b.push(c):d||b.splice(e,1);},Ba:g,extend:c,setPrototypeOf:d,Ab:g?d:c,P:b,Ga:function(a,b,c){if(!a)return a;var d={},e;for(e in a)f.call(a,e)&&(d[e]=
	b.call(c,a[e],e,a));return d},Tb:function(b){for(;b.firstChild;)a.removeNode(b.firstChild);},Yb:function(b){b=a.a.la(b);for(var c=(b[0]&&b[0].ownerDocument||w).createElement("div"),d=0,e=b.length;d<e;d++)c.appendChild(a.oa(b[d]));return c},Ca:function(b,c){for(var d=0,e=b.length,l=[];d<e;d++){var k=b[d].cloneNode(!0);l.push(c?a.oa(k):k);}return l},va:function(b,c){a.a.Tb(b);if(c)for(var d=0,e=c.length;d<e;d++)b.appendChild(c[d]);},Xc:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var e=d[0],
	l=e.parentNode,k=0,f=c.length;k<f;k++)l.insertBefore(c[k],e);k=0;for(f=d.length;k<f;k++)a.removeNode(d[k]);}},Ua:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.splice(0,1);for(;1<a.length&&a[a.length-1].parentNode!==b;)a.length--;if(1<a.length){var c=a[0],d=a[a.length-1];for(a.length=0;c!==d;)a.push(c),c=c.nextSibling;a.push(d);}}return a},Zc:function(a,b){7>p?a.setAttribute("selected",b):a.selected=b;},Db:function(a){return null===a||a===n?"":a.trim?
	a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},Ud:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},vd:function(a,b){if(a===b)return !0;if(11===a.nodeType)return !1;if(b.contains)return b.contains(1!==a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&16);for(;a&&a!=b;)a=a.parentNode;return !!a},Sb:function(b){return a.a.vd(b,b.ownerDocument.documentElement)},kd:function(b){return !!a.a.Lb(b,a.a.Sb)},R:function(a){return a&&
	a.tagName&&a.tagName.toLowerCase()},Ac:function(b){return a.onError?function(){try{return b.apply(this,arguments)}catch(c){throw a.onError&&a.onError(c),c;}}:b},setTimeout:function(b,c){return setTimeout(a.a.Ac(b),c)},Gc:function(b){setTimeout(function(){a.onError&&a.onError(b);throw b;},0);},B:function(b,c,d){var e=a.a.Ac(d);d=l[c];if(a.options.useOnlyNativeEvents||d||!v)if(d||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var k=function(a){e.call(b,a);},f="on"+c;b.attachEvent(f,
	k);a.a.K.za(b,function(){b.detachEvent(f,k);});}else throw Error("Browser doesn't support addEventListener or attachEvent");else b.addEventListener(c,e,!1);else t||(t="function"==typeof v(b).on?"on":"bind"),v(b)[t](c,e);},Fb:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===a.a.R(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==d||"radio"==d):d=!1;if(a.options.useOnlyNativeEvents||!v||d)if("function"==typeof w.createEvent)if("function"==
	typeof b.dispatchEvent)d=w.createEvent(k[c]||"HTMLEvents"),d.initEvent(c,!0,!0,A,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");else v(b).trigger(c);},f:function(b){return a.O(b)?b():b},bc:function(b){return a.O(b)?b.v():b},Eb:function(b,c,d){var l;c&&("object"===typeof b.classList?
	(l=b.classList[d?"add":"remove"],a.a.D(c.match(q),function(a){l.call(b.classList,a);})):"string"===typeof b.className.baseVal?e(b.className,"baseVal",c,d):e(b,"className",c,d));},Bb:function(b,c){var d=a.a.f(c);if(null===d||d===n)d="";var e=a.h.firstChild(b);!e||3!=e.nodeType||a.h.nextSibling(e)?a.h.va(b,[b.ownerDocument.createTextNode(d)]):e.data=d;a.a.Ad(b);},Yc:function(a,b){a.name=b;if(7>=p)try{var c=a.name.replace(/[&<>'"]/g,function(a){return "&#"+a.charCodeAt(0)+";"});a.mergeAttributes(w.createElement("<input name='"+
	c+"'/>"),!1);}catch(d){}},Ad:function(a){9<=p&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom));},wd:function(a){if(p){var b=a.style.width;a.style.width=0;a.style.width=b;}},Pd:function(b,c){b=a.a.f(b);c=a.a.f(c);for(var d=[],e=b;e<=c;e++)d.push(e);return d},la:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},Da:function(a){return h?Symbol(a):a},Zd:6===p,$d:7===p,W:p,Lc:function(b,c){for(var d=a.a.la(b.getElementsByTagName("input")).concat(a.a.la(b.getElementsByTagName("textarea"))),
	e="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},l=[],k=d.length-1;0<=k;k--)e(d[k])&&l.push(d[k]);return l},Nd:function(b){return "string"==typeof b&&(b=a.a.Db(b))?H&&H.parse?H.parse(b):(new Function("return "+b))():null},hc:function(b,c,d){if(!H||!H.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
	return H.stringify(a.a.f(b),c,d)},Od:function(c,d,e){e=e||{};var l=e.params||{},k=e.includeFields||this.Jc,f=c;if("object"==typeof c&&"form"===a.a.R(c))for(var f=c.action,h=k.length-1;0<=h;h--)for(var g=a.a.Lc(c,k[h]),m=g.length-1;0<=m;m--)l[g[m].name]=g[m].value;d=a.a.f(d);var p=w.createElement("form");p.style.display="none";p.action=f;p.method="post";for(var q in d)c=w.createElement("input"),c.type="hidden",c.name=q,c.value=a.a.hc(a.a.f(d[q])),p.appendChild(c);b(l,function(a,b){var c=w.createElement("input");
	c.type="hidden";c.name=a;c.value=b;p.appendChild(c);});w.body.appendChild(p);e.submitter?e.submitter(p):p.submit();setTimeout(function(){p.parentNode.removeChild(p);},0);}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.D);a.b("utils.arrayFirst",a.a.Lb);a.b("utils.arrayFilter",a.a.jb);a.b("utils.arrayGetDistinctValues",a.a.wc);a.b("utils.arrayIndexOf",a.a.A);a.b("utils.arrayMap",a.a.Mb);a.b("utils.arrayPushAll",a.a.Nb);a.b("utils.arrayRemoveItem",a.a.Pa);a.b("utils.cloneNodes",a.a.Ca);a.b("utils.createSymbolOrString",
	a.a.Da);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",a.a.Jc);a.b("utils.getFormFields",a.a.Lc);a.b("utils.objectMap",a.a.Ga);a.b("utils.peekObservable",a.a.bc);a.b("utils.postJson",a.a.Od);a.b("utils.parseJson",a.a.Nd);a.b("utils.registerEventHandler",a.a.B);a.b("utils.stringifyJson",a.a.hc);a.b("utils.range",a.a.Pd);a.b("utils.toggleDomNodeCssClass",a.a.Eb);a.b("utils.triggerEvent",a.a.Fb);a.b("utils.unwrapObservable",a.a.f);a.b("utils.objectForEach",a.a.P);a.b("utils.addOrRemoveItem",
	a.a.Na);a.b("utils.setTextContent",a.a.Bb);a.b("unwrap",a.a.f);Function.prototype.bind||(Function.prototype.bind=function(a){var c=this;if(1===arguments.length)return function(){return c.apply(a,arguments)};var d=Array.prototype.slice.call(arguments,1);return function(){var e=d.slice(0);e.push.apply(e,arguments);return c.apply(a,e)}});a.a.g=new function(){var b=0,c="__ko__"+(new Date).getTime(),d={},e,f;a.a.W?(e=function(a,e){var f=a[c];if(!f||"null"===f||!d[f]){if(!e)return n;f=a[c]="ko"+b++;d[f]=
	{};}return d[f]},f=function(a){var b=a[c];return b?(delete d[b],a[c]=null,!0):!1}):(e=function(a,b){var d=a[c];!d&&b&&(d=a[c]={});return d},f=function(a){return a[c]?(delete a[c],!0):!1});return {get:function(a,b){var c=e(a,!1);return c&&c[b]},set:function(a,b,c){(a=e(a,c!==n))&&(a[b]=c);},Ub:function(a,b,c){a=e(a,!0);return a[b]||(a[b]=c)},clear:f,Z:function(){return b++ +c}}};a.b("utils.domData",a.a.g);a.b("utils.domData.clear",a.a.g.clear);a.a.K=new function(){function b(b,c){var d=a.a.g.get(b,e);
	d===n&&c&&(d=[],a.a.g.set(b,e,d));return d}function c(c){var e=b(c,!1);if(e)for(var e=e.slice(0),k=0;k<e.length;k++)e[k](c);a.a.g.clear(c);a.a.K.cleanExternalData(c);g[c.nodeType]&&d(c.childNodes,!0);}function d(b,d){for(var e=[],l,f=0;f<b.length;f++)if(!d||8===b[f].nodeType)if(c(e[e.length]=l=b[f]),b[f]!==l)for(;f--&&-1==a.a.A(e,b[f]););}var e=a.a.g.Z(),f={1:!0,8:!0,9:!0},g={1:!0,9:!0};return {za:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");b(a,!0).push(c);},yb:function(c,
	d){var f=b(c,!1);f&&(a.a.Pa(f,d),0==f.length&&a.a.g.set(c,e,n));},oa:function(b){a.u.G(function(){f[b.nodeType]&&(c(b),g[b.nodeType]&&d(b.getElementsByTagName("*")));});return b},removeNode:function(b){a.oa(b);b.parentNode&&b.parentNode.removeChild(b);},cleanExternalData:function(a){v&&"function"==typeof v.cleanData&&v.cleanData([a]);}}};a.oa=a.a.K.oa;a.removeNode=a.a.K.removeNode;a.b("cleanNode",a.oa);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",a.a.K);a.b("utils.domNodeDisposal.addDisposeCallback",
	a.a.K.za);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.K.yb);(function(){var b=[0,"",""],c=[1,"<table>","</table>"],d=[3,"<table><tbody><tr>","</tr></tbody></table>"],e=[1,"<select multiple='multiple'>","</select>"],f={thead:c,tbody:c,tfoot:c,tr:[2,"<table><tbody>","</tbody></table>"],td:d,th:d,option:e,optgroup:e},g=8>=a.a.W;a.a.ua=function(c,d){var e;if(v)if(v.parseHTML)e=v.parseHTML(c,d)||[];else {if((e=v.clean([c],d))&&e[0]){for(var l=e[0];l.parentNode&&11!==l.parentNode.nodeType;)l=l.parentNode;
	l.parentNode&&l.parentNode.removeChild(l);}}else {(e=d)||(e=w);var l=e.parentWindow||e.defaultView||A,p=a.a.Db(c).toLowerCase(),q=e.createElement("div"),t;t=(p=p.match(/^(?:\x3c!--.*?--\x3e\s*?)*?<([a-z]+)[\s>]/))&&f[p[1]]||b;p=t[0];t="ignored<div>"+t[1]+c+t[2]+"</div>";"function"==typeof l.innerShiv?q.appendChild(l.innerShiv(t)):(g&&e.body.appendChild(q),q.innerHTML=t,g&&q.parentNode.removeChild(q));for(;p--;)q=q.lastChild;e=a.a.la(q.lastChild.childNodes);}return e};a.a.Md=function(b,c){var d=a.a.ua(b,
	c);return d.length&&d[0].parentElement||a.a.Yb(d)};a.a.fc=function(b,c){a.a.Tb(b);c=a.a.f(c);if(null!==c&&c!==n)if("string"!=typeof c&&(c=c.toString()),v)v(b).html(c);else for(var d=a.a.ua(c,b.ownerDocument),e=0;e<d.length;e++)b.appendChild(d[e]);};})();a.b("utils.parseHtmlFragment",a.a.ua);a.b("utils.setHtml",a.a.fc);a.aa=function(){function b(c,e){if(c)if(8==c.nodeType){var f=a.aa.Uc(c.nodeValue);null!=f&&e.push({ud:c,Kd:f});}else if(1==c.nodeType)for(var f=0,g=c.childNodes,h=g.length;f<h;f++)b(g[f],
	e);}var c={};return {Xb:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);c[b]=a;return "\x3c!--[ko_memo:"+b+"]--\x3e"},bd:function(a,b){var f=c[a];if(f===n)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return f.apply(null,b||[]),!0}finally{delete c[a];}},cd:function(c,e){var f=
	[];b(c,f);for(var g=0,h=f.length;g<h;g++){var m=f[g].ud,k=[m];e&&a.a.Nb(k,e);a.aa.bd(f[g].Kd,k);m.nodeValue="";m.parentNode&&m.parentNode.removeChild(m);}},Uc:function(a){return (a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.aa);a.b("memoization.memoize",a.aa.Xb);a.b("memoization.unmemoize",a.aa.bd);a.b("memoization.parseMemoText",a.aa.Uc);a.b("memoization.unmemoizeDomNodeAndDescendants",a.aa.cd);a.na=function(){function b(){if(f)for(var b=f,c=0,d;h<f;)if(d=e[h++]){if(h>b){if(5E3<=
	++c){h=f;a.a.Gc(Error("'Too much recursion' after processing "+c+" task groups."));break}b=f;}try{d();}catch(p){a.a.Gc(p);}}}function c(){b();h=f=e.length=0;}var d,e=[],f=0,g=1,h=0;A.MutationObserver?d=function(a){var b=w.createElement("div");(new MutationObserver(a)).observe(b,{attributes:!0});return function(){b.classList.toggle("foo");}}(c):d=w&&"onreadystatechange"in w.createElement("script")?function(a){var b=w.createElement("script");b.onreadystatechange=function(){b.onreadystatechange=null;w.documentElement.removeChild(b);
	b=null;a();};w.documentElement.appendChild(b);}:function(a){setTimeout(a,0);};return {scheduler:d,zb:function(b){f||a.na.scheduler(c);e[f++]=b;return g++},cancel:function(a){a=a-(g-f);a>=h&&a<f&&(e[a]=null);},resetForTesting:function(){var a=f-h;h=f=e.length=0;return a},Sd:b}}();a.b("tasks",a.na);a.b("tasks.schedule",a.na.zb);a.b("tasks.runEarly",a.na.Sd);a.Ta={throttle:function(b,c){b.throttleEvaluation=c;var d=null;return a.$({read:b,write:function(e){clearTimeout(d);d=a.a.setTimeout(function(){b(e);},
	c);}})},rateLimit:function(a,c){var d,e,f;"number"==typeof c?d=c:(d=c.timeout,e=c.method);a.Hb=!1;f="function"==typeof e?e:"notifyWhenChangesStop"==e?Y:X;a.ub(function(a){return f(a,d,c)});},deferred:function(b,c){if(!0!==c)throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.");b.Hb||(b.Hb=!0,b.ub(function(c){var e,f=!1;return function(){if(!f){a.na.cancel(e);e=a.na.zb(c);try{f=!0,b.notifySubscribers(n,"dirty");}finally{f=
	!1;}}}}));},notify:function(a,c){a.equalityComparer="always"==c?null:K;}};var W={undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.Ta);a.ic=function(b,c,d){this.da=b;this.lc=c;this.mc=d;this.Ib=!1;this.fb=this.Jb=null;a.L(this,"dispose",this.s);a.L(this,"disposeWhenNodeIsRemoved",this.l);};a.ic.prototype.s=function(){this.Ib||(this.fb&&a.a.K.yb(this.Jb,this.fb),this.Ib=!0,this.mc(),this.da=this.lc=this.mc=this.Jb=this.fb=null);};a.ic.prototype.l=function(b){this.Jb=b;a.a.K.za(b,this.fb=this.s.bind(this));};
	a.T=function(){a.a.Ab(this,D);D.qb(this);};var D={qb:function(a){a.U={change:[]};a.sc=1;},subscribe:function(b,c,d){var e=this;d=d||"change";var f=new a.ic(e,c?b.bind(c):b,function(){a.a.Pa(e.U[d],f);e.hb&&e.hb(d);});e.Qa&&e.Qa(d);e.U[d]||(e.U[d]=[]);e.U[d].push(f);return f},notifySubscribers:function(b,c){c=c||"change";"change"===c&&this.Gb();if(this.Wa(c)){var d="change"===c&&this.ed||this.U[c].slice(0);try{a.u.xc();for(var e=0,f;f=d[e];++e)f.Ib||f.lc(b);}finally{a.u.end();}}},ob:function(){return this.sc},
	Dd:function(a){return this.ob()!==a},Gb:function(){++this.sc;},ub:function(b){var c=this,d=a.O(c),e,f,g,h,m;c.gb||(c.gb=c.notifySubscribers,c.notifySubscribers=Z);var k=b(function(){c.Ja=!1;d&&h===c&&(h=c.nc?c.nc():c());var a=f||m&&c.sb(g,h);m=f=e=!1;a&&c.gb(g=h);});c.qc=function(a,b){b&&c.Ja||(m=!b);c.ed=c.U.change.slice(0);c.Ja=e=!0;h=a;k();};c.pc=function(a){e||(g=a,c.gb(a,"beforeChange"));};c.rc=function(){m=!0;};c.gd=function(){c.sb(g,c.v(!0))&&(f=!0);};},Wa:function(a){return this.U[a]&&this.U[a].length},
	Bd:function(b){if(b)return this.U[b]&&this.U[b].length||0;var c=0;a.a.P(this.U,function(a,b){"dirty"!==a&&(c+=b.length);});return c},sb:function(a,c){return !this.equalityComparer||!this.equalityComparer(a,c)},toString:function(){return "[object Object]"},extend:function(b){var c=this;b&&a.a.P(b,function(b,e){var f=a.Ta[b];"function"==typeof f&&(c=f(c,e)||c);});return c}};a.L(D,"init",D.qb);a.L(D,"subscribe",D.subscribe);a.L(D,"extend",D.extend);a.L(D,"getSubscriptionsCount",D.Bd);a.a.Ba&&a.a.setPrototypeOf(D,
	Function.prototype);a.T.fn=D;a.Qc=function(a){return null!=a&&"function"==typeof a.subscribe&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.T);a.b("isSubscribable",a.Qc);a.S=a.u=function(){function b(a){d.push(e);e=a;}function c(){e=d.pop();}var d=[],e,f=0;return {xc:b,end:c,cc:function(b){if(e){if(!a.Qc(b))throw Error("Only subscribable things can act as dependencies");e.od.call(e.pd,b,b.fd||(b.fd=++f));}},G:function(a,d,e){try{return b(),a.apply(d,e||[])}finally{c();}},qa:function(){if(e)return e.o.qa()},
	Va:function(){if(e)return e.o.Va()},Ya:function(){if(e)return e.Ya},o:function(){if(e)return e.o}}}();a.b("computedContext",a.S);a.b("computedContext.getDependenciesCount",a.S.qa);a.b("computedContext.getDependencies",a.S.Va);a.b("computedContext.isInitial",a.S.Ya);a.b("computedContext.registerDependency",a.S.cc);a.b("ignoreDependencies",a.Yd=a.u.G);var I=a.a.Da("_latestValue");a.ta=function(b){function c(){if(0<arguments.length)return c.sb(c[I],arguments[0])&&(c.ya(),c[I]=arguments[0],c.xa()),this;
	a.u.cc(c);return c[I]}c[I]=b;a.a.Ba||a.a.extend(c,a.T.fn);a.T.fn.qb(c);a.a.Ab(c,F);a.options.deferUpdates&&a.Ta.deferred(c,!0);return c};var F={equalityComparer:K,v:function(){return this[I]},xa:function(){this.notifySubscribers(this[I],"spectate");this.notifySubscribers(this[I]);},ya:function(){this.notifySubscribers(this[I],"beforeChange");}};a.a.Ba&&a.a.setPrototypeOf(F,a.T.fn);var G=a.ta.Ma="__ko_proto__";F[G]=a.ta;a.O=function(b){if((b="function"==typeof b&&b[G])&&b!==F[G]&&b!==a.o.fn[G])throw Error("Invalid object that looks like an observable; possibly from another Knockout instance");
	return !!b};a.Za=function(b){return "function"==typeof b&&(b[G]===F[G]||b[G]===a.o.fn[G]&&b.Nc)};a.b("observable",a.ta);a.b("isObservable",a.O);a.b("isWriteableObservable",a.Za);a.b("isWritableObservable",a.Za);a.b("observable.fn",F);a.L(F,"peek",F.v);a.L(F,"valueHasMutated",F.xa);a.L(F,"valueWillMutate",F.ya);a.Ha=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.ta(b);a.a.Ab(b,
	a.Ha.fn);return b.extend({trackArrayChanges:!0})};a.Ha.fn={remove:function(b){for(var c=this.v(),d=[],e="function"!=typeof b||a.O(b)?function(a){return a===b}:b,f=0;f<c.length;f++){var g=c[f];if(e(g)){0===d.length&&this.ya();if(c[f]!==g)throw Error("Array modified during remove; cannot remove item");d.push(g);c.splice(f,1);f--;}}d.length&&this.xa();return d},removeAll:function(b){if(b===n){var c=this.v(),d=c.slice(0);this.ya();c.splice(0,c.length);this.xa();return d}return b?this.remove(function(c){return 0<=
	a.a.A(b,c)}):[]},destroy:function(b){var c=this.v(),d="function"!=typeof b||a.O(b)?function(a){return a===b}:b;this.ya();for(var e=c.length-1;0<=e;e--){var f=c[e];d(f)&&(f._destroy=!0);}this.xa();},destroyAll:function(b){return b===n?this.destroy(function(){return !0}):b?this.destroy(function(c){return 0<=a.a.A(b,c)}):[]},indexOf:function(b){var c=this();return a.a.A(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.ya(),this.v()[d]=c,this.xa());},sorted:function(a){var c=this().slice(0);
	return a?c.sort(a):c.sort()},reversed:function(){return this().slice(0).reverse()}};a.a.Ba&&a.a.setPrototypeOf(a.Ha.fn,a.ta.fn);a.a.D("pop push reverse shift sort splice unshift".split(" "),function(b){a.Ha.fn[b]=function(){var a=this.v();this.ya();this.zc(a,b,arguments);var d=a[b].apply(a,arguments);this.xa();return d===a?this:d};});a.a.D(["slice"],function(b){a.Ha.fn[b]=function(){var a=this();return a[b].apply(a,arguments)};});a.Pc=function(b){return a.O(b)&&"function"==typeof b.remove&&"function"==
	typeof b.push};a.b("observableArray",a.Ha);a.b("isObservableArray",a.Pc);a.Ta.trackArrayChanges=function(b,c){function d(){function c(){if(m){var d=[].concat(b.v()||[]),e;if(b.Wa("arrayChange")){if(!f||1<m)f=a.a.Pb(k,d,b.Ob);e=f;}k=d;f=null;m=0;e&&e.length&&b.notifySubscribers(e,"arrayChange");}}e?c():(e=!0,h=b.subscribe(function(){++m;},null,"spectate"),k=[].concat(b.v()||[]),f=null,g=b.subscribe(c));}b.Ob={};c&&"object"==typeof c&&a.a.extend(b.Ob,c);b.Ob.sparse=!0;if(!b.zc){var e=!1,f=null,g,h,m=0,
	k,l=b.Qa,p=b.hb;b.Qa=function(a){l&&l.call(b,a);"arrayChange"===a&&d();};b.hb=function(a){p&&p.call(b,a);"arrayChange"!==a||b.Wa("arrayChange")||(g&&g.s(),h&&h.s(),h=g=null,e=!1,k=n);};b.zc=function(b,c,d){function l(a,b,c){return k[k.length]={status:a,value:b,index:c}}if(e&&!m){var k=[],p=b.length,g=d.length,h=0;switch(c){case "push":h=p;case "unshift":for(c=0;c<g;c++)l("added",d[c],h+c);break;case "pop":h=p-1;case "shift":p&&l("deleted",b[h],h);break;case "splice":c=Math.min(Math.max(0,0>d[0]?p+d[0]:
	d[0]),p);for(var p=1===g?p:Math.min(c+(d[1]||0),p),g=c+g-2,h=Math.max(p,g),U=[],L=[],n=2;c<h;++c,++n)c<p&&L.push(l("deleted",b[c],c)),c<g&&U.push(l("added",d[n],c));a.a.Kc(L,U);break;default:return}f=k;}};}};var r=a.a.Da("_state");a.o=a.$=function(b,c,d){function e(){if(0<arguments.length){if("function"===typeof f)f.apply(g.nb,arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");return this}g.ra||
	a.u.cc(e);(g.ka||g.J&&e.Xa())&&e.ha();return g.X}"object"===typeof b?d=b:(d=d||{},b&&(d.read=b));if("function"!=typeof d.read)throw Error("Pass a function that returns the value of the ko.computed");var f=d.write,g={X:n,sa:!0,ka:!0,rb:!1,jc:!1,ra:!1,wb:!1,J:!1,Wc:d.read,nb:c||d.owner,l:d.disposeWhenNodeIsRemoved||d.l||null,Sa:d.disposeWhen||d.Sa,Rb:null,I:{},V:0,Ic:null};e[r]=g;e.Nc="function"===typeof f;a.a.Ba||a.a.extend(e,a.T.fn);a.T.fn.qb(e);a.a.Ab(e,C);d.pure?(g.wb=!0,g.J=!0,a.a.extend(e,da)):
	d.deferEvaluation&&a.a.extend(e,ea);a.options.deferUpdates&&a.Ta.deferred(e,!0);g.l&&(g.jc=!0,g.l.nodeType||(g.l=null));g.J||d.deferEvaluation||e.ha();g.l&&e.ja()&&a.a.K.za(g.l,g.Rb=function(){e.s();});return e};var C={equalityComparer:K,qa:function(){return this[r].V},Va:function(){var b=[];a.a.P(this[r].I,function(a,d){b[d.Ka]=d.da;});return b},Vb:function(b){if(!this[r].V)return !1;var c=this.Va();return -1!==a.a.A(c,b)?!0:!!a.a.Lb(c,function(a){return a.Vb&&a.Vb(b)})},uc:function(a,c,d){if(this[r].wb&&
	c===this)throw Error("A 'pure' computed must not be called recursively");this[r].I[a]=d;d.Ka=this[r].V++;d.La=c.ob();},Xa:function(){var a,c,d=this[r].I;for(a in d)if(Object.prototype.hasOwnProperty.call(d,a)&&(c=d[a],this.Ia&&c.da.Ja||c.da.Dd(c.La)))return !0},Jd:function(){this.Ia&&!this[r].rb&&this.Ia(!1);},ja:function(){var a=this[r];return a.ka||0<a.V},Rd:function(){this.Ja?this[r].ka&&(this[r].sa=!0):this.Hc();},$c:function(a){if(a.Hb){var c=a.subscribe(this.Jd,this,"dirty"),d=a.subscribe(this.Rd,
	this);return {da:a,s:function(){c.s();d.s();}}}return a.subscribe(this.Hc,this)},Hc:function(){var b=this,c=b.throttleEvaluation;c&&0<=c?(clearTimeout(this[r].Ic),this[r].Ic=a.a.setTimeout(function(){b.ha(!0);},c)):b.Ia?b.Ia(!0):b.ha(!0);},ha:function(b){var c=this[r],d=c.Sa,e=!1;if(!c.rb&&!c.ra){if(c.l&&!a.a.Sb(c.l)||d&&d()){if(!c.jc){this.s();return}}else c.jc=!1;c.rb=!0;try{e=this.zd(b);}finally{c.rb=!1;}return e}},zd:function(b){var c=this[r],d=!1,e=c.wb?n:!c.V,d={qd:this,mb:c.I,Qb:c.V};a.u.xc({pd:d,
	od:ba,o:this,Ya:e});c.I={};c.V=0;var f=this.yd(c,d);c.V?d=this.sb(c.X,f):(this.s(),d=!0);d&&(c.J?this.Gb():this.notifySubscribers(c.X,"beforeChange"),c.X=f,this.notifySubscribers(c.X,"spectate"),!c.J&&b&&this.notifySubscribers(c.X),this.rc&&this.rc());e&&this.notifySubscribers(c.X,"awake");return d},yd:function(b,c){try{var d=b.Wc;return b.nb?d.call(b.nb):d()}finally{a.u.end(),c.Qb&&!b.J&&a.a.P(c.mb,aa),b.sa=b.ka=!1;}},v:function(a){var c=this[r];(c.ka&&(a||!c.V)||c.J&&this.Xa())&&this.ha();return c.X},
	ub:function(b){a.T.fn.ub.call(this,b);this.nc=function(){this[r].J||(this[r].sa?this.ha():this[r].ka=!1);return this[r].X};this.Ia=function(a){this.pc(this[r].X);this[r].ka=!0;a&&(this[r].sa=!0);this.qc(this,!a);};},s:function(){var b=this[r];!b.J&&b.I&&a.a.P(b.I,function(a,b){b.s&&b.s();});b.l&&b.Rb&&a.a.K.yb(b.l,b.Rb);b.I=n;b.V=0;b.ra=!0;b.sa=!1;b.ka=!1;b.J=!1;b.l=n;b.Sa=n;b.Wc=n;this.Nc||(b.nb=n);}},da={Qa:function(b){var c=this,d=c[r];if(!d.ra&&d.J&&"change"==b){d.J=!1;if(d.sa||c.Xa())d.I=null,d.V=
	0,c.ha()&&c.Gb();else {var e=[];a.a.P(d.I,function(a,b){e[b.Ka]=a;});a.a.D(e,function(a,b){var e=d.I[a],m=c.$c(e.da);m.Ka=b;m.La=e.La;d.I[a]=m;});c.Xa()&&c.ha()&&c.Gb();}d.ra||c.notifySubscribers(d.X,"awake");}},hb:function(b){var c=this[r];c.ra||"change"!=b||this.Wa("change")||(a.a.P(c.I,function(a,b){b.s&&(c.I[a]={da:b.da,Ka:b.Ka,La:b.La},b.s());}),c.J=!0,this.notifySubscribers(n,"asleep"));},ob:function(){var b=this[r];b.J&&(b.sa||this.Xa())&&this.ha();return a.T.fn.ob.call(this)}},ea={Qa:function(a){"change"!=
	a&&"beforeChange"!=a||this.v();}};a.a.Ba&&a.a.setPrototypeOf(C,a.T.fn);var N=a.ta.Ma;C[N]=a.o;a.Oc=function(a){return "function"==typeof a&&a[N]===C[N]};a.Fd=function(b){return a.Oc(b)&&b[r]&&b[r].wb};a.b("computed",a.o);a.b("dependentObservable",a.o);a.b("isComputed",a.Oc);a.b("isPureComputed",a.Fd);a.b("computed.fn",C);a.L(C,"peek",C.v);a.L(C,"dispose",C.s);a.L(C,"isActive",C.ja);a.L(C,"getDependenciesCount",C.qa);a.L(C,"getDependencies",C.Va);a.xb=function(b,c){if("function"===typeof b)return a.o(b,
	c,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.o(b,c)};a.b("pureComputed",a.xb);(function(){function b(a,f,g){g=g||new d;a=f(a);if("object"!=typeof a||null===a||a===n||a instanceof RegExp||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var h=a instanceof Array?[]:{};g.save(a,h);c(a,function(c){var d=f(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":h[c]=d;break;case "object":case "undefined":var l=g.get(d);h[c]=l!==
	n?l:b(d,f,g);}});return h}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON");}else for(c in a)b(c);}function d(){this.keys=[];this.values=[];}a.ad=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");return b(c,function(b){for(var c=0;a.O(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.ad(b);return a.a.hc(b,c,d)};d.prototype={constructor:d,save:function(b,c){var d=a.a.A(this.keys,
	b);0<=d?this.values[d]=c:(this.keys.push(b),this.values.push(c));},get:function(b){b=a.a.A(this.keys,b);return 0<=b?this.values[b]:n}};})();a.b("toJS",a.ad);a.b("toJSON",a.toJSON);a.Wd=function(b,c,d){function e(c){var e=a.xb(b,d).extend({ma:"always"}),h=e.subscribe(function(a){a&&(h.s(),c(a));});e.notifySubscribers(e.v());return h}return "function"!==typeof Promise||c?e(c.bind(d)):new Promise(e)};a.b("when",a.Wd);(function(){a.w={M:function(b){switch(a.a.R(b)){case "option":return !0===b.__ko__hasDomDataOptionValue__?
	a.a.g.get(b,a.c.options.$b):7>=a.a.W?b.getAttributeNode("value")&&b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.w.M(b.options[b.selectedIndex]):n;default:return b.value}},cb:function(b,c,d){switch(a.a.R(b)){case "option":"string"===typeof c?(a.a.g.set(b,a.c.options.$b,n),"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__,b.value=c):(a.a.g.set(b,a.c.options.$b,c),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===
	typeof c?c:"");break;case "select":if(""===c||null===c)c=n;for(var e=-1,f=0,g=b.options.length,h;f<g;++f)if(h=a.w.M(b.options[f]),h==c||""===h&&c===n){e=f;break}if(d||0<=e||c===n&&1<b.size)b.selectedIndex=e,6===a.a.W&&a.a.setTimeout(function(){b.selectedIndex=e;},0);break;default:if(null===c||c===n)c="";b.value=c;}}};})();a.b("selectExtensions",a.w);a.b("selectExtensions.readValue",a.w.M);a.b("selectExtensions.writeValue",a.w.cb);a.m=function(){function b(b){b=a.a.Db(b);123===b.charCodeAt(0)&&(b=b.slice(1,
	-1));b+="\n,";var c=[],d=b.match(e),p,q=[],h=0;if(1<d.length){for(var x=0,B;B=d[x];++x){var u=B.charCodeAt(0);if(44===u){if(0>=h){c.push(p&&q.length?{key:p,value:q.join("")}:{unknown:p||q.join("")});p=h=0;q=[];continue}}else if(58===u){if(!h&&!p&&1===q.length){p=q.pop();continue}}else if(47===u&&1<B.length&&(47===B.charCodeAt(1)||42===B.charCodeAt(1)))continue;else 47===u&&x&&1<B.length?(u=d[x-1].match(f))&&!g[u[0]]&&(b=b.substr(b.indexOf(B)+1),d=b.match(e),x=-1,B="/"):40===u||123===u||91===u?++h:
	41===u||125===u||93===u?--h:p||q.length||34!==u&&39!==u||(B=B.slice(1,-1));q.push(B);}if(0<h)throw Error("Unbalanced parentheses, braces, or brackets");}return c}var c=["true","false","null","undefined"],d=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,e=RegExp("\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|`(?:\\\\.|[^`])*`|/\\*(?:[^*]|\\*+[^*/])*\\*+/|//.*\n|/(?:\\\\.|[^/])+/w*|[^\\s:,/][^,\"'`{}()/:[\\]]*[^\\s,\"'`{}()/:[\\]]|[^\\s]","g"),f=/[\])"'A-Za-z0-9_$]+$/,g={"in":1,"return":1,"typeof":1},
	h={};return {Ra:[],wa:h,ac:b,vb:function(e,f){function l(b,e){var f;if(!x){var k=a.getBindingHandler(b);if(k&&k.preprocess&&!(e=k.preprocess(e,b,l)))return;if(k=h[b])f=e,0<=a.a.A(c,f)?f=!1:(k=f.match(d),f=null===k?!1:k[1]?"Object("+k[1]+")"+k[2]:f),k=f;k&&q.push("'"+("string"==typeof h[b]?h[b]:b)+"':function(_z){"+f+"=_z}");}g&&(e="function(){return "+e+" }");p.push("'"+b+"':"+e);}f=f||{};var p=[],q=[],g=f.valueAccessors,x=f.bindingParams,B="string"===typeof e?b(e):e;a.a.D(B,function(a){l(a.key||a.unknown,
	a.value);});q.length&&l("_ko_property_writers","{"+q.join(",")+" }");return p.join(",")},Id:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==b)return !0;return !1},eb:function(b,c,d,e,f){if(b&&a.O(b))!a.Za(b)||f&&b.v()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e);}}}();a.b("expressionRewriting",a.m);a.b("expressionRewriting.bindingRewriteValidators",a.m.Ra);a.b("expressionRewriting.parseObjectLiteral",a.m.ac);a.b("expressionRewriting.preProcessBindings",a.m.vb);a.b("expressionRewriting._twoWayBindings",
	a.m.wa);a.b("jsonExpressionRewriting",a.m);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.m.vb);(function(){function b(a){return 8==a.nodeType&&g.test(f?a.text:a.nodeValue)}function c(a){return 8==a.nodeType&&h.test(f?a.text:a.nodeValue)}function d(d,e){for(var f=d,h=1,g=[];f=f.nextSibling;){if(c(f)&&(a.a.g.set(f,k,!0),h--,0===h))return g;g.push(f);b(f)&&h++;}if(!e)throw Error("Cannot find closing comment tag to match: "+d.nodeValue);return null}function e(a,b){var c=d(a,b);return c?
	0<c.length?c[c.length-1].nextSibling:a.nextSibling:null}var f=w&&"\x3c!--test--\x3e"===w.createComment("test").text,g=f?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,h=f?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,m={ul:!0,ol:!0},k="__ko_matchedEndComment__";a.h={ea:{},childNodes:function(a){return b(a)?d(a):a.childNodes},Ea:function(c){if(b(c)){c=a.h.childNodes(c);for(var d=0,e=c.length;d<e;d++)a.removeNode(c[d]);}else a.a.Tb(c);},va:function(c,d){if(b(c)){a.h.Ea(c);for(var e=
	c.nextSibling,f=0,k=d.length;f<k;f++)e.parentNode.insertBefore(d[f],e);}else a.a.va(c,d);},Vc:function(a,c){var d;b(a)?(d=a.nextSibling,a=a.parentNode):d=a.firstChild;d?c!==d&&a.insertBefore(c,d):a.appendChild(c);},Wb:function(c,d,e){e?(e=e.nextSibling,b(c)&&(c=c.parentNode),e?d!==e&&c.insertBefore(d,e):c.appendChild(d)):a.h.Vc(c,d);},firstChild:function(a){if(b(a))return !a.nextSibling||c(a.nextSibling)?null:a.nextSibling;if(a.firstChild&&c(a.firstChild))throw Error("Found invalid end comment, as the first child of "+
	a);return a.firstChild},nextSibling:function(d){b(d)&&(d=e(d));if(d.nextSibling&&c(d.nextSibling)){var f=d.nextSibling;if(c(f)&&!a.a.g.get(f,k))throw Error("Found end comment without a matching opening comment, as child of "+d);return null}return d.nextSibling},Cd:b,Vd:function(a){return (a=(f?a.text:a.nodeValue).match(g))?a[1]:null},Sc:function(d){if(m[a.a.R(d)]){var f=d.firstChild;if(f){do if(1===f.nodeType){var k;k=f.firstChild;var h=null;if(k){do if(h)h.push(k);else if(b(k)){var g=e(k,!0);g?k=
	g:h=[k];}else c(k)&&(h=[k]);while(k=k.nextSibling)}if(k=h)for(h=f.nextSibling,g=0;g<k.length;g++)h?d.insertBefore(k[g],h):d.appendChild(k[g]);}while(f=f.nextSibling)}}}};})();a.b("virtualElements",a.h);a.b("virtualElements.allowedBindings",a.h.ea);a.b("virtualElements.emptyNode",a.h.Ea);a.b("virtualElements.insertAfter",a.h.Wb);a.b("virtualElements.prepend",a.h.Vc);a.b("virtualElements.setDomNodeChildren",a.h.va);(function(){a.ga=function(){this.nd={};};a.a.extend(a.ga.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=
	b.getAttribute("data-bind")||a.j.getComponentNameForNode(b);case 8:return a.h.Cd(b);default:return !1}},getBindings:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b):null;return a.j.tc(d,b,c,!1)},getBindingAccessors:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b,{valueAccessors:!0}):null;return a.j.tc(d,b,c,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.h.Vd(b);default:return null}},
	parseBindingsString:function(b,c,d,e){try{var f=this.nd,g=b+(e&&e.valueAccessors||""),h;if(!(h=f[g])){var m,k="with($context){with($data||{}){return{"+a.m.vb(b,e)+"}}}";m=new Function("$context","$element",k);h=f[g]=m;}return h(c,d)}catch(l){throw l.message="Unable to parse bindings.\nBindings value: "+b+"\nMessage: "+l.message,l;}}});a.ga.instance=new a.ga;})();a.b("bindingProvider",a.ga);(function(){function b(b){var c=(b=a.a.g.get(b,z))&&b.N;c&&(b.N=null,c.Tc());}function c(c,d,e){this.node=c;this.yc=
	d;this.kb=[];this.H=!1;d.N||a.a.K.za(c,b);e&&e.N&&(e.N.kb.push(c),this.Kb=e);}function d(a){return function(){return a}}function e(a){return a()}function f(b){return a.a.Ga(a.u.G(b),function(a,c){return function(){return b()[c]}})}function g(b,c,e){return "function"===typeof b?f(b.bind(null,c,e)):a.a.Ga(b,d)}function h(a,b){return f(this.getBindings.bind(this,a,b))}function m(b,c){var d=a.h.firstChild(c);if(d){var e,f=a.ga.instance,l=f.preprocessNode;if(l){for(;e=d;)d=a.h.nextSibling(e),l.call(f,e);
	d=a.h.firstChild(c);}for(;e=d;)d=a.h.nextSibling(e),k(b,e);}a.i.ma(c,a.i.H);}function k(b,c){var d=b,e=1===c.nodeType;e&&a.h.Sc(c);if(e||a.ga.instance.nodeHasBindings(c))d=p(c,null,b).bindingContextForDescendants;d&&!u[a.a.R(c)]&&m(d,c);}function l(b){var c=[],d={},e=[];a.a.P(b,function ca(f){if(!d[f]){var k=a.getBindingHandler(f);k&&(k.after&&(e.push(f),a.a.D(k.after,function(c){if(b[c]){if(-1!==a.a.A(e,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+e.join(", "));
	ca(c);}}),e.length--),c.push({key:f,Mc:k}));d[f]=!0;}});return c}function p(b,c,d){var f=a.a.g.Ub(b,z,{}),k=f.hd;if(!c){if(k)throw Error("You cannot apply bindings multiple times to the same element.");f.hd=!0;}k||(f.context=d);f.Zb||(f.Zb={});var g;if(c&&"function"!==typeof c)g=c;else {var p=a.ga.instance,q=p.getBindingAccessors||h,m=a.$(function(){if(g=c?c(d,b):q.call(p,b,d)){if(d[t])d[t]();if(d[B])d[B]();}return g},null,{l:b});g&&m.ja()||(m=null);}var x=d,u;if(g){var J=function(){return a.a.Ga(m?m():
	g,e)},r=m?function(a){return function(){return e(m()[a])}}:function(a){return g[a]};J.get=function(a){return g[a]&&e(r(a))};J.has=function(a){return a in g};a.i.H in g&&a.i.subscribe(b,a.i.H,function(){var c=(0, g[a.i.H])();if(c){var d=a.h.childNodes(b);d.length&&c(d,a.Ec(d[0]));}});a.i.pa in g&&(x=a.i.Cb(b,d),a.i.subscribe(b,a.i.pa,function(){var c=(0, g[a.i.pa])();c&&a.h.firstChild(b)&&c(b);}));f=l(g);a.a.D(f,function(c){var d=c.Mc.init,e=c.Mc.update,f=c.key;if(8===b.nodeType&&!a.h.ea[f])throw Error("The binding '"+
	f+"' cannot be used with virtual elements");try{"function"==typeof d&&a.u.G(function(){var a=d(b,r(f),J,x.$data,x);if(a&&a.controlsDescendantBindings){if(u!==n)throw Error("Multiple bindings ("+u+" and "+f+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");u=f;}}),"function"==typeof e&&a.$(function(){e(b,r(f),J,x.$data,x);},null,{l:b});}catch(k){throw k.message='Unable to process binding "'+f+": "+g[f]+'"\nMessage: '+k.message,
	k;}});}f=u===n;return {shouldBindDescendants:f,bindingContextForDescendants:f&&x}}function q(b,c){return b&&b instanceof a.fa?b:new a.fa(b,n,n,c)}var t=a.a.Da("_subscribable"),x=a.a.Da("_ancestorBindingInfo"),B=a.a.Da("_dataDependency");a.c={};var u={script:!0,textarea:!0,template:!0};a.getBindingHandler=function(b){return a.c[b]};var J={};a.fa=function(b,c,d,e,f){function k(){var b=p?h():h,f=a.a.f(b);c?(a.a.extend(l,c),x in c&&(l[x]=c[x])):(l.$parents=[],l.$root=f,l.ko=a);l[t]=q;g?f=l.$data:(l.$rawData=
	b,l.$data=f);d&&(l[d]=f);e&&e(l,c,f);if(c&&c[t]&&!a.S.o().Vb(c[t]))c[t]();m&&(l[B]=m);return l.$data}var l=this,g=b===J,h=g?n:b,p="function"==typeof h&&!a.O(h),q,m=f&&f.dataDependency;f&&f.exportDependencies?k():(q=a.xb(k),q.v(),q.ja()?q.equalityComparer=null:l[t]=n);};a.fa.prototype.createChildContext=function(b,c,d,e){!e&&c&&"object"==typeof c&&(e=c,c=e.as,d=e.extend);if(c&&e&&e.noChildContext){var f="function"==typeof b&&!a.O(b);return new a.fa(J,this,null,function(a){d&&d(a);a[c]=f?b():b;},e)}return new a.fa(b,
	this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);d&&d(a);},e)};a.fa.prototype.extend=function(b,c){return new a.fa(J,this,null,function(c){a.a.extend(c,"function"==typeof b?b(c):b);},c)};var z=a.a.g.Z();c.prototype.Tc=function(){this.Kb&&this.Kb.N&&this.Kb.N.sd(this.node);};c.prototype.sd=function(b){a.a.Pa(this.kb,b);!this.kb.length&&this.H&&this.Cc();};c.prototype.Cc=function(){this.H=!0;this.yc.N&&!this.kb.length&&(this.yc.N=
	null,a.a.K.yb(this.node,b),a.i.ma(this.node,a.i.pa),this.Tc());};a.i={H:"childrenComplete",pa:"descendantsComplete",subscribe:function(b,c,d,e,f){var k=a.a.g.Ub(b,z,{});k.Fa||(k.Fa=new a.T);f&&f.notifyImmediately&&k.Zb[c]&&a.u.G(d,e,[b]);return k.Fa.subscribe(d,e,c)},ma:function(b,c){var d=a.a.g.get(b,z);if(d&&(d.Zb[c]=!0,d.Fa&&d.Fa.notifySubscribers(b,c),c==a.i.H))if(d.N)d.N.Cc();else if(d.N===n&&d.Fa&&d.Fa.Wa(a.i.pa))throw Error("descendantsComplete event not supported for bindings on this node");
	},Cb:function(b,d){var e=a.a.g.Ub(b,z,{});e.N||(e.N=new c(b,e,d[x]));return d[x]==e?d:d.extend(function(a){a[x]=e;})}};a.Td=function(b){return (b=a.a.g.get(b,z))&&b.context};a.ib=function(b,c,d){1===b.nodeType&&a.h.Sc(b);return p(b,c,q(d))};a.ld=function(b,c,d){d=q(d);return a.ib(b,g(c,d,b),d)};a.Oa=function(a,b){1!==b.nodeType&&8!==b.nodeType||m(q(a),b);};a.vc=function(a,b,c){!v&&A.jQuery&&(v=A.jQuery);if(2>arguments.length){if(b=w.body,!b)throw Error("ko.applyBindings: could not find document.body; has the document been loaded?");
	}else if(!b||1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");k(q(a,c),b);};a.Dc=function(b){return !b||1!==b.nodeType&&8!==b.nodeType?n:a.Td(b)};a.Ec=function(b){return (b=a.Dc(b))?b.$data:n};a.b("bindingHandlers",a.c);a.b("bindingEvent",a.i);a.b("bindingEvent.subscribe",a.i.subscribe);a.b("bindingEvent.startPossiblyAsyncContentBinding",a.i.Cb);a.b("applyBindings",a.vc);a.b("applyBindingsToDescendants",a.Oa);
	a.b("applyBindingAccessorsToNode",a.ib);a.b("applyBindingsToNode",a.ld);a.b("contextFor",a.Dc);a.b("dataFor",a.Ec);})();(function(b){function c(c,e){var k=Object.prototype.hasOwnProperty.call(f,c)?f[c]:b,l;k?k.subscribe(e):(k=f[c]=new a.T,k.subscribe(e),d(c,function(b,d){var e=!(!d||!d.synchronous);g[c]={definition:b,Gd:e};delete f[c];l||e?k.notifySubscribers(b):a.na.zb(function(){k.notifySubscribers(b);});}),l=!0);}function d(a,b){e("getConfig",[a],function(c){c?e("loadComponent",[a,c],function(a){b(a,
	c);}):b(null,null);});}function e(c,d,f,l){l||(l=a.j.loaders.slice(0));var g=l.shift();if(g){var q=g[c];if(q){var t=!1;if(q.apply(g,d.concat(function(a){t?f(null):null!==a?f(a):e(c,d,f,l);}))!==b&&(t=!0,!g.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");}else e(c,d,f,l);}else f(null);}var f={},g={};a.j={get:function(d,e){var f=Object.prototype.hasOwnProperty.call(g,d)?g[d]:b;f?f.Gd?a.u.G(function(){e(f.definition);}):
	a.na.zb(function(){e(f.definition);}):c(d,e);},Bc:function(a){delete g[a];},oc:e};a.j.loaders=[];a.b("components",a.j);a.b("components.get",a.j.get);a.b("components.clearCachedDefinition",a.j.Bc);})();(function(){function b(b,c,d,e){function g(){0===--B&&e(h);}var h={},B=2,u=d.template;d=d.viewModel;u?f(c,u,function(c){a.j.oc("loadTemplate",[b,c],function(a){h.template=a;g();});}):g();d?f(c,d,function(c){a.j.oc("loadViewModel",[b,c],function(a){h[m]=a;g();});}):g();}function c(a,b,d){if("function"===typeof b)d(function(a){return new b(a)});
	else if("function"===typeof b[m])d(b[m]);else if("instance"in b){var e=b.instance;d(function(){return e});}else "viewModel"in b?c(a,b.viewModel,d):a("Unknown viewModel value: "+b);}function d(b){switch(a.a.R(b)){case "script":return a.a.ua(b.text);case "textarea":return a.a.ua(b.value);case "template":if(e(b.content))return a.a.Ca(b.content.childNodes)}return a.a.Ca(b.childNodes)}function e(a){return A.DocumentFragment?a instanceof DocumentFragment:a&&11===a.nodeType}function f(a,b,c){"string"===typeof b.require?
	T||A.require?(T||A.require)([b.require],function(a){a&&"object"===typeof a&&a.Xd&&a["default"]&&(a=a["default"]);c(a);}):a("Uses require, but no AMD loader is present"):c(b);}function g(a){return function(b){throw Error("Component '"+a+"': "+b);}}var h={};a.j.register=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.j.tb(b))throw Error("Component "+b+" is already registered");h[b]=c;};a.j.tb=function(a){return Object.prototype.hasOwnProperty.call(h,a)};a.j.unregister=function(b){delete h[b];
	a.j.Bc(b);};a.j.Fc={getConfig:function(b,c){c(a.j.tb(b)?h[b]:null);},loadComponent:function(a,c,d){var e=g(a);f(e,c,function(c){b(a,e,c,d);});},loadTemplate:function(b,c,f){b=g(b);if("string"===typeof c)f(a.a.ua(c));else if(c instanceof Array)f(c);else if(e(c))f(a.a.la(c.childNodes));else if(c.element)if(c=c.element,A.HTMLElement?c instanceof HTMLElement:c&&c.tagName&&1===c.nodeType)f(d(c));else if("string"===typeof c){var h=w.getElementById(c);h?f(d(h)):b("Cannot find element with ID "+c);}else b("Unknown element type: "+
	c);else b("Unknown template value: "+c);},loadViewModel:function(a,b,d){c(g(a),b,d);}};var m="createViewModel";a.b("components.register",a.j.register);a.b("components.isRegistered",a.j.tb);a.b("components.unregister",a.j.unregister);a.b("components.defaultLoader",a.j.Fc);a.j.loaders.push(a.j.Fc);a.j.dd=h;})();(function(){function b(b,e){var f=b.getAttribute("params");if(f){var f=c.parseBindingsString(f,e,b,{valueAccessors:!0,bindingParams:!0}),f=a.a.Ga(f,function(c){return a.o(c,null,{l:b})}),g=a.a.Ga(f,
	function(c){var e=c.v();return c.ja()?a.o({read:function(){return a.a.f(c())},write:a.Za(e)&&function(a){c()(a);},l:b}):e});Object.prototype.hasOwnProperty.call(g,"$raw")||(g.$raw=f);return g}return {$raw:{}}}a.j.getComponentNameForNode=function(b){var c=a.a.R(b);if(a.j.tb(c)&&(-1!=c.indexOf("-")||"[object HTMLUnknownElement]"==""+b||8>=a.a.W&&b.tagName===c))return c};a.j.tc=function(c,e,f,g){if(1===e.nodeType){var h=a.j.getComponentNameForNode(e);if(h){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');
	var m={name:h,params:b(e,f)};c.component=g?function(){return m}:m;}}return c};var c=new a.ga;9>a.a.W&&(a.j.register=function(a){return function(b){return a.apply(this,arguments)}}(a.j.register),w.createDocumentFragment=function(b){return function(){var c=b(),f=a.j.dd;return c}}(w.createDocumentFragment));})();(function(){function b(b,c,d){c=c.template;if(!c)throw Error("Component '"+b+"' has no template");b=a.a.Ca(c);a.h.va(d,b);}function c(a,b,c){var d=a.createViewModel;return d?d.call(a,
	b,c):b}var d=0;a.c.component={init:function(e,f,g,h,m){function k(){var a=l&&l.dispose;"function"===typeof a&&a.call(l);q&&q.s();p=l=q=null;}var l,p,q,t=a.a.la(a.h.childNodes(e));a.h.Ea(e);a.a.K.za(e,k);a.o(function(){var g=a.a.f(f()),h,u;"string"===typeof g?h=g:(h=a.a.f(g.name),u=a.a.f(g.params));if(!h)throw Error("No component name specified");var n=a.i.Cb(e,m),z=p=++d;a.j.get(h,function(d){if(p===z){k();if(!d)throw Error("Unknown component '"+h+"'");b(h,d,e);var f=c(d,u,{element:e,templateNodes:t});
	d=n.createChildContext(f,{extend:function(a){a.$component=f;a.$componentTemplateNodes=t;}});f&&f.koDescendantsComplete&&(q=a.i.subscribe(e,a.i.pa,f.koDescendantsComplete,f));l=f;a.Oa(d,e);}});},null,{l:e});return {controlsDescendantBindings:!0}}};a.h.ea.component=!0;})();var V={"class":"className","for":"htmlFor"};a.c.attr={update:function(b,c){var d=a.a.f(c())||{};a.a.P(d,function(c,d){d=a.a.f(d);var g=c.indexOf(":"),g="lookupNamespaceURI"in b&&0<g&&b.lookupNamespaceURI(c.substr(0,g)),h=!1===d||null===
	d||d===n;h?g?b.removeAttributeNS(g,c):b.removeAttribute(c):d=d.toString();8>=a.a.W&&c in V?(c=V[c],h?b.removeAttribute(c):b[c]=d):h||(g?b.setAttributeNS(g,c,d):b.setAttribute(c,d));"name"===c&&a.a.Yc(b,h?"":d);});}};(function(){a.c.checked={after:["value","attr"],init:function(b,c,d){function e(){var e=b.checked,f=g();if(!a.S.Ya()&&(e||!m&&!a.S.qa())){var k=a.u.G(c);if(l){var q=p?k.v():k,z=t;t=f;z!==f?e&&(a.a.Na(q,f,!0),a.a.Na(q,z,!1)):a.a.Na(q,f,e);p&&a.Za(k)&&k(q);}else h&&(f===n?f=e:e||(f=n)),a.m.eb(k,
	d,"checked",f,!0);}}function f(){var d=a.a.f(c()),e=g();l?(b.checked=0<=a.a.A(d,e),t=e):b.checked=h&&e===n?!!d:g()===d;}var g=a.xb(function(){if(d.has("checkedValue"))return a.a.f(d.get("checkedValue"));if(q)return d.has("value")?a.a.f(d.get("value")):b.value}),h="checkbox"==b.type,m="radio"==b.type;if(h||m){var k=c(),l=h&&a.a.f(k)instanceof Array,p=!(l&&k.push&&k.splice),q=m||l,t=l?g():n;m&&!b.name&&a.c.uniqueName.init(b,function(){return !0});a.o(e,null,{l:b});a.a.B(b,"click",e);a.o(f,null,{l:b});
	k=n;}}};a.m.wa.checked=!0;a.c.checkedValue={update:function(b,c){b.value=a.a.f(c());}};})();a.c["class"]={update:function(b,c){var d=a.a.Db(a.a.f(c()));a.a.Eb(b,b.__ko__cssValue,!1);b.__ko__cssValue=d;a.a.Eb(b,d,!0);}};a.c.css={update:function(b,c){var d=a.a.f(c());null!==d&&"object"==typeof d?a.a.P(d,function(c,d){d=a.a.f(d);a.a.Eb(b,c,d);}):a.c["class"].update(b,c);}};a.c.enable={update:function(b,c){var d=a.a.f(c());d&&b.disabled?b.removeAttribute("disabled"):d||b.disabled||(b.disabled=!0);}};a.c.disable=
	{update:function(b,c){a.c.enable.update(b,function(){return !a.a.f(c())});}};a.c.event={init:function(b,c,d,e,f){var g=c()||{};a.a.P(g,function(g){"string"==typeof g&&a.a.B(b,g,function(b){var k,l=c()[g];if(l){try{var p=a.a.la(arguments);e=f.$data;p.unshift(e);k=l.apply(e,p);}finally{!0!==k&&(b.preventDefault?b.preventDefault():b.returnValue=!1);}!1===d.get(g+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation());}});});}};a.c.foreach={Rc:function(b){return function(){var c=b(),d=a.a.bc(c);
	if(!d||"number"==typeof d.length)return {foreach:c,templateEngine:a.ba.Ma};a.a.f(c);return {foreach:d.data,as:d.as,noChildContext:d.noChildContext,includeDestroyed:d.includeDestroyed,afterAdd:d.afterAdd,beforeRemove:d.beforeRemove,afterRender:d.afterRender,beforeMove:d.beforeMove,afterMove:d.afterMove,templateEngine:a.ba.Ma}}},init:function(b,c){return a.c.template.init(b,a.c.foreach.Rc(c))},update:function(b,c,d,e,f){return a.c.template.update(b,a.c.foreach.Rc(c),d,e,f)}};a.m.Ra.foreach=!1;a.h.ea.foreach=
	!0;a.c.hasfocus={init:function(b,c,d){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement;}catch(l){g=f.body;}e=g===b;}f=c();a.m.eb(f,d,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1;}var f=e.bind(null,!0),g=e.bind(null,!1);a.a.B(b,"focus",f);a.a.B(b,"focusin",f);a.a.B(b,"blur",g);a.a.B(b,"focusout",g);b.__ko_hasfocusLastValue=!1;},update:function(b,c){var d=!!a.a.f(c());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===
	d||(d?b.focus():b.blur(),!d&&b.__ko_hasfocusLastValue&&b.ownerDocument.body.focus(),a.u.G(a.a.Fb,null,[b,d?"focusin":"focusout"]));}};a.m.wa.hasfocus=!0;a.c.hasFocus=a.c.hasfocus;a.m.wa.hasFocus="hasfocus";a.c.html={init:function(){return {controlsDescendantBindings:!0}},update:function(b,c){a.a.fc(b,c());}};(function(){function b(b,d,e){a.c[b]={init:function(b,c,h,m,k){var l,p,q={},t,x,n;if(d){m=h.get("as");var u=h.get("noChildContext");n=!(m&&u);q={as:m,noChildContext:u,exportDependencies:n};}x=(t=
	"render"==h.get("completeOn"))||h.has(a.i.pa);a.o(function(){var h=a.a.f(c()),m=!e!==!h,u=!p,r;if(n||m!==l){x&&(k=a.i.Cb(b,k));if(m){if(!d||n)q.dataDependency=a.S.o();r=d?k.createChildContext("function"==typeof h?h:c,q):a.S.qa()?k.extend(null,q):k;}u&&a.S.qa()&&(p=a.a.Ca(a.h.childNodes(b),!0));m?(u||a.h.va(b,a.a.Ca(p)),a.Oa(r,b)):(a.h.Ea(b),t||a.i.ma(b,a.i.H));l=m;}},null,{l:b});return {controlsDescendantBindings:!0}}};a.m.Ra[b]=!1;a.h.ea[b]=!0;}b("if");b("ifnot",!1,!0);b("with",!0);})();a.c.let={init:function(b,
	c,d,e,f){c=f.extend(c);a.Oa(c,b);return {controlsDescendantBindings:!0}}};a.h.ea.let=!0;var Q={};a.c.options={init:function(b){if("select"!==a.a.R(b))throw Error("options binding applies only to SELECT elements");for(;0<b.length;)b.remove(0);return {controlsDescendantBindings:!0}},update:function(b,c,d){function e(){return a.a.jb(b.options,function(a){return a.selected})}function f(a,b,c){var d=typeof b;return "function"==d?b(a):"string"==d?a[b]:c}function g(c,d){if(x&&l)a.i.ma(b,a.i.H);else if(t.length){var e=
	0<=a.a.A(t,a.w.M(d[0]));a.a.Zc(d[0],e);x&&!e&&a.u.G(a.a.Fb,null,[b,"change"]);}}var h=b.multiple,m=0!=b.length&&h?b.scrollTop:null,k=a.a.f(c()),l=d.get("valueAllowUnset")&&d.has("value"),p=d.get("optionsIncludeDestroyed");c={};var q,t=[];l||(h?t=a.a.Mb(e(),a.w.M):0<=b.selectedIndex&&t.push(a.w.M(b.options[b.selectedIndex])));k&&("undefined"==typeof k.length&&(k=[k]),q=a.a.jb(k,function(b){return p||b===n||null===b||!a.a.f(b._destroy)}),d.has("optionsCaption")&&(k=a.a.f(d.get("optionsCaption")),null!==
	k&&k!==n&&q.unshift(Q)));var x=!1;c.beforeRemove=function(a){b.removeChild(a);};k=g;d.has("optionsAfterRender")&&"function"==typeof d.get("optionsAfterRender")&&(k=function(b,c){g(0,c);a.u.G(d.get("optionsAfterRender"),null,[c[0],b!==Q?b:n]);});a.a.ec(b,q,function(c,e,g){g.length&&(t=!l&&g[0].selected?[a.w.M(g[0])]:[],x=!0);e=b.ownerDocument.createElement("option");c===Q?(a.a.Bb(e,d.get("optionsCaption")),a.w.cb(e,n)):(g=f(c,d.get("optionsValue"),c),a.w.cb(e,a.a.f(g)),c=f(c,d.get("optionsText"),g),
	a.a.Bb(e,c));return [e]},c,k);if(!l){var B;h?B=t.length&&e().length<t.length:B=t.length&&0<=b.selectedIndex?a.w.M(b.options[b.selectedIndex])!==t[0]:t.length||0<=b.selectedIndex;B&&a.u.G(a.a.Fb,null,[b,"change"]);}(l||a.S.Ya())&&a.i.ma(b,a.i.H);a.a.wd(b);m&&20<Math.abs(m-b.scrollTop)&&(b.scrollTop=m);}};a.c.options.$b=a.a.g.Z();a.c.selectedOptions={init:function(b,c,d){function e(){var e=c(),f=[];a.a.D(b.getElementsByTagName("option"),function(b){b.selected&&f.push(a.w.M(b));});a.m.eb(e,d,"selectedOptions",
	f);}function f(){var d=a.a.f(c()),e=b.scrollTop;d&&"number"==typeof d.length&&a.a.D(b.getElementsByTagName("option"),function(b){var c=0<=a.a.A(d,a.w.M(b));b.selected!=c&&a.a.Zc(b,c);});b.scrollTop=e;}if("select"!=a.a.R(b))throw Error("selectedOptions binding applies only to SELECT elements");var g;a.i.subscribe(b,a.i.H,function(){g?e():(a.a.B(b,"change",e),g=a.o(f,null,{l:b}));},null,{notifyImmediately:!0});},update:function(){}};a.m.wa.selectedOptions=!0;a.c.style={update:function(b,c){var d=a.a.f(c()||
	{});a.a.P(d,function(c,d){d=a.a.f(d);if(null===d||d===n||!1===d)d="";if(v)v(b).css(c,d);else if(/^--/.test(c))b.style.setProperty(c,d);else {c=c.replace(/-(\w)/g,function(a,b){return b.toUpperCase()});var g=b.style[c];b.style[c]=d;d===g||b.style[c]!=g||isNaN(d)||(b.style[c]=d+"px");}});}};a.c.submit={init:function(b,c,d,e,f){if("function"!=typeof c())throw Error("The value for a submit binding must be a function");a.a.B(b,"submit",function(a){var d,e=c();try{d=e.call(f.$data,b);}finally{!0!==d&&(a.preventDefault?
	a.preventDefault():a.returnValue=!1);}});}};a.c.text={init:function(){return {controlsDescendantBindings:!0}},update:function(b,c){a.a.Bb(b,c());}};a.h.ea.text=!0;(function(){if(A&&A.navigator){var b=function(a){if(a)return parseFloat(a[1])},c=A.navigator.userAgent,d,e,f,g,h;(d=A.opera&&A.opera.version&&parseInt(A.opera.version()))||(h=b(c.match(/Edge\/([^ ]+)$/)))||b(c.match(/Chrome\/([^ ]+)/))||(e=b(c.match(/Version\/([^ ]+) Safari/)))||(f=b(c.match(/Firefox\/([^ ]+)/)))||(g=a.a.W||b(c.match(/MSIE ([^ ]+)/)))||
	(g=b(c.match(/rv:([^ )]+)/)));}if(8<=g&&10>g)var m=a.a.g.Z(),k=a.a.g.Z(),l=function(b){var c=this.activeElement;(c=c&&a.a.g.get(c,k))&&c(b);},p=function(b,c){var d=b.ownerDocument;a.a.g.get(d,m)||(a.a.g.set(d,m,!0),a.a.B(d,"selectionchange",l));a.a.g.set(b,k,c);};a.c.textInput={init:function(b,c,k){function l(c,d){a.a.B(b,c,d);}function m(){var d=a.a.f(c());if(null===d||d===n)d="";L!==n&&d===L?a.a.setTimeout(m,4):b.value!==d&&(y=!0,b.value=d,y=!1,v=b.value);}function r(){w||(L=b.value,w=a.a.setTimeout(z,
	4));}function z(){clearTimeout(w);L=w=n;var d=b.value;v!==d&&(v=d,a.m.eb(c(),k,"textInput",d));}var v=b.value,w,L,A=9==a.a.W?r:z,y=!1;g&&l("keypress",z);11>g&&l("propertychange",function(a){y||"value"!==a.propertyName||A();});8==g&&(l("keyup",z),l("keydown",z));p&&(p(b,A),l("dragend",r));(!g||9<=g)&&l("input",A);5>e&&"textarea"===a.a.R(b)?(l("keydown",r),l("paste",r),l("cut",r)):11>d?l("keydown",r):4>f?(l("DOMAutoComplete",z),l("dragdrop",z),l("drop",z)):h&&"number"===b.type&&l("keydown",r);l("change",
	z);l("blur",z);a.o(m,null,{l:b});}};a.m.wa.textInput=!0;a.c.textinput={preprocess:function(a,b,c){c("textInput",a);}};})();a.c.uniqueName={init:function(b,c){if(c()){var d="ko_unique_"+ ++a.c.uniqueName.rd;a.a.Yc(b,d);}}};a.c.uniqueName.rd=0;a.c.using={init:function(b,c,d,e,f){var g;d.has("as")&&(g={as:d.get("as"),noChildContext:d.get("noChildContext")});c=f.createChildContext(c,g);a.Oa(c,b);return {controlsDescendantBindings:!0}}};a.h.ea.using=!0;a.c.value={init:function(b,c,d){var e=a.a.R(b),f="input"==
	e;if(!f||"checkbox"!=b.type&&"radio"!=b.type){var g=[],h=d.get("valueUpdate"),m=!1,k=null;h&&("string"==typeof h?g=[h]:g=a.a.wc(h),a.a.Pa(g,"change"));var l=function(){k=null;m=!1;var e=c(),f=a.w.M(b);a.m.eb(e,d,"value",f);};!a.a.W||!f||"text"!=b.type||"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.A(g,"propertychange")||(a.a.B(b,"propertychange",function(){m=!0;}),a.a.B(b,"focus",function(){m=!1;}),a.a.B(b,"blur",function(){m&&l();}));a.a.D(g,function(c){var d=l;a.a.Ud(c,"after")&&
	(d=function(){k=a.w.M(b);a.a.setTimeout(l,0);},c=c.substring(5));a.a.B(b,c,d);});var p;p=f&&"file"==b.type?function(){var d=a.a.f(c());null===d||d===n||""===d?b.value="":a.u.G(l);}:function(){var f=a.a.f(c()),g=a.w.M(b);if(null!==k&&f===k)a.a.setTimeout(p,0);else if(f!==g||g===n)"select"===e?(g=d.get("valueAllowUnset"),a.w.cb(b,f,g),g||f===a.w.M(b)||a.u.G(l)):a.w.cb(b,f);};if("select"===e){var q;a.i.subscribe(b,a.i.H,function(){q?d.get("valueAllowUnset")?p():l():(a.a.B(b,"change",l),q=a.o(p,null,{l:b}));},
	null,{notifyImmediately:!0});}else a.a.B(b,"change",l),a.o(p,null,{l:b});}else a.ib(b,{checkedValue:c});},update:function(){}};a.m.wa.value=!0;a.c.visible={update:function(b,c){var d=a.a.f(c()),e="none"!=b.style.display;d&&!e?b.style.display="":!d&&e&&(b.style.display="none");}};a.c.hidden={update:function(b,c){a.c.visible.update(b,function(){return !a.a.f(c())});}};(function(b){a.c[b]={init:function(c,d,e,f,g){return a.c.event.init.call(this,c,function(){var a={};a[b]=d();return a},e,f,g)}};})("click");
	a.ca=function(){};a.ca.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource");};a.ca.prototype.createJavaScriptEvaluatorBlock=function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.ca.prototype.makeTemplateSource=function(b,c){if("string"==typeof b){c=c||w;var d=c.getElementById(b);if(!d)throw Error("Cannot find template with ID "+b);return new a.C.F(d)}if(1==b.nodeType||8==b.nodeType)return new a.C.ia(b);throw Error("Unknown template type: "+b);};a.ca.prototype.renderTemplate=
	function(a,c,d,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,c,d,e)};a.ca.prototype.isTemplateRewritten=function(a,c){return !1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,c).data("isRewritten")};a.ca.prototype.rewriteTemplate=function(a,c,d){a=this.makeTemplateSource(a,d);c=c(a.text());a.text(c);a.data("isRewritten",!0);};a.b("templateEngine",a.ca);a.kc=function(){function b(b,c,d,h){b=a.m.ac(b);for(var m=a.m.Ra,k=0;k<b.length;k++){var l=b[k].key;if(Object.prototype.hasOwnProperty.call(m,
	l)){var p=m[l];if("function"===typeof p){if(l=p(b[k].value))throw Error(l);}else if(!p)throw Error("This template engine does not support the '"+l+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.m.vb(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+"')";return h.createJavaScriptEvaluatorBlock(d)+c}var c=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,
	d=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return {xd:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.kc.Ld(b,c)},d);},Ld:function(a,f){return a.replace(c,function(a,c,d,e,l){return b(l,c,d,f)}).replace(d,function(a,c){return b(c,"\x3c!-- ko --\x3e","#comment",f)})},md:function(b,c){return a.aa.Xb(function(d,h){var m=d.nextSibling;m&&m.nodeName.toLowerCase()===c&&a.ib(m,b,h);})}}}();a.b("__tr_ambtns",a.kc.md);(function(){a.C={};a.C.F=function(b){if(this.F=b){var c=
	a.a.R(b);this.ab="script"===c?1:"textarea"===c?2:"template"==c&&b.content&&11===b.content.nodeType?3:4;}};a.C.F.prototype.text=function(){var b=1===this.ab?"text":2===this.ab?"value":"innerHTML";if(0==arguments.length)return this.F[b];var c=arguments[0];"innerHTML"===b?a.a.fc(this.F,c):this.F[b]=c;};var b=a.a.g.Z()+"_";a.C.F.prototype.data=function(c){if(1===arguments.length)return a.a.g.get(this.F,b+c);a.a.g.set(this.F,b+c,arguments[1]);};var c=a.a.g.Z();a.C.F.prototype.nodes=function(){var b=this.F;
	if(0==arguments.length){var e=a.a.g.get(b,c)||{},f=e.lb||(3===this.ab?b.content:4===this.ab?b:n);if(!f||e.jd){var g=this.text();g&&g!==e.bb&&(f=a.a.Md(g,b.ownerDocument),a.a.g.set(b,c,{lb:f,bb:g,jd:!0}));}return f}e=arguments[0];this.ab!==n&&this.text("");a.a.g.set(b,c,{lb:e});};a.C.ia=function(a){this.F=a;};a.C.ia.prototype=new a.C.F;a.C.ia.prototype.constructor=a.C.ia;a.C.ia.prototype.text=function(){if(0==arguments.length){var b=a.a.g.get(this.F,c)||{};b.bb===n&&b.lb&&(b.bb=b.lb.innerHTML);return b.bb}a.a.g.set(this.F,
	c,{bb:arguments[0]});};a.b("templateSources",a.C);a.b("templateSources.domElement",a.C.F);a.b("templateSources.anonymousTemplate",a.C.ia);})();(function(){function b(b,c,d){var e;for(c=a.h.nextSibling(c);b&&(e=b)!==c;)b=a.h.nextSibling(e),d(e,b);}function c(c,d){if(c.length){var e=c[0],f=c[c.length-1],g=e.parentNode,h=a.ga.instance,m=h.preprocessNode;if(m){b(e,f,function(a,b){var c=a.previousSibling,d=m.call(h,a);d&&(a===e&&(e=d[0]||b),a===f&&(f=d[d.length-1]||c));});c.length=0;if(!e)return;e===f?c.push(e):
	(c.push(e,f),a.a.Ua(c,g));}b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.vc(d,b);});b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.aa.cd(b,[d]);});a.a.Ua(c,g);}}function d(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,f,h,m){m=m||{};var n=(b&&d(b)||f||{}).ownerDocument,B=m.templateEngine||g;a.kc.xd(f,B,n);f=B.renderTemplate(f,h,m,n);if("number"!=typeof f.length||0<f.length&&"number"!=typeof f[0].nodeType)throw Error("Template engine must return an array of DOM nodes");n=!1;switch(e){case "replaceChildren":a.h.va(b,
	f);n=!0;break;case "replaceNode":a.a.Xc(b,f);n=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+e);}n&&(c(f,h),m.afterRender&&a.u.G(m.afterRender,null,[f,h[m.as||"$data"]]),"replaceChildren"==e&&a.i.ma(b,a.i.H));return f}function f(b,c,d){return a.O(b)?b():"function"===typeof b?b(c,d):b}var g;a.gc=function(b){if(b!=n&&!(b instanceof a.ca))throw Error("templateEngine must inherit from ko.templateEngine");g=b;};a.dc=function(b,c,h,m,t){h=h||{};if((h.templateEngine||g)==
	n)throw Error("Set a template engine before calling renderTemplate");t=t||"replaceChildren";if(m){var x=d(m);return a.$(function(){var g=c&&c instanceof a.fa?c:new a.fa(c,null,null,null,{exportDependencies:!0}),n=f(b,g.$data,g),g=e(m,t,n,g,h);"replaceNode"==t&&(m=g,x=d(m));},null,{Sa:function(){return !x||!a.a.Sb(x)},l:x&&"replaceNode"==t?x.parentNode:x})}return a.aa.Xb(function(d){a.dc(b,c,h,d,"replaceNode");})};a.Qd=function(b,d,g,h,m){function x(b,c){a.u.G(a.a.ec,null,[h,b,u,g,r,c]);a.i.ma(h,a.i.H);}
	function r(a,b){c(b,v);g.afterRender&&g.afterRender(b,a);v=null;}function u(a,c){v=m.createChildContext(a,{as:z,noChildContext:g.noChildContext,extend:function(a){a.$index=c;z&&(a[z+"Index"]=c);}});var d=f(b,a,v);return e(h,"ignoreTargetNode",d,v,g)}var v,z=g.as,w=!1===g.includeDestroyed||a.options.foreachHidesDestroyed&&!g.includeDestroyed;if(w||g.beforeRemove||!a.Pc(d))return a.$(function(){var b=a.a.f(d)||[];"undefined"==typeof b.length&&(b=[b]);w&&(b=a.a.jb(b,function(b){return b===n||null===b||
	!a.a.f(b._destroy)}));x(b);},null,{l:h});x(d.v());var A=d.subscribe(function(a){x(d(),a);},null,"arrayChange");A.l(h);return A};var h=a.a.g.Z(),m=a.a.g.Z();a.c.template={init:function(b,c){var d=a.a.f(c());if("string"==typeof d||"name"in d)a.h.Ea(b);else if("nodes"in d){d=d.nodes||[];if(a.O(d))throw Error('The "nodes" option must be a plain, non-observable array.');var e=d[0]&&d[0].parentNode;e&&a.a.g.get(e,m)||(e=a.a.Yb(d),a.a.g.set(e,m,!0));(new a.C.ia(b)).nodes(e);}else if(d=a.h.childNodes(b),0<d.length)e=
	a.a.Yb(d),(new a.C.ia(b)).nodes(e);else throw Error("Anonymous template defined, but no template content was provided");return {controlsDescendantBindings:!0}},update:function(b,c,d,e,f){var g=c();c=a.a.f(g);d=!0;e=null;"string"==typeof c?c={}:(g="name"in c?c.name:b,"if"in c&&(d=a.a.f(c["if"])),d&&"ifnot"in c&&(d=!a.a.f(c.ifnot)),d&&!g&&(d=!1));"foreach"in c?e=a.Qd(g,d&&c.foreach||[],c,b,f):d?(d=f,"data"in c&&(d=f.createChildContext(c.data,{as:c.as,noChildContext:c.noChildContext,exportDependencies:!0})),
	e=a.dc(g,d,c,b)):a.h.Ea(b);f=e;(c=a.a.g.get(b,h))&&"function"==typeof c.s&&c.s();a.a.g.set(b,h,!f||f.ja&&!f.ja()?n:f);}};a.m.Ra.template=function(b){b=a.m.ac(b);return 1==b.length&&b[0].unknown||a.m.Id(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.h.ea.template=!0;})();a.b("setTemplateEngine",a.gc);a.b("renderTemplate",a.dc);a.a.Kc=function(a,c,d){if(a.length&&c.length){var e,f,g,h,m;for(e=f=0;(!d||e<d)&&(h=a[f]);++f){for(g=0;m=c[g];++g)if(h.value===
	m.value){h.moved=m.index;m.moved=h.index;c.splice(g,1);e=g=0;break}e+=g;}}};a.a.Pb=function(){function b(b,d,e,f,g){var h=Math.min,m=Math.max,k=[],l,p=b.length,q,n=d.length,r=n-p||1,v=p+n+1,u,w,z;for(l=0;l<=p;l++)for(w=u,k.push(u=[]),z=h(n,l+r),q=m(0,l-1);q<=z;q++)u[q]=q?l?b[l-1]===d[q-1]?w[q-1]:h(w[q]||v,u[q-1]||v)+1:q+1:l+1;h=[];m=[];r=[];l=p;for(q=n;l||q;)n=k[l][q]-1,q&&n===k[l][q-1]?m.push(h[h.length]={status:e,value:d[--q],index:q}):l&&n===k[l-1][q]?r.push(h[h.length]={status:f,value:b[--l],index:l}):
	(--q,--l,g.sparse||h.push({status:"retained",value:d[q]}));a.a.Kc(r,m,!g.dontLimitMoves&&10*p);return h.reverse()}return function(a,d,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];d=d||[];return a.length<d.length?b(a,d,"added","deleted",e):b(d,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.Pb);(function(){function b(b,c,d,h,m){var k=[],l=a.$(function(){var l=c(d,m,a.a.Ua(k,b))||[];0<k.length&&(a.a.Xc(k,l),h&&a.u.G(h,null,[d,l,m]));k.length=0;a.a.Nb(k,l);},null,{l:b,Sa:function(){return !a.a.kd(k)}});
	return {Y:k,$:l.ja()?l:n}}var c=a.a.g.Z(),d=a.a.g.Z();a.a.ec=function(e,f,g,h,m,k){function l(b){y={Aa:b,pb:a.ta(w++)};v.push(y);r||F.push(y);}function p(b){y=t[b];w!==y.pb.v()&&D.push(y);y.pb(w++);a.a.Ua(y.Y,e);v.push(y);}function q(b,c){if(b)for(var d=0,e=c.length;d<e;d++)a.a.D(c[d].Y,function(a){b(a,d,c[d].Aa);});}f=f||[];"undefined"==typeof f.length&&(f=[f]);h=h||{};var t=a.a.g.get(e,c),r=!t,v=[],u=0,w=0,z=[],A=[],C=[],D=[],F=[],y,I=0;if(r)a.a.D(f,l);else {if(!k||t&&t._countWaitingForRemove){var E=
	a.a.Mb(t,function(a){return a.Aa});k=a.a.Pb(E,f,{dontLimitMoves:h.dontLimitMoves,sparse:!0});}for(var E=0,G,H,K;G=k[E];E++)switch(H=G.moved,K=G.index,G.status){case "deleted":for(;u<K;)p(u++);H===n&&(y=t[u],y.$&&(y.$.s(),y.$=n),a.a.Ua(y.Y,e).length&&(h.beforeRemove&&(v.push(y),I++,y.Aa===d?y=null:C.push(y)),y&&z.push.apply(z,y.Y)));u++;break;case "added":for(;w<K;)p(u++);H!==n?(A.push(v.length),p(H)):l(G.value);}for(;w<f.length;)p(u++);v._countWaitingForRemove=I;}a.a.g.set(e,c,v);q(h.beforeMove,D);a.a.D(z,
	h.beforeRemove?a.oa:a.removeNode);var M,O,P;try{P=e.ownerDocument.activeElement;}catch(N){}if(A.length)for(;(E=A.shift())!=n;){y=v[E];for(M=n;E;)if((O=v[--E].Y)&&O.length){M=O[O.length-1];break}for(f=0;u=y.Y[f];M=u,f++)a.h.Wb(e,u,M);}for(E=0;y=v[E];E++){y.Y||a.a.extend(y,b(e,g,y.Aa,m,y.pb));for(f=0;u=y.Y[f];M=u,f++)a.h.Wb(e,u,M);!y.Ed&&m&&(m(y.Aa,y.Y,y.pb),y.Ed=!0,M=y.Y[y.Y.length-1]);}P&&e.ownerDocument.activeElement!=P&&P.focus();q(h.beforeRemove,C);for(E=0;E<C.length;++E)C[E].Aa=d;q(h.afterMove,D);
	q(h.afterAdd,F);};})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.ec);a.ba=function(){this.allowTemplateRewriting=!1;};a.ba.prototype=new a.ca;a.ba.prototype.constructor=a.ba;a.ba.prototype.renderTemplateSource=function(b,c,d,e){if(c=(9>a.a.W?0:b.nodes)?b.nodes():null)return a.a.la(c.cloneNode(!0).childNodes);b=b.text();return a.a.ua(b,e)};a.ba.Ma=new a.ba;a.gc(a.ba.Ma);a.b("nativeTemplateEngine",a.ba);(function(){a.$a=function(){var a=this.Hd=function(){if(!v||!v.tmpl)return 0;try{if(0<=v.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();
	this.renderTemplateSource=function(b,e,f,g){g=g||w;f=f||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var h=b.data("precompiled");h||(h=b.text()||"",h=v.template(null,"{{ko_with $item.koBindingContext}}"+h+"{{/ko_with}}"),b.data("precompiled",h));b=[e.$data];e=v.extend({koBindingContext:e},f.templateOptions);e=v.tmpl(h,b,e);e.appendTo(g.createElement("div"));v.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return "{{ko_code ((function() { return "+
	a+" })()) }}"};this.addTemplate=function(a,b){w.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>");};0<a&&(v.tmpl.tag.ko_code={open:"__.push($1 || '');"},v.tmpl.tag.ko_with={open:"with($1) {",close:"} "});};a.$a.prototype=new a.ca;a.$a.prototype.constructor=a.$a;var b=new a.$a;0<b.Hd&&a.gc(b);a.b("jqueryTmplTemplateEngine",a.$a);})();});})();})();
	});

	window.ko = knockout;
	window.knockout = knockout;

	var knockout_mapping = createCommonjsModule(function (module, exports) {
	(function (factory) {
		// Module systems magic dance.

		if (typeof commonjsRequire === "function" && 'object' === "object" && 'object' === "object") {
			// CommonJS or Node: hard-coded dependency on "knockout"
			factory(knockout, exports);
		} else {
			// <script> tag: use the global `ko` object, attaching a `mapping` property
			factory(ko, ko.mapping = {});
		}
	}(function (ko, exports) {
		var mappingProperty = "__ko_mapping__";
		var realKoDependentObservable = ko.dependentObservable;
		var mappingNesting = 0;
		var dependentObservables;
		var visitedObjects;
		var recognizedRootProperties = ["create", "update", "key", "arrayChanged"];
		var emptyReturn = {};

		var _defaultOptions = {
			include: ["_destroy"],
			ignore: [],
			copy: [],
			observe: []
		};
		var defaultOptions = _defaultOptions;

		// Author: KennyTM @ StackOverflow
		function unionArrays (x, y) {
			var obj = {};
			for (var i = x.length - 1; i >= 0; -- i) obj[x[i]] = x[i];
			for (var i = y.length - 1; i >= 0; -- i) obj[y[i]] = y[i];
			var res = [];

			for (var k in obj) {
				res.push(obj[k]);
			}
			return res;
		}

		function extendObject(destination, source) {
			var destType;

			for (var key in source) {
				if (source.hasOwnProperty(key) && source[key]) {
					destType = exports.getType(destination[key]);
					if (key && destination[key] && destType !== "array" && destType !== "string") {
						extendObject(destination[key], source[key]);
					} else {
						var bothArrays = exports.getType(destination[key]) === "array" && exports.getType(source[key]) === "array";
						if (bothArrays) {
							destination[key] = unionArrays(destination[key], source[key]);
						} else {
							destination[key] = source[key];
						}
					}
				}
			}
		}

		function merge(obj1, obj2) {
			var merged = {};
			extendObject(merged, obj1);
			extendObject(merged, obj2);

			return merged;
		}

		exports.isMapped = function (viewModel) {
			var unwrapped = ko.utils.unwrapObservable(viewModel);
			return unwrapped && unwrapped[mappingProperty];
		};

		exports.fromJS = function (jsObject /*, inputOptions, target*/ ) {
			if (arguments.length == 0) throw new Error("When calling ko.fromJS, pass the object you want to convert.");

			try {
				if (!mappingNesting++) {
					dependentObservables = [];
					visitedObjects = new objectLookup();
				}

				var options;
				var target;

				if (arguments.length == 2) {
					if (arguments[1][mappingProperty]) {
						target = arguments[1];
					} else {
						options = arguments[1];
					}
				}
				if (arguments.length == 3) {
					options = arguments[1];
					target = arguments[2];
				}

				if (target) {
					options = merge(options, target[mappingProperty]);
				}
				options = fillOptions(options);

				var result = updateViewModel(target, jsObject, options);
				if (target) {
					result = target;
				}

				// Evaluate any dependent observables that were proxied.
				// Do this after the model's observables have been created
				if (!--mappingNesting) {
					while (dependentObservables.length) {
						var DO = dependentObservables.pop();
						if (DO) {
							DO();
							
							// Move this magic property to the underlying dependent observable
							DO.__DO["throttleEvaluation"] = DO["throttleEvaluation"];
						}
					}
				}

				// Save any new mapping options in the view model, so that updateFromJS can use them later.
				result[mappingProperty] = merge(result[mappingProperty], options);

				return result;
			} catch(e) {
				mappingNesting = 0;
				throw e;
			}
		};

		exports.fromJSON = function (jsonString /*, options, target*/ ) {
			var parsed = ko.utils.parseJson(jsonString);
			arguments[0] = parsed;
			return exports.fromJS.apply(this, arguments);
		};

		exports.updateFromJS = function (viewModel) {
			throw new Error("ko.mapping.updateFromJS, use ko.mapping.fromJS instead. Please note that the order of parameters is different!");
		};

		exports.updateFromJSON = function (viewModel) {
			throw new Error("ko.mapping.updateFromJSON, use ko.mapping.fromJSON instead. Please note that the order of parameters is different!");
		};

		exports.toJS = function (rootObject, options) {
			if (!defaultOptions) exports.resetDefaultOptions();

			if (arguments.length == 0) throw new Error("When calling ko.mapping.toJS, pass the object you want to convert.");
			if (exports.getType(defaultOptions.ignore) !== "array") throw new Error("ko.mapping.defaultOptions().ignore should be an array.");
			if (exports.getType(defaultOptions.include) !== "array") throw new Error("ko.mapping.defaultOptions().include should be an array.");
			if (exports.getType(defaultOptions.copy) !== "array") throw new Error("ko.mapping.defaultOptions().copy should be an array.");

			// Merge in the options used in fromJS
			options = fillOptions(options, rootObject[mappingProperty]);

			// We just unwrap everything at every level in the object graph
			return exports.visitModel(rootObject, function (x) {
				return ko.utils.unwrapObservable(x)
			}, options);
		};

		exports.toJSON = function (rootObject, options) {
			var plainJavaScriptObject = exports.toJS(rootObject, options);
			return ko.utils.stringifyJson(plainJavaScriptObject);
		};

		exports.defaultOptions = function () {
			if (arguments.length > 0) {
				defaultOptions = arguments[0];
			} else {
				return defaultOptions;
			}
		};

		exports.resetDefaultOptions = function () {
			defaultOptions = {
				include: _defaultOptions.include.slice(0),
				ignore: _defaultOptions.ignore.slice(0),
				copy: _defaultOptions.copy.slice(0)
			};
		};

		exports.getType = function(x) {
			if ((x) && (typeof (x) === "object")) {
				if (x.constructor === Date) return "date";
				if (x.constructor === Array) return "array";
			}
			return typeof x;
		};

		function fillOptions(rawOptions, otherOptions) {
			var options = merge({}, rawOptions);

			// Move recognized root-level properties into a root namespace
			for (var i = recognizedRootProperties.length - 1; i >= 0; i--) {
				var property = recognizedRootProperties[i];
				
				// Carry on, unless this property is present
				if (!options[property]) continue;
				
				// Move the property into the root namespace
				if (!(options[""] instanceof Object)) options[""] = {};
				options[""][property] = options[property];
				delete options[property];
			}

			if (otherOptions) {
				options.ignore = mergeArrays(otherOptions.ignore, options.ignore);
				options.include = mergeArrays(otherOptions.include, options.include);
				options.copy = mergeArrays(otherOptions.copy, options.copy);
				options.observe = mergeArrays(otherOptions.observe, options.observe);
			}
			options.ignore = mergeArrays(options.ignore, defaultOptions.ignore);
			options.include = mergeArrays(options.include, defaultOptions.include);
			options.copy = mergeArrays(options.copy, defaultOptions.copy);
			options.observe = mergeArrays(options.observe, defaultOptions.observe);

			options.mappedProperties = options.mappedProperties || {};
			options.copiedProperties = options.copiedProperties || {};
			return options;
		}

		function mergeArrays(a, b) {
			if (exports.getType(a) !== "array") {
				if (exports.getType(a) === "undefined") a = [];
				else a = [a];
			}
			if (exports.getType(b) !== "array") {
				if (exports.getType(b) === "undefined") b = [];
				else b = [b];
			}

			return ko.utils.arrayGetDistinctValues(a.concat(b));
		}

		// When using a 'create' callback, we proxy the dependent observable so that it doesn't immediately evaluate on creation.
		// The reason is that the dependent observables in the user-specified callback may contain references to properties that have not been mapped yet.
		function withProxyDependentObservable(dependentObservables, callback) {
			var localDO = ko.dependentObservable;
			ko.dependentObservable = function (read, owner, options) {
				options = options || {};

				if (read && typeof read == "object") { // mirrors condition in knockout implementation of DO's
					options = read;
				}

				var realDeferEvaluation = options.deferEvaluation;

				var isRemoved = false;

				// We wrap the original dependent observable so that we can remove it from the 'dependentObservables' list we need to evaluate after mapping has
				// completed if the user already evaluated the DO themselves in the meantime.
				var wrap = function (DO) {
					// Temporarily revert ko.dependentObservable, since it is used in ko.isWriteableObservable
					var tmp = ko.dependentObservable;
					ko.dependentObservable = realKoDependentObservable;
					var isWriteable = ko.isWriteableObservable(DO);
					ko.dependentObservable = tmp;

					var wrapped = realKoDependentObservable({
						read: function () {
							if (!isRemoved) {
								ko.utils.arrayRemoveItem(dependentObservables, DO);
								isRemoved = true;
							}
							return DO.apply(DO, arguments);
						},
						write: isWriteable && function (val) {
							return DO(val);
						},
						deferEvaluation: true
					});
					wrapped._wrapper = true;
					wrapped.__DO = DO;
					return wrapped;
				};
				
				options.deferEvaluation = true; // will either set for just options, or both read/options.
				var realDependentObservable = new realKoDependentObservable(read, owner, options);

				if (!realDeferEvaluation) {
					realDependentObservable = wrap(realDependentObservable);
					dependentObservables.push(realDependentObservable);
				}

				return realDependentObservable;
			};
			ko.dependentObservable.fn = realKoDependentObservable.fn;
			ko.computed = ko.dependentObservable;
			var result = callback();
			ko.dependentObservable = localDO;
			ko.computed = ko.dependentObservable;
			return result;
		}

		function updateViewModel(mappedRootObject, rootObject, options, parentName, parent, parentPropertyName, mappedParent) {
			var isArray = exports.getType(ko.utils.unwrapObservable(rootObject)) === "array";

			parentPropertyName = parentPropertyName || "";

			// If this object was already mapped previously, take the options from there and merge them with our existing ones.
			if (exports.isMapped(mappedRootObject)) {
				var previousMapping = ko.utils.unwrapObservable(mappedRootObject)[mappingProperty];
				options = merge(previousMapping, options);
			}

			var callbackParams = {
				data: rootObject,
				parent: mappedParent || parent
			};

			var hasCreateCallback = function () {
				return options[parentName] && options[parentName].create instanceof Function;
			};

			var createCallback = function (data) {
				return withProxyDependentObservable(dependentObservables, function () {
					
					if (ko.utils.unwrapObservable(parent) instanceof Array) {
						return options[parentName].create({
							data: data || callbackParams.data,
							parent: callbackParams.parent,
							skip: emptyReturn
						});
					} else {
						return options[parentName].create({
							data: data || callbackParams.data,
							parent: callbackParams.parent
						});
					}				
				});
			};

			var hasUpdateCallback = function () {
				return options[parentName] && options[parentName].update instanceof Function;
			};

			var updateCallback = function (obj, data) {
				var params = {
					data: data || callbackParams.data,
					parent: callbackParams.parent,
					target: ko.utils.unwrapObservable(obj)
				};

				if (ko.isWriteableObservable(obj)) {
					params.observable = obj;
				}

				return options[parentName].update(params);
			};

			var alreadyMapped = visitedObjects.get(rootObject);
			if (alreadyMapped) {
				return alreadyMapped;
			}

			parentName = parentName || "";

			if (!isArray) {
				// For atomic types, do a direct update on the observable
				if (!canHaveProperties(rootObject)) {
					switch (exports.getType(rootObject)) {
					case "function":
						if (hasUpdateCallback()) {
							if (ko.isWriteableObservable(rootObject)) {
								rootObject(updateCallback(rootObject));
								mappedRootObject = rootObject;
							} else {
								mappedRootObject = updateCallback(rootObject);
							}
						} else {
							mappedRootObject = rootObject;
						}
						break;
					default:
						if (ko.isWriteableObservable(mappedRootObject)) {
							if (hasUpdateCallback()) {
								var valueToWrite = updateCallback(mappedRootObject);
								mappedRootObject(valueToWrite);
								return valueToWrite;
							} else {
								var valueToWrite = ko.utils.unwrapObservable(rootObject);
								mappedRootObject(valueToWrite);
								return valueToWrite;
							}
						} else {
							var hasCreateOrUpdateCallback = hasCreateCallback() || hasUpdateCallback();
							
							if (hasCreateCallback()) {
								mappedRootObject = createCallback();
							} else {
								mappedRootObject = ko.observable(ko.utils.unwrapObservable(rootObject));
							}

							if (hasUpdateCallback()) {
								mappedRootObject(updateCallback(mappedRootObject));
							}
							
							if (hasCreateOrUpdateCallback) return mappedRootObject;
						}
					}

				} else {
					mappedRootObject = ko.utils.unwrapObservable(mappedRootObject);
					if (!mappedRootObject) {
						if (hasCreateCallback()) {
							var result = createCallback();

							if (hasUpdateCallback()) {
								result = updateCallback(result);
							}

							return result;
						} else {
							if (hasUpdateCallback()) {
								return updateCallback(result);
							}

							mappedRootObject = {};
						}
					}

					if (hasUpdateCallback()) {
						mappedRootObject = updateCallback(mappedRootObject);
					}

					visitedObjects.save(rootObject, mappedRootObject);
					if (hasUpdateCallback()) return mappedRootObject;

					// For non-atomic types, visit all properties and update recursively
					visitPropertiesOrArrayEntries(rootObject, function (indexer) {
						var fullPropertyName = parentPropertyName.length ? parentPropertyName + "." + indexer : indexer;

						if (ko.utils.arrayIndexOf(options.ignore, fullPropertyName) != -1) {
							return;
						}

						if (ko.utils.arrayIndexOf(options.copy, fullPropertyName) != -1) {
							mappedRootObject[indexer] = rootObject[indexer];
							return;
						}

						if(typeof rootObject[indexer] != "object" && typeof rootObject[indexer] != "array" && options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) == -1)
						{
							mappedRootObject[indexer] = rootObject[indexer];
							options.copiedProperties[fullPropertyName] = true;
							return;
						}
						
						// In case we are adding an already mapped property, fill it with the previously mapped property value to prevent recursion.
						// If this is a property that was generated by fromJS, we should use the options specified there
						var prevMappedProperty = visitedObjects.get(rootObject[indexer]);
						var retval = updateViewModel(mappedRootObject[indexer], rootObject[indexer], options, indexer, mappedRootObject, fullPropertyName, mappedRootObject);
						var value = prevMappedProperty || retval;
						
						if(options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) == -1)
						{
							mappedRootObject[indexer] = value();
							options.copiedProperties[fullPropertyName] = true;
							return;
						}
						
						if (ko.isWriteableObservable(mappedRootObject[indexer])) {
							value = ko.utils.unwrapObservable(value);
							if (mappedRootObject[indexer]() !== value) {
								mappedRootObject[indexer](value);
							}
						} else {
							value = mappedRootObject[indexer] === undefined ? value : ko.utils.unwrapObservable(value);
							mappedRootObject[indexer] = value;
						}

						options.mappedProperties[fullPropertyName] = true;
					});
				}
			} else { //mappedRootObject is an array
				var changes = [];

				var hasKeyCallback = false;
				var keyCallback = function (x) {
					return x;
				};
				if (options[parentName] && options[parentName].key) {
					keyCallback = options[parentName].key;
					hasKeyCallback = true;
				}

				if (!ko.isObservable(mappedRootObject)) {
					// When creating the new observable array, also add a bunch of utility functions that take the 'key' of the array items into account.
					mappedRootObject = ko.observableArray([]);

					mappedRootObject.mappedRemove = function (valueOrPredicate) {
						var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) {
								return value === keyCallback(valueOrPredicate);
							};
						return mappedRootObject.remove(function (item) {
							return predicate(keyCallback(item));
						});
					};

					mappedRootObject.mappedRemoveAll = function (arrayOfValues) {
						var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);
						return mappedRootObject.remove(function (item) {
							return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) != -1;
						});
					};

					mappedRootObject.mappedDestroy = function (valueOrPredicate) {
						var predicate = typeof valueOrPredicate == "function" ? valueOrPredicate : function (value) {
								return value === keyCallback(valueOrPredicate);
							};
						return mappedRootObject.destroy(function (item) {
							return predicate(keyCallback(item));
						});
					};

					mappedRootObject.mappedDestroyAll = function (arrayOfValues) {
						var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);
						return mappedRootObject.destroy(function (item) {
							return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) != -1;
						});
					};

					mappedRootObject.mappedIndexOf = function (item) {
						var keys = filterArrayByKey(mappedRootObject(), keyCallback);
						var key = keyCallback(item);
						return ko.utils.arrayIndexOf(keys, key);
					};

					mappedRootObject.mappedGet = function (item) {
						return mappedRootObject()[mappedRootObject.mappedIndexOf(item)];
					};

					mappedRootObject.mappedCreate = function (value) {
						if (mappedRootObject.mappedIndexOf(value) !== -1) {
							throw new Error("There already is an object with the key that you specified.");
						}

						var item = hasCreateCallback() ? createCallback(value) : value;
						if (hasUpdateCallback()) {
							var newValue = updateCallback(item, value);
							if (ko.isWriteableObservable(item)) {
								item(newValue);
							} else {
								item = newValue;
							}
						}
						mappedRootObject.push(item);
						return item;
					};
				}

				var currentArrayKeys = filterArrayByKey(ko.utils.unwrapObservable(mappedRootObject), keyCallback).sort();
				var newArrayKeys = filterArrayByKey(rootObject, keyCallback);
				if (hasKeyCallback) newArrayKeys.sort();
				var editScript = ko.utils.compareArrays(currentArrayKeys, newArrayKeys);

				var ignoreIndexOf = {};
				
				var i, j;

				var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);
				var itemsByKey = {};
				var optimizedKeys = true;
				for (i = 0, j = unwrappedRootObject.length; i < j; i++) {
					var key = keyCallback(unwrappedRootObject[i]);
					if (key === undefined || key instanceof Object) {
						optimizedKeys = false;
						break;
					}
					itemsByKey[key] = unwrappedRootObject[i];
				}

				var newContents = [];
				var passedOver = 0;
				for (i = 0, j = editScript.length; i < j; i++) {
					var key = editScript[i];
					var mappedItem;
					var fullPropertyName = parentPropertyName + "[" + i + "]";
					switch (key.status) {
					case "added":
						var item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);
						mappedItem = updateViewModel(undefined, item, options, parentName, mappedRootObject, fullPropertyName, parent);
						if(!hasCreateCallback()) {
							mappedItem = ko.utils.unwrapObservable(mappedItem);
						}

						var index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);
						
						if (mappedItem === emptyReturn) {
							passedOver++;
						} else {
							newContents[index - passedOver] = mappedItem;
						}
							
						ignoreIndexOf[index] = true;
						break;
					case "retained":
						var item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);
						mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);
						updateViewModel(mappedItem, item, options, parentName, mappedRootObject, fullPropertyName, parent);

						var index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);
						newContents[index] = mappedItem;
						ignoreIndexOf[index] = true;
						break;
					case "deleted":
						mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);
						break;
					}

					changes.push({
						event: key.status,
						item: mappedItem
					});
				}

				mappedRootObject(newContents);

				if (options[parentName] && options[parentName].arrayChanged) {
					ko.utils.arrayForEach(changes, function (change) {
						options[parentName].arrayChanged(change.event, change.item);
					});
				}
			}

			return mappedRootObject;
		}

		function ignorableIndexOf(array, item, ignoreIndices) {
			for (var i = 0, j = array.length; i < j; i++) {
				if (ignoreIndices[i] === true) continue;
				if (array[i] === item) return i;
			}
			return null;
		}

		function mapKey(item, callback) {
			var mappedItem;
			if (callback) mappedItem = callback(item);
			if (exports.getType(mappedItem) === "undefined") mappedItem = item;

			return ko.utils.unwrapObservable(mappedItem);
		}

		function getItemByKey(array, key, callback) {
			array = ko.utils.unwrapObservable(array);
			for (var i = 0, j = array.length; i < j; i++) {
				var item = array[i];
				if (mapKey(item, callback) === key) return item;
			}

			throw new Error("When calling ko.update*, the key '" + key + "' was not found!");
		}

		function filterArrayByKey(array, callback) {
			return ko.utils.arrayMap(ko.utils.unwrapObservable(array), function (item) {
				if (callback) {
					return mapKey(item, callback);
				} else {
					return item;
				}
			});
		}

		function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
			if (exports.getType(rootObject) === "array") {
				for (var i = 0; i < rootObject.length; i++)
				visitorCallback(i);
			} else {
				for (var propertyName in rootObject)
				visitorCallback(propertyName);
			}
		}
		function canHaveProperties(object) {
			var type = exports.getType(object);
			return ((type === "object") || (type === "array")) && (object !== null);
		}

		// Based on the parentName, this creates a fully classified name of a property

		function getPropertyName(parentName, parent, indexer) {
			var propertyName = parentName || "";
			if (exports.getType(parent) === "array") {
				if (parentName) {
					propertyName += "[" + indexer + "]";
				}
			} else {
				if (parentName) {
					propertyName += ".";
				}
				propertyName += indexer;
			}
			return propertyName;
		}

		exports.visitModel = function (rootObject, callback, options) {
			options = options || {};
			options.visitedObjects = options.visitedObjects || new objectLookup();

			var mappedRootObject;
			var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);

			if (!canHaveProperties(unwrappedRootObject)) {
				return callback(rootObject, options.parentName);
			} else {
				options = fillOptions(options, unwrappedRootObject[mappingProperty]);

				// Only do a callback, but ignore the results
				callback(rootObject, options.parentName);
				mappedRootObject = exports.getType(unwrappedRootObject) === "array" ? [] : {};
			}

			options.visitedObjects.save(rootObject, mappedRootObject);

			var parentName = options.parentName;
			visitPropertiesOrArrayEntries(unwrappedRootObject, function (indexer) {
				if (options.ignore && ko.utils.arrayIndexOf(options.ignore, indexer) != -1) return;

				var propertyValue = unwrappedRootObject[indexer];
				options.parentName = getPropertyName(parentName, unwrappedRootObject, indexer);

				// If we don't want to explicitly copy the unmapped property...
				if (ko.utils.arrayIndexOf(options.copy, indexer) === -1) {
					// ...find out if it's a property we want to explicitly include
					if (ko.utils.arrayIndexOf(options.include, indexer) === -1) {
						// The mapped properties object contains all the properties that were part of the original object.
						// If a property does not exist, and it is not because it is part of an array (e.g. "myProp[3]"), then it should not be unmapped.
					    if (unwrappedRootObject[mappingProperty]
					        && unwrappedRootObject[mappingProperty].mappedProperties && !unwrappedRootObject[mappingProperty].mappedProperties[indexer]
					        && unwrappedRootObject[mappingProperty].copiedProperties && !unwrappedRootObject[mappingProperty].copiedProperties[indexer]
					        && !(exports.getType(unwrappedRootObject) === "array")) {
							return;
						}
					}
				}
				switch (exports.getType(ko.utils.unwrapObservable(propertyValue))) {
				case "object":
				case "array":
				case "undefined":
					var previouslyMappedValue = options.visitedObjects.get(propertyValue);
					mappedRootObject[indexer] = (exports.getType(previouslyMappedValue) !== "undefined") ? previouslyMappedValue : exports.visitModel(propertyValue, callback, options);
					break;
				default:
					mappedRootObject[indexer] = callback(propertyValue, options.parentName);
				}
			});

			return mappedRootObject;
		};

		function simpleObjectLookup() {
			var keys = [];
			var values = [];
			this.save = function (key, value) {
				var existingIndex = ko.utils.arrayIndexOf(keys, key);
				if (existingIndex >= 0) values[existingIndex] = value;
				else {
					keys.push(key);
					values.push(value);
				}
			};
			this.get = function (key) {
				var existingIndex = ko.utils.arrayIndexOf(keys, key);
				var value = (existingIndex >= 0) ? values[existingIndex] : undefined;
				return value;
			};
		}	
		function objectLookup() {
			var buckets = {};
			
			var findBucket = function(key) {
				var bucketKey;
				try {
					bucketKey = key;//JSON.stringify(key);
				}
				catch (e) {
					bucketKey = "$$$";
				}

				var bucket = buckets[bucketKey];
				if (bucket === undefined) {
					bucket = new simpleObjectLookup();
					buckets[bucketKey] = bucket;
				}
				return bucket;
			};
			
			this.save = function (key, value) {
				findBucket(key).save(key, value);
			};
			this.get = function (key) {
				return findBucket(key).get(key);
			};
		}}));
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.js 4.3.1-201130-21-086c3328-1a04bc7d

	*/
	let Wincor$1;Wincor$1=window.Wincor||{},Wincor$1.UI=Wincor$1.UI||{},Wincor$1.UI.Service=Wincor$1.UI.Service||{},Wincor$1.ConvHexToStr=function(n){return function(n){let r=null;if(function(n){return n.length%2==0}(n)&&function(n){for(let r=0;r<n.length;r++){let t=n[r];if(!(t>="A"&&t<="F"||t>="a"&&t<="f"||t>="0"&&t<="9"))return !1}return !0}(n)){r=function(n){let r="";for(let t=0;t<n.length;t++)t===n.length-1&&0===n[t]||(r+=String.fromCharCode(n[t]));return r}(function(n){let r=[];for(let t=0;t<n.length;t+=2){let e=`0x${n[t]}${n[t+1]}`;r.push(parseInt(e));}return r}(n));}return r}(n)},window.Wincor=Wincor$1;var Wincor$2 = Wincor$1;

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Diagnostics.js 4.3.1-201211-21-586b0f0c-1a04bc7d

	*/
	Wincor$2.UI.Diagnostics={};var diagnostics = Wincor$2.UI.Diagnostics;

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Diagnostics.ConsoleLogger.js 4.3.1-210127-21-34ae33df-1a04bc7d

	*/

	/**
	 * The ConsoleLogger class logs to the console. During application mode, this logger is interchanged with the LogService after an initialization phase.

	 * @module
	 *
	 */
	Wincor$2.UI.Diagnostics.ConsoleLogger = class ConsoleLogger { //Hint: don't write a log in here!!!

	    /**
	     * The type of this logger. Used by the service-provider.
	     * @const
	     * @type {String}
	     */
	    TYPE = "CONSOLE";

	    originalLogFunction = null;
	    originalErrorFunction = null;
	    originalClearFunction = null;

	    /**
	     * true, if this logger is attached.
	     * @type {boolean}
	     */
	    isAttached = false;

	    /** For the log levels see {@link Wincor.UI.Diagnostics.LogProvider} */
	    LOG_ANALYSE = 20;
	    /** For the log levels see {@link Wincor.UI.Diagnostics.LogProvider} */
	    LOG_EXCEPTION = 21;
	    /** For the log levels see {@link Wincor.UI.Diagnostics.LogProvider} */
	    LOG_ERROR = 22;
	    /** For the log levels see {@link Wincor.UI.Diagnostics.LogProvider} */
	    LOG_WARNING = 23;
	    /** For the log levels see {@link Wincor.UI.Diagnostics.LogProvider} */
	    LOG_INFO = 24;
	    /** For the log levels see {@link Wincor.UI.Diagnostics.LogProvider} */
	    LOG_INOUT = 25;
	    /** For the log levels see {@link Wincor.UI.Diagnostics.LogProvider} */
	    LOG_DATA = 26;
	    /** For the log levels see {@link Wincor.UI.Diagnostics.LogProvider} */
	    LOG_SRVC_INOUT = 27;
	    /** For the log levels see {@link Wincor.UI.Diagnostics.LogProvider} */
	    LOG_SRVC_DATA = 28;
	    /** For the log levels see {@link Wincor.UI.Diagnostics.LogProvider} */
	    LOG_DETAIL = 29;

	    /**
	     *
	     */
	    constructor() {
	        this.messageStack = [];
	        this.isAttached = false;
	        this.attachLogger();
	    }
	    
	    /**
	     * Logs a message to the console.
	     * @param {number} traceBit The traceBit used to log this message
	     * @param {String} message The logged message.
	     */
	    log(traceBit, message) {
	        if (traceBit) {
	            window.console.log(message);
	        }
	    }

	    /**
	     * Logs an error message to the console.
	     * @param {string} message The logged error message.
	     */
	    error(message) {
	        window.console.error(message);
	    }

	    isTraceBitSet (traceBit) {
	        return this[traceBit];
	    }

	    /**
	     * "Detaches" this logger: the native logging functions will be restored.
	     *
	     * Without detaching any other logging service, which will log to the console, would use the overriding functions of this logger,
	     * which will lead to a deadlock (because of recursive log() calls).
	     */
	    detachLogger() {
	        if (this.isAttached === true) {
	            window.console.log = this.originalLogFunction;
	            window.console.error = this.originalErrorFunction;
	            window.console.clear = this.originalClearFunction;
	            this.isAttached = false;
	        }
	    }

	    /**
	     * "Attaches" this logger: the native logging functions will be rescued and overridden by the functions of this service.
	     */
	    attachLogger() {
	        
	        if (this.isAttached === false) {
	            this.originalLogFunction = window.console.log;
	            this.originalErrorFunction = window.console.error;
	            this.originalClearFunction = window.console.clear;
	            
	            window.console.log = (msg) => {
	                let logProvider = Wincor$2.UI.Diagnostics.LogProvider;
	                if ((!logProvider) || (!logProvider.logger) || (logProvider.logger.TYPE === this.TYPE)) {
	                    // its just us... keep logging and remember logs
	                    if (Wincor$2.UI.Content && !Wincor$2.UI.Content.designModeExtended && !Wincor$2.UI.Content.designMode) {
	                        // only need messageStack if logservice is likely to be loaded
	                        this.messageStack.push([false, msg]); // false tells it's a trace entry
	                    }
	                    this.originalLogFunction.call(window.console, msg);
	                } else {
	                    logProvider.log(logProvider.LOG_DETAIL, "console.log: " + msg);
	                }
	            };

	            window.console.error = (msg) => {
	                let logProvider = Wincor$2.UI.Diagnostics.LogProvider;
	                if ((!logProvider) || (!logProvider.logger) || (logProvider.logger.TYPE === this.TYPE)) {
	                    // its just us... keep logging and remember logs
	                    this.messageStack.push([true, msg]); // true tells it's an error entry
	                    this.originalErrorFunction.call(window.console, msg);
	                } else {
	                    logProvider.error("console.error: " + msg);
	                }
	            };

	            window.console.clear = () => {
	                this.messageStack = [];
	                // check because e.g. firefox does not support console.clear!
	                if (this.originalClearFunction) {
	                    this.originalClearFunction.call(window.console);
	                }
	            };

	            this.isAttached = true;
	        }
	    }
	};

	//SINGLETON
	diagnostics.ConsoleLogger = new Wincor$2.UI.Diagnostics.ConsoleLogger();
	/**
	 * @class Wincor.UI.Diagnostics.ConsoleLogger
	 */
	var consoleLogger = diagnostics.ConsoleLogger;

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Diagnostics.LogProvider.js 4.3.1-210204-21-e1b78e33-1a04bc7d

	*/
	const TRACEBITS={20:"LOG_ANALYSE",21:"LOG_EXCEPTION",22:"LOG_ERROR",23:"LOG_WARNING",24:"LOG_INFO",25:"LOG_INOUT",26:"LOG_DATA",27:"LOG_SRVC_INOUT",28:"LOG_SRVC_DATA",29:"LOG_DETAIL"};Wincor$2.UI.Diagnostics.LogProvider=class{LOG_ANALYSE=20;LOG_EXCEPTION=21;LOG_ERROR=22;LOG_WARNING=23;LOG_INFO=24;LOG_INOUT=25;LOG_DATA=26;LOG_SRVC_INOUT=27;LOG_SRVC_DATA=28;LOG_DETAIL=29;logger=null;loggerHasTraceBits=!0;LOGGER_TYPE_CONSOLE="CONSOLE";LOGGER_TYPE_TRACELOG="TRACELOG";NAME="LogProvider";constructor(){this.setLogger(consoleLogger);}log(r,e){try{this.loggerHasTraceBits?this.logger.log(r,e):this.logger.log(e);}catch(r){consoleLogger.log(e);}}error(r){try{this.logger.error(r);}catch(e){consoleLogger.log(`*** ERROR *** ${r}`);}}onTraceBitsChanged(r){Object.keys(r).forEach((e=>this[TRACEBITS[e]]=r[e]?parseInt(e,10):0));}setLogger(r){this.logger&&this.logger.detachLogger&&this.logger.detachLogger(),this.logger=r,this.logger.attachLogger&&this.logger.attachLogger(),this.loggerHasTraceBits=void 0!==r.isTraceBitSet,this.loggerHasTraceBits&&r.registerTraceBitsChangedHandler&&(r.registerTraceBitsChangedHandler(this.onTraceBitsChanged.bind(this)),this.logger.readCurrentTraceBitStates()),console.log(`. setLogger - loggerHasTraceBits=${this.loggerHasTraceBits}`);}},Wincor$2.UI.Diagnostics.LogProvider=new Wincor$2.UI.Diagnostics.LogProvider;var LogProvider = Wincor$2.UI.Diagnostics.LogProvider;

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany
	 
	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.
	 
	 
	 $MOD$ wn.UI.bluebird.enhanced.js 4.3.1-201130-21-086c3328-1a04bc7d
	 
	 */
	/* @preserve
	 * The MIT License (MIT)
	 *
	 * Copyright (c) 2013-2018 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */
	var Promise$1 = (function(){return function t(e,n,r){function i(s,a){if(!n[s]){if(!e[s]){var c="function"==typeof _dereq_&&_dereq_;if(!a&&c)return c(s,!0);if(o)return o(s,!0);var l=new Error("Cannot find module '"+s+"'");throw l.code="MODULE_NOT_FOUND",l}var u=n[s]={exports:{}};e[s][0].call(u.exports,(function(t){var n=e[s][1][t];return i(n||t)}),u,u.exports,t,e,n,r);}return n[s].exports}for(var o="function"==typeof _dereq_&&_dereq_,s=0;s<r.length;s++)i(r[s]);return i}({1:[function(t,e,n){e.exports=function(t){var e=t._SomePromiseArray;function n(t){var n=new e(t),r=n.promise();return n.setHowMany(1),n.setUnwrap(),n.init(),r}t.any=function(t){return n(t)},t.prototype.any=function(){return n(this)};};},{}],2:[function(t,e,n){var r;try{throw new Error}catch(t){r=t;}var i=t("./schedule"),o=t("./queue");function s(){this._customScheduler=!1,this._isTickUsed=!1,this._lateQueue=new o(16),this._normalQueue=new o(16),this._haveDrainedQueues=!1;var t=this;this.drainQueues=function(){t._drainQueues();},this._schedule=i;}function a(t){for(;t.length()>0;)c(t);}function c(t){var e=t.shift();if("function"!=typeof e)e._settlePromises();else {var n=t.shift(),r=t.shift();e.call(n,r);}}s.prototype.setScheduler=function(t){var e=this._schedule;return this._schedule=t,this._customScheduler=!0,e},s.prototype.hasCustomScheduler=function(){return this._customScheduler},s.prototype.haveItemsQueued=function(){return this._isTickUsed||this._haveDrainedQueues},s.prototype.fatalError=function(t,e){e?(process.stderr.write("Fatal "+(t instanceof Error?t.stack:t)+"\n"),process.exit(2)):this.throwLater(t);},s.prototype.throwLater=function(t,e){if(1===arguments.length&&(e=t,t=function(){throw e}),"undefined"!=typeof setTimeout)setTimeout((function(){t(e);}),0);else try{this._schedule((function(){t(e);}));}catch(t){throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n")}},s.prototype.invokeLater=function(t,e,n){this._lateQueue.push(t,e,n),this._queueTick();},s.prototype.invoke=function(t,e,n){this._normalQueue.push(t,e,n),this._queueTick();},s.prototype.settlePromises=function(t){this._normalQueue._pushOne(t),this._queueTick();},s.prototype._drainQueues=function(){a(this._normalQueue),this._reset(),this._haveDrainedQueues=!0,a(this._lateQueue);},s.prototype._queueTick=function(){this._isTickUsed||(this._isTickUsed=!0,this._schedule(this.drainQueues));},s.prototype._reset=function(){this._isTickUsed=!1;},e.exports=s,e.exports.firstLineError=r;},{"./queue":26,"./schedule":29}],3:[function(t,e,n){e.exports=function(t,e,n,r){var i=!1,o=function(t,e){this._reject(e);},s=function(t,e){e.promiseRejectionQueued=!0,e.bindingPromise._then(o,o,null,this,t);},a=function(t,e){0==(50397184&this._bitField)&&this._resolveCallback(e.target);},c=function(t,e){e.promiseRejectionQueued||this._reject(t);};t.prototype.bind=function(o){i||(i=!0,t.prototype._propagateFrom=r.propagateFromFunction(),t.prototype._boundValue=r.boundValueFunction());var l=n(o),u=new t(e);u._propagateFrom(this,1);var p=this._target();if(u._setBoundTo(l),l instanceof t){var h={promiseRejectionQueued:!1,promise:u,target:p,bindingPromise:l};p._then(e,s,void 0,u,h),l._then(a,c,void 0,u,h),u._setOnCancel(l);}else u._resolveCallback(p);return u},t.prototype._setBoundTo=function(t){void 0!==t?(this._bitField=2097152|this._bitField,this._boundTo=t):this._bitField=-2097153&this._bitField;},t.prototype._isBound=function(){return 2097152==(2097152&this._bitField)},t.bind=function(e,n){return t.resolve(n).bind(e)};};},{}],4:[function(t,e,n){var r;"undefined"!=typeof Promise&&(r=Promise);var i=t("./promise")();i.noConflict=function(){try{Promise===i&&(Promise=r);}catch(t){}return i},e.exports=i;},{"./promise":22}],5:[function(t,e,n){var r=Object.create;if(r){var i=r(null),o=r(null);i[" size"]=o[" size"]=0;}e.exports=function(e){var n,r=t("./util"),i=r.canEvaluate;r.isIdentifier;function o(t,n){var i;if(null!=t&&(i=t[n]),"function"!=typeof i){var o="Object "+r.classString(t)+" has no method '"+r.toString(n)+"'";throw new e.TypeError(o)}return i}function s(t){return o(t,this.pop()).apply(t,this)}function a(t){return t[this]}function c(t){var e=+this;return e<0&&(e=Math.max(0,e+t.length)),t[e]}e.prototype.call=function(t){var e=[].slice.call(arguments,1);return e.push(t),this._then(s,void 0,void 0,e,void 0)},e.prototype.get=function(t){var e;if("number"==typeof t)e=c;else if(i){var r=n();e=null!==r?r:a;}else e=a;return this._then(e,void 0,void 0,t,void 0)};};},{"./util":36}],6:[function(t,e,n){e.exports=function(e,n,r,i){var o=t("./util"),s=o.tryCatch,a=o.errorObj,c=e._async;e.prototype.break=e.prototype.cancel=function(){if(!i.cancellation())return this._warn("cancellation is disabled");for(var t=this,e=t;t._isCancellable();){if(!t._cancelBy(e)){e._isFollowing()?e._followee().cancel():e._cancelBranched();break}var n=t._cancellationParent;if(null==n||!n._isCancellable()){t._isFollowing()?t._followee().cancel():t._cancelBranched();break}t._isFollowing()&&t._followee().cancel(),t._setWillBeCancelled(),e=t,t=n;}},e.prototype._branchHasCancelled=function(){this._branchesRemainingToCancel--;},e.prototype._enoughBranchesHaveCancelled=function(){return void 0===this._branchesRemainingToCancel||this._branchesRemainingToCancel<=0},e.prototype._cancelBy=function(t){return t===this?(this._branchesRemainingToCancel=0,this._invokeOnCancel(),!0):(this._branchHasCancelled(),!!this._enoughBranchesHaveCancelled()&&(this._invokeOnCancel(),!0))},e.prototype._cancelBranched=function(){this._enoughBranchesHaveCancelled()&&this._cancel();},e.prototype._cancel=function(){this._isCancellable()&&(this._setCancelled(),c.invoke(this._cancelPromises,this,void 0));},e.prototype._cancelPromises=function(){this._length()>0&&this._settlePromises();},e.prototype._unsetOnCancel=function(){this._onCancelField=void 0;},e.prototype._isCancellable=function(){return this.isPending()&&!this._isCancelled()},e.prototype.isCancellable=function(){return this.isPending()&&!this.isCancelled()},e.prototype._doInvokeOnCancel=function(t,e){if(o.isArray(t))for(var n=0;n<t.length;++n)this._doInvokeOnCancel(t[n],e);else if(void 0!==t)if("function"==typeof t){if(!e){var r=s(t).call(this._boundValue());r===a&&(this._attachExtraTrace(r.e),c.throwLater(r.e));}}else t._resultCancelled(this);},e.prototype._invokeOnCancel=function(){var t=this._onCancel();this._unsetOnCancel(),c.invoke(this._doInvokeOnCancel,this,t);},e.prototype._invokeInternalOnCancel=function(){this._isCancellable()&&(this._doInvokeOnCancel(this._onCancel(),!0),this._unsetOnCancel());},e.prototype._resultCancelled=function(){this.cancel();};};},{"./util":36}],7:[function(t,e,n){e.exports=function(e){var n=t("./util"),r=t("./es5").keys,i=n.tryCatch,o=n.errorObj;return function(t,s,a){return function(c){var l=a._boundValue();t:for(var u=0;u<t.length;++u){var p=t[u];if(p===Error||null!=p&&p.prototype instanceof Error){if(c instanceof p)return i(s).call(l,c)}else if("function"==typeof p){var h=i(p).call(l,c);if(h===o)return h;if(h)return i(s).call(l,c)}else if(n.isObject(c)){for(var f=r(p),_=0;_<f.length;++_){var d=f[_];if(p[d]!=c[d])continue t}return i(s).call(l,c)}}return e}}};},{"./es5":13,"./util":36}],8:[function(t,e,n){e.exports=function(t){var e=!1,n=[];function r(){this._trace=new r.CapturedTrace(i());}function i(){var t=n.length-1;if(t>=0)return n[t]}return t.prototype._promiseCreated=function(){},t.prototype._pushContext=function(){},t.prototype._popContext=function(){return null},t._peekContext=t.prototype._peekContext=function(){},r.prototype._pushContext=function(){void 0!==this._trace&&(this._trace._promiseCreated=null,n.push(this._trace));},r.prototype._popContext=function(){if(void 0!==this._trace){var t=n.pop(),e=t._promiseCreated;return t._promiseCreated=null,e}return null},r.CapturedTrace=null,r.create=function(){if(e)return new r},r.deactivateLongStackTraces=function(){},r.activateLongStackTraces=function(){var n=t.prototype._pushContext,o=t.prototype._popContext,s=t._peekContext,a=t.prototype._peekContext,c=t.prototype._promiseCreated;r.deactivateLongStackTraces=function(){t.prototype._pushContext=n,t.prototype._popContext=o,t._peekContext=s,t.prototype._peekContext=a,t.prototype._promiseCreated=c,e=!1;},e=!0,t.prototype._pushContext=r.prototype._pushContext,t.prototype._popContext=r.prototype._popContext,t._peekContext=t.prototype._peekContext=i,t.prototype._promiseCreated=function(){var t=this._peekContext();t&&null==t._promiseCreated&&(t._promiseCreated=this);};},r};},{}],9:[function(t,e,n){e.exports=function(e,n,r,i){var o,s,a,c,l=e._async,u=t("./errors").Warning,p=t("./util"),h=t("./es5"),f=p.canAttachTrace,_=/[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/,d=/\((?:timers\.js):\d+:\d+\)/,v=/[\/<\(](.+?):(\d+):(\d+)\)?\s*$/,y=null,g=null,m=!1,b=!(0==p.env("BLUEBIRD_DEBUG")),w=!(0==p.env("BLUEBIRD_WARNINGS")||!b&&!p.env("BLUEBIRD_WARNINGS")),C=!(0==p.env("BLUEBIRD_LONG_STACK_TRACES")||!b&&!p.env("BLUEBIRD_LONG_STACK_TRACES")),j=0!=p.env("BLUEBIRD_W_FORGOTTEN_RETURN")&&(w||!!p.env("BLUEBIRD_W_FORGOTTEN_RETURN"));!function(){var t=[];function n(){for(var e=0;e<t.length;++e)t[e]._notifyUnhandledRejection();r();}function r(){t.length=0;}c=function(e){t.push(e),setTimeout(n,1);},h.defineProperty(e,"_unhandledRejectionCheck",{value:n}),h.defineProperty(e,"_unhandledRejectionClear",{value:r});}(),e.prototype.suppressUnhandledRejections=function(){var t=this._target();t._bitField=-1048577&t._bitField|524288;},e.prototype._ensurePossibleRejectionHandled=function(){0==(524288&this._bitField)&&(this._setRejectionIsUnhandled(),c(this));},e.prototype._notifyUnhandledRejectionIsHandled=function(){z("rejectionHandled",o,void 0,this);},e.prototype._setReturnedNonUndefined=function(){this._bitField=268435456|this._bitField;},e.prototype._returnedNonUndefined=function(){return 0!=(268435456&this._bitField)},e.prototype._notifyUnhandledRejection=function(){if(this._isRejectionUnhandled()){var t=this._settledValue();this._setUnhandledRejectionIsNotified(),z("unhandledRejection",s,t,this);}},e.prototype._setUnhandledRejectionIsNotified=function(){this._bitField=262144|this._bitField;},e.prototype._unsetUnhandledRejectionIsNotified=function(){this._bitField=-262145&this._bitField;},e.prototype._isUnhandledRejectionNotified=function(){return (262144&this._bitField)>0},e.prototype._setRejectionIsUnhandled=function(){this._bitField=1048576|this._bitField;},e.prototype._unsetRejectionIsUnhandled=function(){this._bitField=-1048577&this._bitField,this._isUnhandledRejectionNotified()&&(this._unsetUnhandledRejectionIsNotified(),this._notifyUnhandledRejectionIsHandled());},e.prototype._isRejectionUnhandled=function(){return (1048576&this._bitField)>0},e.prototype._warn=function(t,e,n){return q(t,e,n||this)},e.onPossiblyUnhandledRejection=function(t){var n=e._getContext();s=p.contextBind(n,t);},e.onUnhandledRejectionHandled=function(t){var n=e._getContext();o=p.contextBind(n,t);};var k=function(){};e.longStackTraces=function(){if(l.haveItemsQueued()&&!et.longStackTraces)throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");if(!et.longStackTraces&&W()){var t=e.prototype._captureStackTrace,r=e.prototype._attachExtraTrace,i=e.prototype._dereferenceTrace;et.longStackTraces=!0,k=function(){if(l.haveItemsQueued()&&!et.longStackTraces)throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");e.prototype._captureStackTrace=t,e.prototype._attachExtraTrace=r,e.prototype._dereferenceTrace=i,n.deactivateLongStackTraces(),et.longStackTraces=!1;},e.prototype._captureStackTrace=U,e.prototype._attachExtraTrace=B,e.prototype._dereferenceTrace=M,n.activateLongStackTraces();}},e.hasLongStackTraces=function(){return et.longStackTraces&&W()};var E={unhandledrejection:{before:function(){var t=p.global.onunhandledrejection;return p.global.onunhandledrejection=null,t},after:function(t){p.global.onunhandledrejection=t;}},rejectionhandled:{before:function(){var t=p.global.onrejectionhandled;return p.global.onrejectionhandled=null,t},after:function(t){p.global.onrejectionhandled=t;}}},F=function(){var t=function(t,e){if(!t)return !p.global.dispatchEvent(e);var n;try{return n=t.before(),!p.global.dispatchEvent(e)}finally{t.after(n);}};try{if("function"==typeof CustomEvent){var e=new CustomEvent("CustomEvent");return p.global.dispatchEvent(e),function(e,n){e=e.toLowerCase();var r=new CustomEvent(e,{detail:n,cancelable:!0});return h.defineProperty(r,"promise",{value:n.promise}),h.defineProperty(r,"reason",{value:n.reason}),t(E[e],r)}}if("function"==typeof Event){e=new Event("CustomEvent");return p.global.dispatchEvent(e),function(e,n){e=e.toLowerCase();var r=new Event(e,{cancelable:!0});return r.detail=n,h.defineProperty(r,"promise",{value:n.promise}),h.defineProperty(r,"reason",{value:n.reason}),t(E[e],r)}}return (e=document.createEvent("CustomEvent")).initCustomEvent("testingtheevent",!1,!0,{}),p.global.dispatchEvent(e),function(e,n){e=e.toLowerCase();var r=document.createEvent("CustomEvent");return r.initCustomEvent(e,!1,!0,n),t(E[e],r)}}catch(t){}return function(){return !1}}(),x=p.isNode?function(){return process.emit.apply(process,arguments)}:p.global?function(t){var e="on"+t.toLowerCase(),n=p.global[e];return !!n&&(n.apply(p.global,[].slice.call(arguments,1)),!0)}:function(){return !1};function T(t,e){return {promise:e}}var P={promiseCreated:T,promiseFulfilled:T,promiseRejected:T,promiseResolved:T,promiseCancelled:T,promiseChained:function(t,e,n){return {promise:e,child:n}},warning:function(t,e){return {warning:e}},unhandledRejection:function(t,e,n){return {reason:e,promise:n}},rejectionHandled:T},R=function(t){var e=!1;try{e=x.apply(null,arguments);}catch(t){l.throwLater(t),e=!0;}var n=!1;try{n=F(t,P[t].apply(null,arguments));}catch(t){l.throwLater(t),n=!0;}return n||e};function S(){return !1}function O(t,e,n){var r=this;try{t(e,n,(function(t){if("function"!=typeof t)throw new TypeError("onCancel must be a function, got: "+p.toString(t));r._attachCancellationCallback(t);}));}catch(t){return t}}function A(t){if(!this._isCancellable())return this;var e=this._onCancel();void 0!==e?p.isArray(e)?e.push(t):this._setOnCancel([e,t]):this._setOnCancel(t);}function H(){return this._onCancelField}function V(t){this._onCancelField=t;}function D(){this._cancellationParent=void 0,this._onCancelField=void 0;}function I(t,e){if(0!=(1&e)){this._cancellationParent=t;var n=t._branchesRemainingToCancel;void 0===n&&(n=0),t._branchesRemainingToCancel=n+1;}0!=(2&e)&&t._isBound()&&this._setBoundTo(t._boundTo);}e.config=function(t){if("longStackTraces"in(t=Object(t))&&(t.longStackTraces?e.longStackTraces():!t.longStackTraces&&e.hasLongStackTraces()&&k()),"warnings"in t){var n=t.warnings;et.warnings=!!n,j=et.warnings,p.isObject(n)&&"wForgottenReturn"in n&&(j=!!n.wForgottenReturn);}if("cancellation"in t&&t.cancellation&&!et.cancellation){if(l.haveItemsQueued())throw new Error("cannot enable cancellation after promises are in use");e.prototype._clearCancellationData=D,e.prototype._propagateFrom=I,e.prototype._onCancel=H,e.prototype._setOnCancel=V,e.prototype._attachCancellationCallback=A,e.prototype._execute=O,L=I,et.cancellation=!0;}if("monitoring"in t&&(t.monitoring&&!et.monitoring?(et.monitoring=!0,e.prototype._fireEvent=R):!t.monitoring&&et.monitoring&&(et.monitoring=!1,e.prototype._fireEvent=S)),"asyncHooks"in t&&p.nodeSupportsAsyncResource){var o=et.asyncHooks,s=!!t.asyncHooks;o!==s&&(et.asyncHooks=s,s?r():i());}return e},e.prototype._fireEvent=S,e.prototype._execute=function(t,e,n){try{t(e,n);}catch(t){return t}},e.prototype._onCancel=function(){},e.prototype._setOnCancel=function(t){},e.prototype._attachCancellationCallback=function(t){},e.prototype._captureStackTrace=function(){},e.prototype._attachExtraTrace=function(){},e.prototype._dereferenceTrace=function(){},e.prototype._clearCancellationData=function(){},e.prototype._propagateFrom=function(t,e){};var L=function(t,e){0!=(2&e)&&t._isBound()&&this._setBoundTo(t._boundTo);};function N(){var t=this._boundTo;return void 0!==t&&t instanceof e?t.isFulfilled()?t.value():void 0:t}function U(){this._trace=new Z(this._peekContext());}function B(t,e){if(f(t)){var n=this._trace;if(void 0!==n&&e&&(n=n._parent),void 0!==n)n.attachExtraTrace(t);else if(!t.__stackCleaned__){var r=Q(t);p.notEnumerableProp(t,"stack",r.message+"\n"+r.stack.join("\n")),p.notEnumerableProp(t,"__stackCleaned__",!0);}}}function M(){this._trace=void 0;}function q(t,n,r){if(et.warnings){var i,o=new u(t);if(n)r._attachExtraTrace(o);else if(et.longStackTraces&&(i=e._peekContext()))i.attachExtraTrace(o);else {var s=Q(o);o.stack=s.message+"\n"+s.stack.join("\n");}R("warning",o)||G(o,"",!0);}}function $(t){for(var e=[],n=0;n<t.length;++n){var r=t[n],i="    (No stack trace)"===r||y.test(r),o=i&&K(r);i&&!o&&(m&&" "!==r.charAt(0)&&(r="    "+r),e.push(r));}return e}function Q(t){var e=t.stack,n=t.toString();return e="string"==typeof e&&e.length>0?function(t){for(var e=t.stack.replace(/\s+$/g,"").split("\n"),n=0;n<e.length;++n){var r=e[n];if("    (No stack trace)"===r||y.test(r))break}return n>0&&"SyntaxError"!=t.name&&(e=e.slice(n)),e}(t):["    (No stack trace)"],{message:n,stack:"SyntaxError"==t.name?e:$(e)}}function G(t,e,n){if("undefined"!=typeof console){var r;if(p.isObject(t)){var i=t.stack;r=e+g(i,t);}else r=e+String(t);"function"==typeof a?a(r,n):"function"!=typeof console.log&&"object"!=typeof console.log||console.log(r);}}function z(t,e,n,r){var i=!1;try{"function"==typeof e&&(i=!0,"rejectionHandled"===t?e(r):e(n,r));}catch(t){l.throwLater(t);}"unhandledRejection"===t?R(t,n,r)||i||G(n,"Unhandled rejection "):R(t,r);}function X(t){var e;if("function"==typeof t)e="[function "+(t.name||"anonymous")+"]";else {e=t&&"function"==typeof t.toString?t.toString():p.toString(t);if(/\[object [a-zA-Z0-9$_]+\]/.test(e))try{e=JSON.stringify(t);}catch(t){}0===e.length&&(e="(empty array)");}return "(<"+function(t){var e=41;if(t.length<e)return t;return t.substr(0,e-3)+"..."}(e)+">, no stack trace)"}function W(){return "function"==typeof tt}var K=function(){return !1},J=/[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;function Y(t){var e=t.match(J);if(e)return {fileName:e[1],line:parseInt(e[2],10)}}function Z(t){this._parent=t,this._promisesCreated=0;var e=this._length=1+(void 0===t?0:t._length);tt(this,Z),e>32&&this.uncycle();}p.inherits(Z,Error),n.CapturedTrace=Z,Z.prototype.uncycle=function(){var t=this._length;if(!(t<2)){for(var e=[],n={},r=0,i=this;void 0!==i;++r)e.push(i),i=i._parent;for(r=(t=this._length=r)-1;r>=0;--r){var o=e[r].stack;void 0===n[o]&&(n[o]=r);}for(r=0;r<t;++r){var s=n[e[r].stack];if(void 0!==s&&s!==r){s>0&&(e[s-1]._parent=void 0,e[s-1]._length=1),e[r]._parent=void 0,e[r]._length=1;var a=r>0?e[r-1]:this;s<t-1?(a._parent=e[s+1],a._parent.uncycle(),a._length=a._parent._length+1):(a._parent=void 0,a._length=1);for(var c=a._length+1,l=r-2;l>=0;--l)e[l]._length=c,c++;return}}}},Z.prototype.attachExtraTrace=function(t){if(!t.__stackCleaned__){this.uncycle();for(var e=Q(t),n=e.message,r=[e.stack],i=this;void 0!==i;)r.push($(i.stack.split("\n"))),i=i._parent;!function(t){for(var e=t[0],n=1;n<t.length;++n){for(var r=t[n],i=e.length-1,o=e[i],s=-1,a=r.length-1;a>=0;--a)if(r[a]===o){s=a;break}for(a=s;a>=0;--a){var c=r[a];if(e[i]!==c)break;e.pop(),i--;}e=r;}}(r),function(t){for(var e=0;e<t.length;++e)(0===t[e].length||e+1<t.length&&t[e][0]===t[e+1][0])&&(t.splice(e,1),e--);}(r),p.notEnumerableProp(t,"stack",function(t,e){for(var n=0;n<e.length-1;++n)e[n].push("From previous event:"),e[n]=e[n].join("\n");return n<e.length&&(e[n]=e[n].join("\n")),t+"\n"+e.join("\n")}(n,r)),p.notEnumerableProp(t,"__stackCleaned__",!0);}};var tt=function(){var t=/^\s*at\s*/,e=function(t,e){return "string"==typeof t?t:void 0!==e.name&&void 0!==e.message?e.toString():X(e)};if("number"==typeof Error.stackTraceLimit&&"function"==typeof Error.captureStackTrace){Error.stackTraceLimit+=6,y=t,g=e;var n=Error.captureStackTrace;return K=function(t){return _.test(t)},function(t,e){Error.stackTraceLimit+=6,n(t,e),Error.stackTraceLimit-=6;}}var r,i=new Error;if("string"==typeof i.stack&&i.stack.split("\n")[0].indexOf("stackDetection@")>=0)return y=/@/,g=e,m=!0,function(t){t.stack=(new Error).stack;};try{throw new Error}catch(t){r="stack"in t;}return !("stack"in i)&&r&&"number"==typeof Error.stackTraceLimit?(y=t,g=e,function(t){Error.stackTraceLimit+=6;try{throw new Error}catch(e){t.stack=e.stack;}Error.stackTraceLimit-=6;}):(g=function(t,e){return "string"==typeof t?t:"object"!=typeof e&&"function"!=typeof e||void 0===e.name||void 0===e.message?X(e):e.toString()},null)}();"undefined"!=typeof console&&void 0!==console.warn&&(a=function(t){console.warn(t);},p.isNode&&process.stderr.isTTY?a=function(t,e){var n=e?"[33m":"[31m";console.warn(n+t+"[0m\n");}:p.isNode||"string"!=typeof(new Error).stack||(a=function(t,e){console.warn("%c"+t,e?"color: darkorange":"color: red");}));var et={warnings:w,longStackTraces:!1,cancellation:!1,monitoring:!1,asyncHooks:!1};return C&&e.longStackTraces(),{asyncHooks:function(){return et.asyncHooks},longStackTraces:function(){return et.longStackTraces},warnings:function(){return et.warnings},cancellation:function(){return et.cancellation},monitoring:function(){return et.monitoring},propagateFromFunction:function(){return L},boundValueFunction:function(){return N},checkForgottenReturns:function(t,e,n,r,i){if(void 0===t&&null!==e&&j){if(void 0!==i&&i._returnedNonUndefined())return;if(0==(65535&r._bitField))return;n&&(n+=" ");var o="",s="";if(e._trace){for(var a=e._trace.stack.split("\n"),c=$(a),l=c.length-1;l>=0;--l){var u=c[l];if(!d.test(u)){var p=u.match(v);p&&(o="at "+p[1]+":"+p[2]+":"+p[3]+" ");break}}if(c.length>0){var h=c[0];for(l=0;l<a.length;++l)if(a[l]===h){l>0&&(s="\n"+a[l-1]);break}}}var f="a promise was created in a "+n+"handler "+o+"but was not returned from it, see http://goo.gl/rRqMUw"+s;r._warn(f,!0,e);}},setBounds:function(t,e){if(W()){for(var n,r,i=(t.stack||"").split("\n"),o=(e.stack||"").split("\n"),s=-1,a=-1,c=0;c<i.length;++c){if(l=Y(i[c])){n=l.fileName,s=l.line;break}}for(c=0;c<o.length;++c){var l;if(l=Y(o[c])){r=l.fileName,a=l.line;break}}s<0||a<0||!n||!r||n!==r||s>=a||(K=function(t){if(_.test(t))return !0;var e=Y(t);return !!(e&&e.fileName===n&&s<=e.line&&e.line<=a)});}},warn:q,deprecated:function(t,e){var n=t+" is deprecated and will be removed in a future version.";return e&&(n+=" Use "+e+" instead."),q(n)},CapturedTrace:Z,fireDomEvent:F,fireGlobalEvent:x}};},{"./errors":12,"./es5":13,"./util":36}],10:[function(t,e,n){e.exports=function(t){function e(){return this.value}function n(){throw this.reason}t.prototype.return=t.prototype.thenReturn=function(n){return n instanceof t&&n.suppressUnhandledRejections(),this._then(e,void 0,void 0,{value:n},void 0)},t.prototype.throw=t.prototype.thenThrow=function(t){return this._then(n,void 0,void 0,{reason:t},void 0)},t.prototype.catchThrow=function(t){if(arguments.length<=1)return this._then(void 0,n,void 0,{reason:t},void 0);var e=arguments[1],r=function(){throw e};return this.caught(t,r)},t.prototype.catchReturn=function(n){if(arguments.length<=1)return n instanceof t&&n.suppressUnhandledRejections(),this._then(void 0,e,void 0,{value:n},void 0);var r=arguments[1];r instanceof t&&r.suppressUnhandledRejections();var i=function(){return r};return this.caught(n,i)};};},{}],11:[function(t,e,n){e.exports=function(t,e){var n=t.reduce,r=t.all;function i(){return r(this)}t.prototype.each=function(t){return n(this,t,e,0)._then(i,void 0,void 0,this,void 0)},t.prototype.mapSeries=function(t){return n(this,t,e,e)},t.each=function(t,r){return n(t,r,e,0)._then(i,void 0,void 0,t,void 0)},t.mapSeries=function(t,r){return n(t,r,e,e)};};},{}],12:[function(t,e,n){var r,i,o=t("./es5"),s=o.freeze,a=t("./util"),c=a.inherits,l=a.notEnumerableProp;function u(t,e){function n(r){if(!(this instanceof n))return new n(r);l(this,"message","string"==typeof r?r:e),l(this,"name",t),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):Error.call(this);}return c(n,Error),n}var p=u("Warning","warning"),h=u("CancellationError","cancellation error"),f=u("TimeoutError","timeout error"),_=u("AggregateError","aggregate error");try{r=TypeError,i=RangeError;}catch(t){r=u("TypeError","type error"),i=u("RangeError","range error");}for(var d="join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "),v=0;v<d.length;++v)"function"==typeof Array.prototype[d[v]]&&(_.prototype[d[v]]=Array.prototype[d[v]]);o.defineProperty(_.prototype,"length",{value:0,configurable:!1,writable:!0,enumerable:!0}),_.prototype.isOperational=!0;var y=0;function g(t){if(!(this instanceof g))return new g(t);l(this,"name","OperationalError"),l(this,"message",t),this.cause=t,this.isOperational=!0,t instanceof Error?(l(this,"message",t.message),l(this,"stack",t.stack)):Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor);}_.prototype.toString=function(){var t=Array(4*y+1).join(" "),e="\n"+t+"AggregateError of:\n";y++,t=Array(4*y+1).join(" ");for(var n=0;n<this.length;++n){for(var r=this[n]===this?"[Circular AggregateError]":this[n]+"",i=r.split("\n"),o=0;o<i.length;++o)i[o]=t+i[o];e+=(r=i.join("\n"))+"\n";}return y--,e},c(g,Error);var m=Error.__BluebirdErrorTypes__;m||(m=s({CancellationError:h,TimeoutError:f,OperationalError:g,RejectionError:g,AggregateError:_}),o.defineProperty(Error,"__BluebirdErrorTypes__",{value:m,writable:!1,enumerable:!1,configurable:!1})),e.exports={Error,TypeError:r,RangeError:i,CancellationError:m.CancellationError,OperationalError:m.OperationalError,TimeoutError:m.TimeoutError,AggregateError:m.AggregateError,Warning:p};},{"./es5":13,"./util":36}],13:[function(t,e,n){var r=function(){return void 0===this}();if(r)e.exports={freeze:Object.freeze,defineProperty:Object.defineProperty,getDescriptor:Object.getOwnPropertyDescriptor,keys:Object.keys,names:Object.getOwnPropertyNames,getPrototypeOf:Object.getPrototypeOf,isArray:Array.isArray,isES5:r,propertyIsWritable:function(t,e){var n=Object.getOwnPropertyDescriptor(t,e);return !(n&&!n.writable&&!n.set)}};else {var i={}.hasOwnProperty,o={}.toString,s={}.constructor.prototype,a=function(t){var e=[];for(var n in t)i.call(t,n)&&e.push(n);return e};e.exports={isArray:function(t){try{return "[object Array]"===o.call(t)}catch(t){return !1}},keys:a,names:a,defineProperty:function(t,e,n){return t[e]=n.value,t},getDescriptor:function(t,e){return {value:t[e]}},freeze:function(t){return t},getPrototypeOf:function(t){try{return Object(t).constructor.prototype}catch(t){return s}},isES5:r,propertyIsWritable:function(){return !0}};}},{}],14:[function(t,e,n){e.exports=function(t,e){var n=t.map;t.prototype.filter=function(t,r){return n(this,t,r,e)},t.filter=function(t,r,i){return n(t,r,i,e)};};},{}],15:[function(t,e,n){e.exports=function(e,n,r){var i=t("./util"),o=e.CancellationError,s=i.errorObj,a=t("./catch_filter")(r);function c(t,e,n){this.promise=t,this.type=e,this.handler=n,this.called=!1,this.cancelPromise=null;}function l(t){this.finallyHandler=t;}function u(t,e){return null!=t.cancelPromise&&(arguments.length>1?t.cancelPromise._reject(e):t.cancelPromise._cancel(),t.cancelPromise=null,!0)}function p(){return f.call(this,this.promise._target()._settledValue())}function h(t){if(!u(this,t))return s.e=t,s}function f(t){var i=this.promise,a=this.handler;if(!this.called){this.called=!0;var c=this.isFinallyHandler()?a.call(i._boundValue()):a.call(i._boundValue(),t);if(c===r)return c;if(void 0!==c){i._setReturnedNonUndefined();var f=n(c,i);if(f instanceof e){if(null!=this.cancelPromise){if(f._isCancelled()){var _=new o("late cancellation observer");return i._attachExtraTrace(_),s.e=_,s}f.isPending()&&f._attachCancellationCallback(new l(this));}return f._then(p,h,void 0,this,void 0)}}}return i.isRejected()?(u(this),s.e=t,s):(u(this),t)}return c.prototype.isFinallyHandler=function(){return 0===this.type},l.prototype._resultCancelled=function(){u(this.finallyHandler);},e.prototype._passThrough=function(t,e,n,r){return "function"!=typeof t?this.then():this._then(n,r,void 0,new c(this,e,t),void 0)},e.prototype.lastly=e.prototype.finally=function(t){return this._passThrough(t,0,f,f)},e.prototype.tap=function(t){return this._passThrough(t,1,f)},e.prototype.tapCatch=function(t){var n=arguments.length;if(1===n)return this._passThrough(t,1,void 0,f);var r,o=new Array(n-1),s=0;for(r=0;r<n-1;++r){var c=arguments[r];if(!i.isObject(c))return e.reject(new TypeError("tapCatch statement predicate: expecting an object but got "+i.classString(c)));o[s++]=c;}o.length=s;var l=arguments[r];return this._passThrough(a(o,l,this),1,void 0,f)},c};},{"./catch_filter":7,"./util":36}],16:[function(t,e,n){e.exports=function(e,n,r,i,o,s){var a=t("./errors").TypeError,c=t("./util"),l=c.errorObj,u=c.tryCatch,p=[];function h(t,n,i,o){if(s.cancellation()){var a=new e(r),c=this._finallyPromise=new e(r);this._promise=a.lastly((function(){return c})),a._captureStackTrace(),a._setOnCancel(this);}else {(this._promise=new e(r))._captureStackTrace();}this._stack=o,this._generatorFunction=t,this._receiver=n,this._generator=void 0,this._yieldHandlers="function"==typeof i?[i].concat(p):p,this._yieldedPromise=null,this._cancellationPhase=!1;}c.inherits(h,o),h.prototype._isResolved=function(){return null===this._promise},h.prototype._cleanup=function(){this._promise=this._generator=null,s.cancellation()&&null!==this._finallyPromise&&(this._finallyPromise._fulfill(),this._finallyPromise=null);},h.prototype._promiseCancelled=function(){if(!this._isResolved()){var t;if(void 0!==this._generator.return)this._promise._pushContext(),t=u(this._generator.return).call(this._generator,void 0),this._promise._popContext();else {var n=new e.CancellationError("generator .return() sentinel");e.coroutine.returnSentinel=n,this._promise._attachExtraTrace(n),this._promise._pushContext(),t=u(this._generator.throw).call(this._generator,n),this._promise._popContext();}this._cancellationPhase=!0,this._yieldedPromise=null,this._continue(t);}},h.prototype._promiseFulfilled=function(t){this._yieldedPromise=null,this._promise._pushContext();var e=u(this._generator.next).call(this._generator,t);this._promise._popContext(),this._continue(e);},h.prototype._promiseRejected=function(t){this._yieldedPromise=null,this._promise._attachExtraTrace(t),this._promise._pushContext();var e=u(this._generator.throw).call(this._generator,t);this._promise._popContext(),this._continue(e);},h.prototype._resultCancelled=function(){if(this._yieldedPromise instanceof e){var t=this._yieldedPromise;this._yieldedPromise=null,t.cancel();}},h.prototype.promise=function(){return this._promise},h.prototype._run=function(){this._generator=this._generatorFunction.call(this._receiver),this._receiver=this._generatorFunction=void 0,this._promiseFulfilled(void 0);},h.prototype._continue=function(t){var n=this._promise;if(t===l)return this._cleanup(),this._cancellationPhase?n.cancel():n._rejectCallback(t.e,!1);var r=t.value;if(!0===t.done)return this._cleanup(),this._cancellationPhase?n.cancel():n._resolveCallback(r);var o=i(r,this._promise);if(o instanceof e||null!==(o=function(t,n,r){for(var o=0;o<n.length;++o){r._pushContext();var s=u(n[o])(t);if(r._popContext(),s===l){r._pushContext();var a=e.reject(l.e);return r._popContext(),a}var c=i(s,r);if(c instanceof e)return c}return null}(o,this._yieldHandlers,this._promise))){var s=(o=o._target())._bitField;0==(50397184&s)?(this._yieldedPromise=o,o._proxy(this,null)):0!=(33554432&s)?e._async.invoke(this._promiseFulfilled,this,o._value()):0!=(16777216&s)?e._async.invoke(this._promiseRejected,this,o._reason()):this._promiseCancelled();}else this._promiseRejected(new a("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s",String(r))+"From coroutine:\n"+this._stack.split("\n").slice(1,-7).join("\n")));},e.coroutine=function(t,e){if("function"!=typeof t)throw new a("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");var n=Object(e).yieldHandler,r=h,i=(new Error).stack;return function(){var e=t.apply(this,arguments),o=new r(void 0,void 0,n,i),s=o.promise();return o._generator=e,o._promiseFulfilled(void 0),s}},e.coroutine.addYieldHandler=function(t){if("function"!=typeof t)throw new a("expecting a function but got "+c.classString(t));p.push(t);},e.spawn=function(t){if(s.deprecated("Promise.spawn()","Promise.coroutine()"),"function"!=typeof t)return n("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");var r=new h(t,this),i=r.promise();return r._run(e.spawn),i};};},{"./errors":12,"./util":36}],17:[function(t,e,n){e.exports=function(e,n,r,i,o){var s=t("./util");s.canEvaluate,s.tryCatch,s.errorObj;e.join=function(){var t,e=arguments.length-1;e>0&&"function"==typeof arguments[e]&&(t=arguments[e]);var r=[].slice.call(arguments);t&&r.pop();var i=new n(r).promise();return void 0!==t?i.spread(t):i};};},{"./util":36}],18:[function(t,e,n){e.exports=function(e,n,r,i,o,s){var a=t("./util"),c=a.tryCatch,l=a.errorObj,u=e._async;function p(t,n,r,i){this.constructor$(t),this._promise._captureStackTrace();var s=e._getContext();if(this._callback=a.contextBind(s,n),this._preservedValues=i===o?new Array(this.length()):null,this._limit=r,this._inFlight=0,this._queue=[],u.invoke(this._asyncInit,this,void 0),a.isArray(t))for(var c=0;c<t.length;++c){var l=t[c];l instanceof e&&l.suppressUnhandledRejections();}}function h(t,n,i,o){if("function"!=typeof n)return r("expecting a function but got "+a.classString(n));var s=0;if(void 0!==i){if("object"!=typeof i||null===i)return e.reject(new TypeError("options argument must be an object but it is "+a.classString(i)));if("number"!=typeof i.concurrency)return e.reject(new TypeError("'concurrency' must be a number but it is "+a.classString(i.concurrency)));s=i.concurrency;}return new p(t,n,s="number"==typeof s&&isFinite(s)&&s>=1?s:0,o).promise()}a.inherits(p,n),p.prototype._asyncInit=function(){this._init$(void 0,-2);},p.prototype._init=function(){},p.prototype._promiseFulfilled=function(t,n){var r=this._values,o=this.length(),a=this._preservedValues,u=this._limit;if(n<0){if(r[n=-1*n-1]=t,u>=1&&(this._inFlight--,this._drainQueue(),this._isResolved()))return !0}else {if(u>=1&&this._inFlight>=u)return r[n]=t,this._queue.push(n),!1;null!==a&&(a[n]=t);var p=this._promise,h=this._callback,f=p._boundValue();p._pushContext();var _=c(h).call(f,t,n,o),d=p._popContext();if(s.checkForgottenReturns(_,d,null!==a?"Promise.filter":"Promise.map",p),_===l)return this._reject(_.e),!0;var v=i(_,this._promise);if(v instanceof e){var y=(v=v._target())._bitField;if(0==(50397184&y))return u>=1&&this._inFlight++,r[n]=v,v._proxy(this,-1*(n+1)),!1;if(0==(33554432&y))return 0!=(16777216&y)?(this._reject(v._reason()),!0):(this._cancel(),!0);_=v._value();}r[n]=_;}return ++this._totalResolved>=o&&(null!==a?this._filter(r,a):this._resolve(r),!0)},p.prototype._drainQueue=function(){for(var t=this._queue,e=this._limit,n=this._values;t.length>0&&this._inFlight<e;){if(this._isResolved())return;var r=t.pop();this._promiseFulfilled(n[r],r);}},p.prototype._filter=function(t,e){for(var n=e.length,r=new Array(n),i=0,o=0;o<n;++o)t[o]&&(r[i++]=e[o]);r.length=i,this._resolve(r);},p.prototype.preservedValues=function(){return this._preservedValues},e.prototype.map=function(t,e){return h(this,t,e,null)},e.map=function(t,e,n,r){return h(t,e,n,r)};};},{"./util":36}],19:[function(t,e,n){e.exports=function(e,n,r,i,o){var s=t("./util"),a=s.tryCatch;e.method=function(t){if("function"!=typeof t)throw new e.TypeError("expecting a function but got "+s.classString(t));return function(){var r=new e(n);r._captureStackTrace(),r._pushContext();var i=a(t).apply(this,arguments),s=r._popContext();return o.checkForgottenReturns(i,s,"Promise.method",r),r._resolveFromSyncValue(i),r}},e.attempt=e.try=function(t){if("function"!=typeof t)return i("expecting a function but got "+s.classString(t));var r,c=new e(n);if(c._captureStackTrace(),c._pushContext(),arguments.length>1){o.deprecated("calling Promise.try with more than 1 argument");var l=arguments[1],u=arguments[2];r=s.isArray(l)?a(t).apply(u,l):a(t).call(u,l);}else r=a(t)();var p=c._popContext();return o.checkForgottenReturns(r,p,"Promise.try",c),c._resolveFromSyncValue(r),c},e.prototype._resolveFromSyncValue=function(t){t===s.errorObj?this._rejectCallback(t.e,!1):this._resolveCallback(t,!0);};};},{"./util":36}],20:[function(t,e,n){var r=t("./util"),i=r.maybeWrapAsError,o=t("./errors").OperationalError,s=t("./es5");var a=/^(?:name|message|stack|cause)$/;function c(t){var e;if(function(t){return t instanceof Error&&s.getPrototypeOf(t)===Error.prototype}(t)){(e=new o(t)).name=t.name,e.message=t.message,e.stack=t.stack;for(var n=s.keys(t),i=0;i<n.length;++i){var c=n[i];a.test(c)||(e[c]=t[c]);}return e}return r.markAsOriginatingFromRejection(t),t}e.exports=function(t,e){return function(n,r){if(null!==t){if(n){var o=c(i(n));t._attachExtraTrace(o),t._reject(o);}else if(e){var s=[].slice.call(arguments,1);t._fulfill(s);}else t._fulfill(r);t=null;}}};},{"./errors":12,"./es5":13,"./util":36}],21:[function(t,e,n){e.exports=function(e){var n=t("./util"),r=e._async,i=n.tryCatch,o=n.errorObj;function s(t,e){if(!n.isArray(t))return a.call(this,t,e);var s=i(e).apply(this._boundValue(),[null].concat(t));s===o&&r.throwLater(s.e);}function a(t,e){var n=this._boundValue(),s=void 0===t?i(e).call(n,null):i(e).call(n,null,t);s===o&&r.throwLater(s.e);}function c(t,e){if(!t){var n=new Error(t+"");n.cause=t,t=n;}var s=i(e).call(this._boundValue(),t);s===o&&r.throwLater(s.e);}e.prototype.asCallback=e.prototype.nodeify=function(t,e){if("function"==typeof t){var n=a;void 0!==e&&Object(e).spread&&(n=s),this._then(n,c,void 0,this,t);}return this};};},{"./util":36}],22:[function(t,e,n){e.exports=function(){var n=function(){return new y("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n")},r=function(){return new O.PromiseInspection(this._target())},i=function(t){return O.reject(new y(t))};function o(){}var s={},a=t("./util");a.setReflectHandler(r);var c=function(){var t=process.domain;return void 0===t?null:t},l=function(){return {domain:c(),async:null}},u=a.isNode&&a.nodeSupportsAsyncResource?t("async_hooks").AsyncResource:null,p=function(){return {domain:c(),async:new u("Bluebird::Promise")}},h=a.isNode?l:function(){return null};a.notEnumerableProp(O,"_getContext",h);var f=t("./es5"),_=t("./async"),d=new _;f.defineProperty(O,"_async",{value:d});var v=t("./errors"),y=O.TypeError=v.TypeError;O.RangeError=v.RangeError;var g=O.CancellationError=v.CancellationError;O.TimeoutError=v.TimeoutError,O.OperationalError=v.OperationalError,O.RejectionError=v.OperationalError,O.AggregateError=v.AggregateError;var m=function(){},b={},w={},C=t("./thenables")(O,m),j=t("./promise_array")(O,m,C,i,o),k=t("./context")(O),E=k.create,F=t("./debuggability")(O,k,(function(){h=p,a.notEnumerableProp(O,"_getContext",p);}),(function(){h=l,a.notEnumerableProp(O,"_getContext",l);})),x=(F.CapturedTrace,t("./finally")(O,C,w)),T=t("./catch_filter")(w),P=t("./nodeback"),R=a.errorObj,S=a.tryCatch;function O(t){t!==m&&function(t,e){if(null==t||t.constructor!==O)throw new y("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");if("function"!=typeof e)throw new y("expecting a function but got "+a.classString(e))}(this,t),this._bitField=0,this._fulfillmentHandler0=void 0,this._rejectionHandler0=void 0,this._promise0=void 0,this._receiver0=void 0,this._resolveFromExecutor(t),this._promiseCreated(),this._fireEvent("promiseCreated",this);}function A(t){this.promise._resolveCallback(t);}function H(t){this.promise._rejectCallback(t,!1);}function V(t){var e=new O(m);e._fulfillmentHandler0=t,e._rejectionHandler0=t,e._promise0=t,e._receiver0=t;}return O.prototype.toString=function(){return "[object Promise]"},O.prototype.caught=O.prototype.catch=O.prototype.fail=function(t){var e=arguments.length;if(e>1){var n,r=new Array(e-1),o=0;for(n=0;n<e-1;++n){var s=arguments[n];if(!a.isObject(s))return i("Catch statement predicate: expecting an object but got "+a.classString(s));r[o++]=s;}if(r.length=o,"function"!=typeof(t=arguments[n]))throw new y("The last argument to .catch() must be a function, got "+a.toString(t));return this.then(void 0,T(r,t,this))}return this.then(void 0,t)},O.prototype.reflect=function(){return this._then(r,r,void 0,this,void 0)},O.prototype.then=function(t,e){if(F.warnings()&&arguments.length>0&&"function"!=typeof t&&"function"!=typeof e){var n=".then() only accepts functions but was passed: "+a.classString(t);arguments.length>1&&(n+=", "+a.classString(e)),this._warn(n);}return this._then(t,e,void 0,void 0,void 0)},O.prototype.done=function(t,e){this._then(t,e,void 0,void 0,void 0)._setIsFinal();},O.prototype.spread=function(t){return "function"!=typeof t?i("expecting a function but got "+a.classString(t)):this.all()._then(t,void 0,void 0,b,void 0)},O.prototype.toJSON=function(){var t={isFulfilled:!1,isRejected:!1,fulfillmentValue:void 0,rejectionReason:void 0};return this.isFulfilled()?(t.fulfillmentValue=this.value(),t.isFulfilled=!0):this.isRejected()&&(t.rejectionReason=this.reason(),t.isRejected=!0),t},O.prototype.all=function(){return arguments.length>0&&this._warn(".all() was passed arguments but it does not take any"),new j(this).promise()},O.prototype.error=function(t){return this.caught(a.originatesFromRejection,t)},O.getNewLibraryCopy=e.exports,O.is=function(t){return t instanceof O},O.fromNode=O.fromCallback=function(t){var e=new O(m);e._captureStackTrace();var n=arguments.length>1&&!!Object(arguments[1]).multiArgs,r=S(t)(P(e,n));return r===R&&e._rejectCallback(r.e,!0),e._isFateSealed()||e._setAsyncGuaranteed(),e},O.all=function(t){return new j(t).promise()},O.cast=function(t){var e=C(t);return e instanceof O||((e=new O(m))._captureStackTrace(),e._setFulfilled(),e._rejectionHandler0=t),e},O.resolve=O.fulfilled=O.cast,O.reject=O.rejected=function(t){var e=new O(m);return e._captureStackTrace(),e._rejectCallback(t,!0),e},O.setScheduler=function(t){if("function"!=typeof t)throw new y("expecting a function but got "+a.classString(t));return d.setScheduler(t)},O.prototype._then=function(t,e,n,r,i){var o=void 0!==i,s=o?i:new O(m),c=this._target(),l=c._bitField;o||(s._propagateFrom(this,3),s._captureStackTrace(),void 0===r&&0!=(2097152&this._bitField)&&(r=0!=(50397184&l)?this._boundValue():c===this?void 0:this._boundTo),this._fireEvent("promiseChained",this,s));var u=h();if(0!=(50397184&l)){var p,f,_=c._settlePromiseCtx;0!=(33554432&l)?(f=c._rejectionHandler0,p=t):0!=(16777216&l)?(f=c._fulfillmentHandler0,p=e,c._unsetRejectionIsUnhandled()):(_=c._settlePromiseLateCancellationObserver,f=new g("late cancellation observer"),c._attachExtraTrace(f),p=e),d.invoke(_,c,{handler:a.contextBind(u,p),promise:s,receiver:r,value:f});}else c._addCallbacks(t,e,s,r,u);return s},O.prototype._length=function(){return 65535&this._bitField},O.prototype._isFateSealed=function(){return 0!=(117506048&this._bitField)},O.prototype._isFollowing=function(){return 67108864==(67108864&this._bitField)},O.prototype._setLength=function(t){this._bitField=-65536&this._bitField|65535&t;},O.prototype._setFulfilled=function(){this._bitField=33554432|this._bitField,this._fireEvent("promiseFulfilled",this);},O.prototype._setRejected=function(){this._bitField=16777216|this._bitField,this._fireEvent("promiseRejected",this);},O.prototype._setFollowing=function(){this._bitField=67108864|this._bitField,this._fireEvent("promiseResolved",this);},O.prototype._setIsFinal=function(){this._bitField=4194304|this._bitField;},O.prototype._isFinal=function(){return (4194304&this._bitField)>0},O.prototype._unsetCancelled=function(){this._bitField=-65537&this._bitField;},O.prototype._setCancelled=function(){this._bitField=65536|this._bitField,this._fireEvent("promiseCancelled",this);},O.prototype._setWillBeCancelled=function(){this._bitField=8388608|this._bitField;},O.prototype._setAsyncGuaranteed=function(){if(!d.hasCustomScheduler()){var t=this._bitField;this._bitField=t|(536870912&t)>>2^134217728;}},O.prototype._setNoAsyncGuarantee=function(){this._bitField=-134217729&(536870912|this._bitField);},O.prototype._receiverAt=function(t){var e=0===t?this._receiver0:this[4*t-4+3];if(e!==s)return void 0===e&&this._isBound()?this._boundValue():e},O.prototype._promiseAt=function(t){return this[4*t-4+2]},O.prototype._fulfillmentHandlerAt=function(t){return this[4*t-4+0]},O.prototype._rejectionHandlerAt=function(t){return this[4*t-4+1]},O.prototype._boundValue=function(){},O.prototype._migrateCallback0=function(t){t._bitField;var e=t._fulfillmentHandler0,n=t._rejectionHandler0,r=t._promise0,i=t._receiverAt(0);void 0===i&&(i=s),this._addCallbacks(e,n,r,i,null);},O.prototype._migrateCallbackAt=function(t,e){var n=t._fulfillmentHandlerAt(e),r=t._rejectionHandlerAt(e),i=t._promiseAt(e),o=t._receiverAt(e);void 0===o&&(o=s),this._addCallbacks(n,r,i,o,null);},O.prototype._addCallbacks=function(t,e,n,r,i){var o=this._length();if(o>=65531&&(o=0,this._setLength(0)),0===o)this._promise0=n,this._receiver0=r,"function"==typeof t&&(this._fulfillmentHandler0=a.contextBind(i,t)),"function"==typeof e&&(this._rejectionHandler0=a.contextBind(i,e));else {var s=4*o-4;this[s+2]=n,this[s+3]=r,"function"==typeof t&&(this[s+0]=a.contextBind(i,t)),"function"==typeof e&&(this[s+1]=a.contextBind(i,e));}return this._setLength(o+1),o},O.prototype._proxy=function(t,e){this._addCallbacks(void 0,void 0,e,t,null);},O.prototype._resolveCallback=function(t,e){if(0==(117506048&this._bitField)){if(t===this)return this._rejectCallback(n(),!1);var r=C(t,this);if(!(r instanceof O))return this._fulfill(t);e&&this._propagateFrom(r,2);var i=r._target();if(i!==this){var o=i._bitField;if(0==(50397184&o)){var s=this._length();s>0&&i._migrateCallback0(this);for(var a=1;a<s;++a)i._migrateCallbackAt(this,a);this._setFollowing(),this._setLength(0),this._setFollowee(r);}else if(0!=(33554432&o))this._fulfill(i._value());else if(0!=(16777216&o))this._reject(i._reason());else {var c=new g("late cancellation observer");i._attachExtraTrace(c),this._reject(c);}}else this._reject(n());}},O.prototype._rejectCallback=function(t,e,n){var r=a.ensureErrorObject(t),i=r===t;if(!i&&!n&&F.warnings()){var o="a promise was rejected with a non-error: "+a.classString(t);this._warn(o,!0);}this._attachExtraTrace(r,!!e&&i),this._reject(t);},O.prototype._resolveFromExecutor=function(t){if(t!==m){var e=this;this._captureStackTrace(),this._pushContext();var n=!0,r=this._execute(t,(function(t){e._resolveCallback(t);}),(function(t){e._rejectCallback(t,n);}));n=!1,this._popContext(),void 0!==r&&e._rejectCallback(r,!0);}},O.prototype._settlePromiseFromHandler=function(t,e,n,r){var i=r._bitField;if(0==(65536&i)){var o;r._pushContext(),e===b?n&&"number"==typeof n.length?o=S(t).apply(this._boundValue(),n):(o=R).e=new y("cannot .spread() a non-array: "+a.classString(n)):o=S(t).call(e,n);var s=r._popContext();0==(65536&(i=r._bitField))&&(o===w?r._reject(n):o===R?r._rejectCallback(o.e,!1):(F.checkForgottenReturns(o,s,"",r,this),r._resolveCallback(o)));}},O.prototype._target=function(){for(var t=this;t._isFollowing();)t=t._followee();return t},O.prototype._followee=function(){return this._rejectionHandler0},O.prototype._setFollowee=function(t){this._rejectionHandler0=t;},O.prototype._settlePromise=function(t,e,n,i){var s=t instanceof O,a=this._bitField,c=0!=(134217728&a);0!=(65536&a)?(s&&t._invokeInternalOnCancel(),n instanceof x&&n.isFinallyHandler()?(n.cancelPromise=t,S(e).call(n,i)===R&&t._reject(R.e)):e===r?t._fulfill(r.call(n)):n instanceof o?n._promiseCancelled(t):s||t instanceof j?t._cancel():n.cancel()):"function"==typeof e?s?(c&&t._setAsyncGuaranteed(),this._settlePromiseFromHandler(e,n,i,t)):e.call(n,i,t):n instanceof o?n._isResolved()||(0!=(33554432&a)?n._promiseFulfilled(i,t):n._promiseRejected(i,t)):s&&(c&&t._setAsyncGuaranteed(),0!=(33554432&a)?t._fulfill(i):t._reject(i));},O.prototype._settlePromiseLateCancellationObserver=function(t){var e=t.handler,n=t.promise,r=t.receiver,i=t.value;"function"==typeof e?n instanceof O?this._settlePromiseFromHandler(e,r,i,n):e.call(r,i,n):n instanceof O&&n._reject(i);},O.prototype._settlePromiseCtx=function(t){this._settlePromise(t.promise,t.handler,t.receiver,t.value);},O.prototype._settlePromise0=function(t,e,n){var r=this._promise0,i=this._receiverAt(0);this._promise0=void 0,this._receiver0=void 0,this._settlePromise(r,t,i,e);},O.prototype._clearCallbackDataAtIndex=function(t){var e=4*t-4;this[e+2]=this[e+3]=this[e+0]=this[e+1]=void 0;},O.prototype._fulfill=function(t){var e=this._bitField;if(!((117506048&e)>>>16)){if(t===this){var r=n();return this._attachExtraTrace(r),this._reject(r)}this._setFulfilled(),this._rejectionHandler0=t,(65535&e)>0&&(0!=(134217728&e)?this._settlePromises():d.settlePromises(this),this._dereferenceTrace());}},O.prototype._reject=function(t){var e=this._bitField;if(!((117506048&e)>>>16)){if(this._setRejected(),this._fulfillmentHandler0=t,this._isFinal())return d.fatalError(t,a.isNode);(65535&e)>0?d.settlePromises(this):this._ensurePossibleRejectionHandled();}},O.prototype._fulfillPromises=function(t,e){for(var n=1;n<t;n++){var r=this._fulfillmentHandlerAt(n),i=this._promiseAt(n),o=this._receiverAt(n);this._clearCallbackDataAtIndex(n),this._settlePromise(i,r,o,e);}},O.prototype._rejectPromises=function(t,e){for(var n=1;n<t;n++){var r=this._rejectionHandlerAt(n),i=this._promiseAt(n),o=this._receiverAt(n);this._clearCallbackDataAtIndex(n),this._settlePromise(i,r,o,e);}},O.prototype._settlePromises=function(){var t=this._bitField,e=65535&t;if(e>0){if(0!=(16842752&t)){var n=this._fulfillmentHandler0;this._settlePromise0(this._rejectionHandler0,n,t),this._rejectPromises(e,n);}else {var r=this._rejectionHandler0;this._settlePromise0(this._fulfillmentHandler0,r,t),this._fulfillPromises(e,r);}this._setLength(0);}this._clearCancellationData();},O.prototype._settledValue=function(){var t=this._bitField;return 0!=(33554432&t)?this._rejectionHandler0:0!=(16777216&t)?this._fulfillmentHandler0:void 0},"undefined"!=typeof Symbol&&Symbol.toStringTag&&f.defineProperty(O.prototype,Symbol.toStringTag,{get:function(){return "Object"}}),O.defer=O.pending=function(){return F.deprecated("Promise.defer","new Promise"),{promise:new O(m),resolve:A,reject:H}},a.notEnumerableProp(O,"_makeSelfResolutionError",n),t("./method")(O,m,C,i,F),t("./bind")(O,m,C,F),t("./cancel")(O,j,i,F),t("./direct_resolve")(O),t("./synchronous_inspection")(O),t("./join")(O,j,C,m,d),O.Promise=O,O.version="3.7.2",t("./call_get.js")(O),t("./generators.js")(O,i,m,C,o,F),t("./map.js")(O,j,i,C,m,F),t("./nodeify.js")(O),t("./promisify.js")(O,m),t("./props.js")(O,j,C,i),t("./race.js")(O,m,C,i),t("./reduce.js")(O,j,i,C,m,F),t("./settle.js")(O,j,F),t("./some.js")(O,j,i),t("./timers.js")(O,m,F),t("./using.js")(O,i,C,E,m,F),t("./any.js")(O),t("./each.js")(O,m),t("./filter.js")(O,m),a.toFastProperties(O),a.toFastProperties(O.prototype),V({a:1}),V({b:2}),V({c:3}),V(1),V((function(){})),V(void 0),V(!1),V(new O(m)),F.setBounds(_.firstLineError,a.lastLineError),O};},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36,async_hooks:void 0}],23:[function(t,e,n){e.exports=function(e,n,r,i,o){var s=t("./util");s.isArray;function a(t){var r=this._promise=new e(n);t instanceof e&&(r._propagateFrom(t,3),t.suppressUnhandledRejections()),r._setOnCancel(this),this._values=t,this._length=0,this._totalResolved=0,this._init(void 0,-2);}return s.inherits(a,o),a.prototype.length=function(){return this._length},a.prototype.promise=function(){return this._promise},a.prototype._init=function t(n,o){var a=r(this._values,this._promise);if(a instanceof e){var c=(a=a._target())._bitField;if(this._values=a,0==(50397184&c))return this._promise._setAsyncGuaranteed(),a._then(t,this._reject,void 0,this,o);if(0==(33554432&c))return 0!=(16777216&c)?this._reject(a._reason()):this._cancel();a=a._value();}if(null!==(a=s.asArray(a)))0!==a.length?this._iterate(a):-5===o?this._resolveEmptyArray():this._resolve(function(t){switch(t){case-2:return [];case-3:return {};case-6:return new Map}}(o));else {var l=i("expecting an array or an iterable object but got "+s.classString(a)).reason();this._promise._rejectCallback(l,!1);}},a.prototype._iterate=function(t){var n=this.getActualLength(t.length);this._length=n,this._values=this.shouldCopyValues()?new Array(n):this._values;for(var i=this._promise,o=!1,s=null,a=0;a<n;++a){var c=r(t[a],i);s=c instanceof e?(c=c._target())._bitField:null,o?null!==s&&c.suppressUnhandledRejections():null!==s?0==(50397184&s)?(c._proxy(this,a),this._values[a]=c):o=0!=(33554432&s)?this._promiseFulfilled(c._value(),a):0!=(16777216&s)?this._promiseRejected(c._reason(),a):this._promiseCancelled(a):o=this._promiseFulfilled(c,a);}o||i._setAsyncGuaranteed();},a.prototype._isResolved=function(){return null===this._values},a.prototype._resolve=function(t){this._values=null,this._promise._fulfill(t);},a.prototype._cancel=function(){!this._isResolved()&&this._promise._isCancellable()&&(this._values=null,this._promise._cancel());},a.prototype._reject=function(t){this._values=null,this._promise._rejectCallback(t,!1);},a.prototype._promiseFulfilled=function(t,e){return this._values[e]=t,++this._totalResolved>=this._length&&(this._resolve(this._values),!0)},a.prototype._promiseCancelled=function(){return this._cancel(),!0},a.prototype._promiseRejected=function(t){return this._totalResolved++,this._reject(t),!0},a.prototype._resultCancelled=function(){if(!this._isResolved()){var t=this._values;if(this._cancel(),t instanceof e)t.cancel();else for(var n=0;n<t.length;++n)t[n]instanceof e&&t[n].cancel();}},a.prototype.shouldCopyValues=function(){return !0},a.prototype.getActualLength=function(t){return t},a};},{"./util":36}],24:[function(t,e,n){e.exports=function(e,n){var r={},i=t("./util"),o=t("./nodeback"),s=i.withAppended,a=i.maybeWrapAsError,c=i.canEvaluate,l=t("./errors").TypeError,u={__isPromisified__:!0},p=new RegExp("^(?:"+["arity","length","name","arguments","caller","callee","prototype","__isPromisified__"].join("|")+")$"),h=function(t){return i.isIdentifier(t)&&"_"!==t.charAt(0)&&"constructor"!==t};function f(t){return !p.test(t)}function _(t){try{return !0===t.__isPromisified__}catch(t){return !1}}function d(t,e,n){var r=i.getDataPropertyOrDefault(t,e+n,u);return !!r&&_(r)}function v(t,e,n,r){for(var o=i.inheritedDataKeys(t),s=[],a=0;a<o.length;++a){var c=o[a],u=t[c],p=r===h||h(c);"function"!=typeof u||_(u)||d(t,c,e)||!r(c,u,t,p)||s.push(c,u);}return function(t,e,n){for(var r=0;r<t.length;r+=2){var i=t[r];if(n.test(i))for(var o=i.replace(n,""),s=0;s<t.length;s+=2)if(t[s]===o)throw new l("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s",e))}}(s,e,n),s}var y;var g=c?y:function(t,c,l,u,p,h){var f=function(){return this}(),_=t;function d(){var i=c;c===r&&(i=this);var l=new e(n);l._captureStackTrace();var u="string"==typeof _&&this!==f?this[_]:t,p=o(l,h);try{u.apply(i,s(arguments,p));}catch(t){l._rejectCallback(a(t),!0,!0);}return l._isFateSealed()||l._setAsyncGuaranteed(),l}return "string"==typeof _&&(t=u),i.notEnumerableProp(d,"__isPromisified__",!0),d};function m(t,e,n,o,s){for(var a=new RegExp(e.replace(/([$])/,"\\$")+"$"),c=v(t,e,a,n),l=0,u=c.length;l<u;l+=2){var p=c[l],h=c[l+1],f=p+e;if(o===g)t[f]=g(p,r,p,h,e,s);else {var _=o(h,(function(){return g(p,r,p,h,e,s)}));i.notEnumerableProp(_,"__isPromisified__",!0),t[f]=_;}}return i.toFastProperties(t),t}e.promisify=function(t,e){if("function"!=typeof t)throw new l("expecting a function but got "+i.classString(t));if(_(t))return t;var n=function(t,e,n){return g(t,e,void 0,t,null,n)}(t,void 0===(e=Object(e)).context?r:e.context,!!e.multiArgs);return i.copyDescriptors(t,n,f),n},e.promisifyAll=function(t,e){if("function"!=typeof t&&"object"!=typeof t)throw new l("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");var n=!!(e=Object(e)).multiArgs,r=e.suffix;"string"!=typeof r&&(r="Async");var o=e.filter;"function"!=typeof o&&(o=h);var s=e.promisifier;if("function"!=typeof s&&(s=g),!i.isIdentifier(r))throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");for(var a=i.inheritedDataKeys(t),c=0;c<a.length;++c){var u=t[a[c]];"constructor"!==a[c]&&i.isClass(u)&&(m(u.prototype,r,o,s,n),m(u,r,o,s,n));}return m(t,r,o,s,n)};};},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(t,e,n){e.exports=function(e,n,r,i){var o,s=t("./util"),a=s.isObject,c=t("./es5");"function"==typeof Map&&(o=Map);var l=function(){var t=0,e=0;function n(n,r){this[t]=n,this[t+e]=r,t++;}return function(r){e=r.size,t=0;var i=new Array(2*r.size);return r.forEach(n,i),i}}();function u(t){var e,n=!1;if(void 0!==o&&t instanceof o)e=l(t),n=!0;else {var r=c.keys(t),i=r.length;e=new Array(2*i);for(var s=0;s<i;++s){var a=r[s];e[s]=t[a],e[s+i]=a;}}this.constructor$(e),this._isMap=n,this._init$(void 0,n?-6:-3);}function p(t){var n,o=r(t);return a(o)?(n=o instanceof e?o._then(e.props,void 0,void 0,void 0,void 0):new u(o).promise(),o instanceof e&&n._propagateFrom(o,2),n):i("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n")}s.inherits(u,n),u.prototype._init=function(){},u.prototype._promiseFulfilled=function(t,e){if(this._values[e]=t,++this._totalResolved>=this._length){var n;if(this._isMap)n=function(t){for(var e=new o,n=t.length/2|0,r=0;r<n;++r){var i=t[n+r],s=t[r];e.set(i,s);}return e}(this._values);else {n={};for(var r=this.length(),i=0,s=this.length();i<s;++i)n[this._values[i+r]]=this._values[i];}return this._resolve(n),!0}return !1},u.prototype.shouldCopyValues=function(){return !1},u.prototype.getActualLength=function(t){return t>>1},e.prototype.props=function(){return p(this)},e.props=function(t){return p(t)};};},{"./es5":13,"./util":36}],26:[function(t,e,n){function r(t){this._capacity=t,this._length=0,this._front=0;}r.prototype._willBeOverCapacity=function(t){return this._capacity<t},r.prototype._pushOne=function(t){var e=this.length();this._checkCapacity(e+1),this[this._front+e&this._capacity-1]=t,this._length=e+1;},r.prototype.push=function(t,e,n){var r=this.length()+3;if(this._willBeOverCapacity(r))return this._pushOne(t),this._pushOne(e),void this._pushOne(n);var i=this._front+r-3;this._checkCapacity(r);var o=this._capacity-1;this[i+0&o]=t,this[i+1&o]=e,this[i+2&o]=n,this._length=r;},r.prototype.shift=function(){var t=this._front,e=this[t];return this[t]=void 0,this._front=t+1&this._capacity-1,this._length--,e},r.prototype.length=function(){return this._length},r.prototype._checkCapacity=function(t){this._capacity<t&&this._resizeTo(this._capacity<<1);},r.prototype._resizeTo=function(t){var e=this._capacity;this._capacity=t,function(t,e,n,r,i){for(var o=0;o<i;++o)n[o+r]=t[o+e],t[o+e]=void 0;}(this,0,this,e,this._front+this._length&e-1);},e.exports=r;},{}],27:[function(t,e,n){e.exports=function(e,n,r,i){var o=t("./util");function s(t,a){var c,l=r(t);if(l instanceof e)return (c=l).then((function(t){return s(t,c)}));if(null===(t=o.asArray(t)))return i("expecting an array or an iterable object but got "+o.classString(t));var u=new e(n);void 0!==a&&u._propagateFrom(a,3);for(var p=u._fulfill,h=u._reject,f=0,_=t.length;f<_;++f){var d=t[f];(void 0!==d||f in t)&&e.cast(d)._then(p,h,void 0,u,null);}return u}e.race=function(t){return s(t,void 0)},e.prototype.race=function(){return s(this,void 0)};};},{"./util":36}],28:[function(t,e,n){e.exports=function(e,n,r,i,o,s){var a=t("./util"),c=a.tryCatch;function l(t,n,r,i){this.constructor$(t);var s=e._getContext();this._fn=a.contextBind(s,n),void 0!==r&&(r=e.resolve(r))._attachCancellationCallback(this),this._initialValue=r,this._currentCancellable=null,this._eachValues=i===o?Array(this._length):0===i?null:void 0,this._promise._captureStackTrace(),this._init$(void 0,-5);}function u(t,e){this.isFulfilled()?e._resolve(t):e._reject(t);}function p(t,e,n,i){return "function"!=typeof e?r("expecting a function but got "+a.classString(e)):new l(t,e,n,i).promise()}function h(t){this.accum=t,this.array._gotAccum(t);var n=i(this.value,this.array._promise);return n instanceof e?(this.array._currentCancellable=n,n._then(f,void 0,void 0,this,void 0)):f.call(this,n)}function f(t){var n,r=this.array,i=r._promise,o=c(r._fn);i._pushContext(),(n=void 0!==r._eachValues?o.call(i._boundValue(),t,this.index,this.length):o.call(i._boundValue(),this.accum,t,this.index,this.length))instanceof e&&(r._currentCancellable=n);var a=i._popContext();return s.checkForgottenReturns(n,a,void 0!==r._eachValues?"Promise.each":"Promise.reduce",i),n}a.inherits(l,n),l.prototype._gotAccum=function(t){void 0!==this._eachValues&&null!==this._eachValues&&t!==o&&this._eachValues.push(t);},l.prototype._eachComplete=function(t){return null!==this._eachValues&&this._eachValues.push(t),this._eachValues},l.prototype._init=function(){},l.prototype._resolveEmptyArray=function(){this._resolve(void 0!==this._eachValues?this._eachValues:this._initialValue);},l.prototype.shouldCopyValues=function(){return !1},l.prototype._resolve=function(t){this._promise._resolveCallback(t),this._values=null;},l.prototype._resultCancelled=function(t){if(t===this._initialValue)return this._cancel();this._isResolved()||(this._resultCancelled$(),this._currentCancellable instanceof e&&this._currentCancellable.cancel(),this._initialValue instanceof e&&this._initialValue.cancel());},l.prototype._iterate=function(t){var n,r;this._values=t;var i=t.length;void 0!==this._initialValue?(n=this._initialValue,r=0):(n=e.resolve(t[0]),r=1),this._currentCancellable=n;for(var o=r;o<i;++o){var s=t[o];s instanceof e&&s.suppressUnhandledRejections();}if(!n.isRejected())for(;r<i;++r){var a={accum:null,value:t[r],index:r,length:i,array:this};n=n._then(h,void 0,void 0,a,void 0),0==(127&r)&&n._setNoAsyncGuarantee();}void 0!==this._eachValues&&(n=n._then(this._eachComplete,void 0,void 0,this,void 0)),n._then(u,u,void 0,n,this);},e.prototype.reduce=function(t,e){return p(this,t,e,null)},e.reduce=function(t,e,n,r){return p(t,e,n,r)};};},{"./util":36}],29:[function(t,e,n){var r,i=t("./util"),o=i.getNativePromise();if(i.isNode&&"undefined"==typeof MutationObserver){var s=global.setImmediate,a=process.nextTick;r=i.isRecentNode?function(t){s.call(global,t);}:function(t){a.call(process,t);};}else if("function"==typeof o&&"function"==typeof o.resolve){var c=o.resolve();r=function(t){c.then(t);};}else r="undefined"==typeof MutationObserver||"undefined"!=typeof window&&window.navigator&&(window.navigator.standalone||window.cordova)||!("classList"in document.documentElement)?"undefined"!=typeof setImmediate?function(t){setImmediate(t);}:"undefined"!=typeof setTimeout?function(t){setTimeout(t,0);}:function(){throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n")}:function(){var t=document.createElement("div"),e={attributes:!0},n=!1,r=document.createElement("div");new MutationObserver((function(){t.classList.toggle("foo"),n=!1;})).observe(r,e);return function(i){var o=new MutationObserver((function(){o.disconnect(),i();}));o.observe(t,e),n||(n=!0,r.classList.toggle("foo"));}}();e.exports=r;},{"./util":36}],30:[function(t,e,n){e.exports=function(e,n,r){var i=e.PromiseInspection;function o(t){this.constructor$(t);}t("./util").inherits(o,n),o.prototype._promiseResolved=function(t,e){return this._values[t]=e,++this._totalResolved>=this._length&&(this._resolve(this._values),!0)},o.prototype._promiseFulfilled=function(t,e){var n=new i;return n._bitField=33554432,n._settledValueField=t,this._promiseResolved(e,n)},o.prototype._promiseRejected=function(t,e){var n=new i;return n._bitField=16777216,n._settledValueField=t,this._promiseResolved(e,n)},e.settle=function(t){return r.deprecated(".settle()",".reflect()"),new o(t).promise()},e.allSettled=function(t){return new o(t).promise()},e.prototype.settle=function(){return e.settle(this)};};},{"./util":36}],31:[function(t,e,n){e.exports=function(e,n,r){var i=t("./util"),o=t("./errors").RangeError,s=t("./errors").AggregateError,a=i.isArray,c={};function l(t){this.constructor$(t),this._howMany=0,this._unwrap=!1,this._initialized=!1;}function u(t,e){if((0|e)!==e||e<0)return r("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");var n=new l(t),i=n.promise();return n.setHowMany(e),n.init(),i}i.inherits(l,n),l.prototype._init=function(){if(this._initialized)if(0!==this._howMany){this._init$(void 0,-5);var t=a(this._values);!this._isResolved()&&t&&this._howMany>this._canPossiblyFulfill()&&this._reject(this._getRangeError(this.length()));}else this._resolve([]);},l.prototype.init=function(){this._initialized=!0,this._init();},l.prototype.setUnwrap=function(){this._unwrap=!0;},l.prototype.howMany=function(){return this._howMany},l.prototype.setHowMany=function(t){this._howMany=t;},l.prototype._promiseFulfilled=function(t){return this._addFulfilled(t),this._fulfilled()===this.howMany()&&(this._values.length=this.howMany(),1===this.howMany()&&this._unwrap?this._resolve(this._values[0]):this._resolve(this._values),!0)},l.prototype._promiseRejected=function(t){return this._addRejected(t),this._checkOutcome()},l.prototype._promiseCancelled=function(){return this._values instanceof e||null==this._values?this._cancel():(this._addRejected(c),this._checkOutcome())},l.prototype._checkOutcome=function(){if(this.howMany()>this._canPossiblyFulfill()){for(var t=new s,e=this.length();e<this._values.length;++e)this._values[e]!==c&&t.push(this._values[e]);return t.length>0?this._reject(t):this._cancel(),!0}return !1},l.prototype._fulfilled=function(){return this._totalResolved},l.prototype._rejected=function(){return this._values.length-this.length()},l.prototype._addRejected=function(t){this._values.push(t);},l.prototype._addFulfilled=function(t){this._values[this._totalResolved++]=t;},l.prototype._canPossiblyFulfill=function(){return this.length()-this._rejected()},l.prototype._getRangeError=function(t){var e="Input array must contain at least "+this._howMany+" items but contains only "+t+" items";return new o(e)},l.prototype._resolveEmptyArray=function(){this._reject(this._getRangeError(0));},e.some=function(t,e){return u(t,e)},e.prototype.some=function(t){return u(this,t)},e._SomePromiseArray=l;};},{"./errors":12,"./util":36}],32:[function(t,e,n){e.exports=function(t){function e(t){void 0!==t?(t=t._target(),this._bitField=t._bitField,this._settledValueField=t._isFateSealed()?t._settledValue():void 0):(this._bitField=0,this._settledValueField=void 0);}e.prototype._settledValue=function(){return this._settledValueField};var n=e.prototype.value=function(){if(!this.isFulfilled())throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");return this._settledValue()},r=e.prototype.error=e.prototype.reason=function(){if(!this.isRejected())throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");return this._settledValue()},i=e.prototype.isFulfilled=function(){return 0!=(33554432&this._bitField)},o=e.prototype.isRejected=function(){return 0!=(16777216&this._bitField)},s=e.prototype.isPending=function(){return 0==(50397184&this._bitField)},a=e.prototype.isResolved=function(){return 0!=(50331648&this._bitField)};e.prototype.isCancelled=function(){return 0!=(8454144&this._bitField)},t.prototype.__isCancelled=function(){return 65536==(65536&this._bitField)},t.prototype._isCancelled=function(){return this._target().__isCancelled()},t.prototype.isCancelled=function(){return 0!=(8454144&this._target()._bitField)},t.prototype.isPending=function(){return s.call(this._target())},t.prototype.isRejected=function(){return o.call(this._target())},t.prototype.isFulfilled=function(){return i.call(this._target())},t.prototype.isResolved=function(){return a.call(this._target())},t.prototype.value=function(){return n.call(this._target())},t.prototype.reason=function(){var t=this._target();return t._unsetRejectionIsUnhandled(),r.call(t)},t.prototype._value=function(){return this._settledValue()},t.prototype._reason=function(){return this._unsetRejectionIsUnhandled(),this._settledValue()},t.PromiseInspection=e;};},{}],33:[function(t,e,n){e.exports=function(e,n){var r=t("./util"),i=r.errorObj,o=r.isObject;var s={}.hasOwnProperty;return function(t,a){if(o(t)){if(t instanceof e)return t;var c=function(t){try{return function(t){return t.then}(t)}catch(t){return i.e=t,i}}(t);if(c===i){a&&a._pushContext();var l=e.reject(c.e);return a&&a._popContext(),l}if("function"==typeof c){if(function(t){try{return s.call(t,"_promise0")}catch(t){return !1}}(t)){l=new e(n);return t._then(l._fulfill,l._reject,void 0,l,null),l}return function(t,o,s){var a=new e(n),c=a;s&&s._pushContext();a._captureStackTrace(),s&&s._popContext();var l=!0,u=r.tryCatch(o).call(t,p,h);l=!1,a&&u===i&&(a._rejectCallback(u.e,!0,!0),a=null);function p(t){a&&(a._resolveCallback(t),a=null);}function h(t){a&&(a._rejectCallback(t,l,!0),a=null);}return c}(t,c,a)}}return t}};},{"./util":36}],34:[function(t,e,n){e.exports=function(e,n,r){var i=t("./util"),o=e.TimeoutError;function s(t){this.handle=t;}s.prototype._resultCancelled=function(){clearTimeout(this.handle);};var a=function(t){return c(+this).thenReturn(t)},c=e.delay=function(t,i){var o,c;return void 0!==i?(o=e.resolve(i)._then(a,null,null,t,void 0),r.cancellation()&&i instanceof e&&o._setOnCancel(i)):(o=new e(n),c=setTimeout((function(){o._fulfill();}),+t),r.cancellation()&&o._setOnCancel(new s(c)),o._captureStackTrace()),o._setAsyncGuaranteed(),o};e.prototype.delay=function(t){return c(t,this)};function l(t){return clearTimeout(this.handle),t}function u(t){throw clearTimeout(this.handle),t}e.prototype.timeout=function(t,e){var n,a;t=+t;var c=new s(setTimeout((function(){n.isPending()&&function(t,e,n){var r;r="string"!=typeof e?e instanceof Error?e:new o("operation timed out"):new o(e),i.markAsOriginatingFromRejection(r),t._attachExtraTrace(r),t._reject(r),null!=n&&n.cancel();}(n,e,a);}),t));return r.cancellation()?(a=this.then(),(n=a._then(l,u,void 0,c,void 0))._setOnCancel(c)):n=this._then(l,u,void 0,c,void 0),n};};},{"./util":36}],35:[function(t,e,n){e.exports=function(e,n,r,i,o,s){var a=t("./util"),c=t("./errors").TypeError,l=t("./util").inherits,u=a.errorObj,p=a.tryCatch,h={};function f(t){setTimeout((function(){throw t}),0);}function _(t,n){var i=0,s=t.length,a=new e(o);return function o(){if(i>=s)return a._fulfill();var c=function(t){var e=r(t);return e!==t&&"function"==typeof t._isDisposable&&"function"==typeof t._getDisposer&&t._isDisposable()&&e._setDisposable(t._getDisposer()),e}(t[i++]);if(c instanceof e&&c._isDisposable()){try{c=r(c._getDisposer().tryDispose(n),t.promise);}catch(t){return f(t)}if(c instanceof e)return c._then(o,f,null,null,null)}o();}(),a}function d(t,e,n){this._data=t,this._promise=e,this._context=n;}function v(t,e,n){this.constructor$(t,e,n);}function y(t){return d.isDisposer(t)?(this.resources[this.index]._setDisposable(t),t.promise()):t}function g(t){this.length=t,this.promise=null,this[t-1]=null;}d.prototype.data=function(){return this._data},d.prototype.promise=function(){return this._promise},d.prototype.resource=function(){return this.promise().isFulfilled()?this.promise().value():h},d.prototype.tryDispose=function(t){var e=this.resource(),n=this._context;void 0!==n&&n._pushContext();var r=e!==h?this.doDispose(e,t):null;return void 0!==n&&n._popContext(),this._promise._unsetDisposable(),this._data=null,r},d.isDisposer=function(t){return null!=t&&"function"==typeof t.resource&&"function"==typeof t.tryDispose},l(v,d),v.prototype.doDispose=function(t,e){return this.data().call(t,t,e)},g.prototype._resultCancelled=function(){for(var t=this.length,n=0;n<t;++n){var r=this[n];r instanceof e&&r.cancel();}},e.using=function(){var t=arguments.length;if(t<2)return n("you must pass at least 2 arguments to Promise.using");var i,o=arguments[t-1];if("function"!=typeof o)return n("expecting a function but got "+a.classString(o));var c=!0;2===t&&Array.isArray(arguments[0])?(t=(i=arguments[0]).length,c=!1):(i=arguments,t--);for(var l=new g(t),h=0;h<t;++h){var f=i[h];if(d.isDisposer(f)){var v=f;(f=f.promise())._setDisposable(v);}else {var m=r(f);m instanceof e&&(f=m._then(y,null,null,{resources:l,index:h},void 0));}l[h]=f;}var b=new Array(l.length);for(h=0;h<b.length;++h)b[h]=e.resolve(l[h]).reflect();var w=e.all(b).then((function(t){for(var e=0;e<t.length;++e){var n=t[e];if(n.isRejected())return u.e=n.error(),u;if(!n.isFulfilled())return void w.cancel();t[e]=n.value();}C._pushContext(),o=p(o);var r=c?o.apply(void 0,t):o(t),i=C._popContext();return s.checkForgottenReturns(r,i,"Promise.using",C),r})),C=w.lastly((function(){var t=new e.PromiseInspection(w);return _(l,t)}));return l.promise=C,C._setOnCancel(l),C},e.prototype._setDisposable=function(t){this._bitField=131072|this._bitField,this._disposer=t;},e.prototype._isDisposable=function(){return (131072&this._bitField)>0},e.prototype._getDisposer=function(){return this._disposer},e.prototype._unsetDisposable=function(){this._bitField=-131073&this._bitField,this._disposer=void 0;},e.prototype.disposer=function(t){if("function"==typeof t)return new v(t,this,i());throw new c};};},{"./errors":12,"./util":36}],36:[function(t,e,n){var r=t("./es5"),i="undefined"==typeof navigator,o={e:{}},s,a="undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0!==this?this:null;function c(){try{var t=s;return s=null,t.apply(this,arguments)}catch(t){return o.e=t,o}}function l(t){return s=t,c}var u=function(t,e){var n={}.hasOwnProperty;function r(){for(var r in this.constructor=t,this.constructor$=e,e.prototype)n.call(e.prototype,r)&&"$"!==r.charAt(r.length-1)&&(this[r+"$"]=e.prototype[r]);}return r.prototype=e.prototype,t.prototype=new r,t.prototype};function p(t){return null==t||!0===t||!1===t||"string"==typeof t||"number"==typeof t}function h(t){return "function"==typeof t||"object"==typeof t&&null!==t}function f(t){return p(t)?new Error(E(t)):t}function _(t,e){var n,r=t.length,i=new Array(r+1);for(n=0;n<r;++n)i[n]=t[n];return i[n]=e,i}function d(t,e,n){if(!r.isES5)return {}.hasOwnProperty.call(t,e)?t[e]:void 0;var i=Object.getOwnPropertyDescriptor(t,e);return null!=i?null==i.get&&null==i.set?i.value:n:void 0}function v(t,e,n){if(p(t))return t;var i={value:n,configurable:!0,enumerable:!1,writable:!0};return r.defineProperty(t,e,i),t}function y(t){throw t}var g=function(){var t=[Array.prototype,Object.prototype,Function.prototype],e=function(e){for(var n=0;n<t.length;++n)if(t[n]===e)return !0;return !1};if(r.isES5){var n=Object.getOwnPropertyNames;return function(t){for(var i=[],o=Object.create(null);null!=t&&!e(t);){var s;try{s=n(t);}catch(t){return i}for(var a=0;a<s.length;++a){var c=s[a];if(!o[c]){o[c]=!0;var l=Object.getOwnPropertyDescriptor(t,c);null!=l&&null==l.get&&null==l.set&&i.push(c);}}t=r.getPrototypeOf(t);}return i}}var i={}.hasOwnProperty;return function(n){if(e(n))return [];var r=[];t:for(var o in n)if(i.call(n,o))r.push(o);else {for(var s=0;s<t.length;++s)if(i.call(t[s],o))continue t;r.push(o);}return r}}(),m=/this\s*\.\s*\S+\s*=/;function b(t){try{if("function"==typeof t){var e=r.names(t.prototype),n=r.isES5&&e.length>1,i=e.length>0&&!(1===e.length&&"constructor"===e[0]),o=m.test(t+"")&&r.names(t).length>0;if(n||i||o)return !0}return !1}catch(t){return !1}}function w(t){return t}var C=/^[a-z$_][a-z$_0-9]*$/i;function j(t){return C.test(t)}function k(t,e,n){for(var r=new Array(t),i=0;i<t;++i)r[i]=e+i+n;return r}function E(t){try{return t+""}catch(t){return "[no string representation]"}}function F(t){return t instanceof Error||null!==t&&"object"==typeof t&&"string"==typeof t.message&&"string"==typeof t.name}function x(t){try{v(t,"isOperational",!0);}catch(t){}}function T(t){return null!=t&&(t instanceof Error.__BluebirdErrorTypes__.OperationalError||!0===t.isOperational)}function P(t){return F(t)&&r.propertyIsWritable(t,"stack")}var R="stack"in new Error?function(t){return P(t)?t:new Error(E(t))}:function(t){if(P(t))return t;try{throw new Error(E(t))}catch(t){return t}};function S(t){return {}.toString.call(t)}function O(t,e,n){for(var i=r.names(t),o=0;o<i.length;++o){var s=i[o];if(n(s))try{r.defineProperty(e,s,r.getDescriptor(t,s));}catch(t){}}}var A=function(t){return r.isArray(t)?t:null};if("undefined"!=typeof Symbol&&Symbol.iterator){var H="function"==typeof Array.from?function(t){return Array.from(t)}:function(t){for(var e,n=[],r=t[Symbol.iterator]();!(e=r.next()).done;)n.push(e.value);return n};A=function(t){return r.isArray(t)?t:null!=t&&"function"==typeof t[Symbol.iterator]?H(t):null};}var V="undefined"!=typeof process&&"[object process]"===S(process).toLowerCase(),D="undefined"!=typeof process&&void 0!==process.env,I;function L(t){return D?process.env[t]:void 0}function N(){if("function"==typeof Promise)try{if("[object Promise]"===S(new Promise((function(){}))))return Promise}catch(t){}}function U(t,e){if(null===t||"function"!=typeof e||e===I)return e;null!==t.domain&&(e=t.domain.bind(e));var n=t.async;if(null!==n){var r=e;e=function(){var t=new Array(2).concat([].slice.call(arguments));return t[0]=r,t[1]=this,n.runInAsyncScope.apply(n,t)};}return e}var B={setReflectHandler:function(t){I=t;},isClass:b,isIdentifier:j,inheritedDataKeys:g,getDataPropertyOrDefault:d,thrower:y,isArray:r.isArray,asArray:A,notEnumerableProp:v,isPrimitive:p,isObject:h,isError:F,canEvaluate:i,errorObj:o,tryCatch:l,inherits:u,withAppended:_,maybeWrapAsError:f,toFastProperties:w,filledRange:k,toString:E,canAttachTrace:P,ensureErrorObject:R,originatesFromRejection:T,markAsOriginatingFromRejection:x,classString:S,copyDescriptors:O,isNode:V,hasEnvVariables:D,env:L,global:a,getNativePromise:N,contextBind:U},M;B.isRecentNode=B.isNode&&(process.versions&&process.versions.node?M=process.versions.node.split(".").map(Number):process.version&&(M=process.version.split(".").map(Number)),0===M[0]&&M[1]>10||M[0]>0),B.nodeSupportsAsyncResource=B.isNode&&function(){var e=!1;try{e="function"==typeof t("async_hooks").AsyncResource.prototype.runInAsyncScope;}catch(t){e=!1;}return e}(),B.isNode&&B.toFastProperties(process);try{throw new Error}catch(t){B.lastLineError=t;}e.exports=B;},{"./es5":13,async_hooks:void 0}]},{},[4])(4)}());"undefined"!=typeof window&&null!==window?window.P=window.Promise:"undefined"!=typeof self&&null!==self&&(self.P=self.Promise);

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.extensions.js 4.3.1-210203-21-1b8704b6-1a04bc7d
	 */
	const filters=["whenAvailable rejected due to deactivation"];let EXTENSIONS=null;const getExtensions=({Wincor:e,LogProvider:t}={})=>{const n=t;window.addEventListener("unhandledrejection",(function(t){const o=n;t.preventDefault();const i=t.detail?t.detail.reason:"unknown",r=t.detail?t.detail.promise:{};let s;if(r._trace&&(s=r._trace.stack),!s&&t.detail&&t.detail.reason&&t.detail.reason.stack&&(s=t.detail.reason.stack),e.UI.longStackTraces||t.detail&&"object"==typeof t.detail.reason){filters.reduce(((e,t)=>e&&(!i||"string"!=typeof i||!i.includes(t))),!0)&&o.error("Promise unhandledrejection reason: "+i+(s?" \n"+s:""));}else o.LOG_ERROR&&o.log(o.LOG_ERROR,"Promise unhandledrejection reason: "+i+(s?" \n"+s:""));})),window.addEventListener("rejectionhandled",(function(t){const o=n;t.preventDefault();const i=t.detail?t.detail.promise:{},r=t.detail?t.detail.reason:"unknown";let s;i._trace&&(s=i._trace.stack),!s&&t.detail&&t.detail.reason&&t.detail.reason.stack&&(s=t.detail.reason.stack),e.UI.longStackTraces||t.detail&&"object"==typeof t.detail.reason?e.UI.Diagnostics.LogProvider.error("Promise rejectionhandled reason: "+r+(s?" \n"+s:"")):o.LOG_ERROR&&o.log(o.LOG_ERROR,"Promise rejectionhandled reason: "+r+(s?" \n"+s:""));})),Promise$1.setScheduler&&Promise$1.config({warnings:!1,longStackTraces:!!e.UI.longStackTraces,cancellation:!1,monitoring:!1}),e.UI.promise=e.UI.promise||function(e){return new Promise$1(e)},e.UI.Promise=e.UI.Promise||Promise$1,e.UI.Promise.getStackTrace=e.UI.Promise.getStackTrace||function(t,n=!1){if(!e.UI.longStackTraces)return null;const o=e.UI.Diagnostics.LogProvider;if(!t||!t.then)return o.error("Wincor.UI.Promise.getStackTrace: invalid argument for promise"),null;let i=null;return t._trace&&(i=t._trace.stack),i&&n&&o.error(`Promise stack: ${i}`),i};let o=0;function i(t,n){let i;o+=1,"string"!=typeof t&&"number"!=typeof t||(i=t),this.id=(i||"gen")+"_"+o,this.resolve=void 0,this.reject=void 0,this.promise=e.UI.promise(((e,t)=>{if(this.resolve=function(t){e(t);},this.reject=function(e){t(e);},n&&"function"==typeof n)return n(e,t)}));}e.UI.deferred=e.UI.deferred||function(e,t){return new i(e,t)},e.UI.promisify=e.UI.promisify||function(t,n,o){return function(){try{const i=Array.prototype.slice.call(arguments,0),r="number"==typeof o&&o>=0?o:i.length;return e.UI.promise(function(o,s){try{i.splice(r,0,(function(e){o(e);})),t.apply(n,i);}catch(n){e.UI.Diagnostics.LogProvider.log("promisified function failed "+n+"\n originalFunc: "+t),s(`promisified function failed ${n}\n originalFunc: ${t}`);}}.bind(n))}catch(n){e.UI.Diagnostics.LogProvider.log("promisifying function failed "+n+"\n originalFunc: "+t);}}},e.UI.serializeProcessing=e.UI.serializeProcessing||function(t,n,o){return e.UI.promise((function(e,i){let r;r=o?Promise$1.all([o]):Promise$1.all([Promise$1.resolve()]);let s=0;const c=t.length,u=[];let a=!0;t.reduce((function(r,l){return a=!1,s++,r.then(function(i,r,s){const a=s?s[0]:void 0,l=Promise$1.all([n(i,r-1,t,a)]);return (r>1||o)&&u.push(a),r>=c&&l.then((function(t){u.push(t[0]),e(u);})),l}.bind(null,l,s),(function(){i("Wincor.UI.serializeProcessing promise rejected");}))}),r),a&&e();}))};let r=1;const s=function(t=!1){this.enqueuedJobs=[],this.mainPromise=Promise$1.resolve(),this.queueIsProcessing=!1,this.concurrency=t,this.name="AsyncJobQueue"+r++,this.stopOnError=!0,this.jobId=0,this.defaultJobTimeout=0,this.currentlyExecutingConcurrency="",this.cancelDfd=new i("AsyncJobQueue::cancel"),this.runningPromise=null,this.setConcurrency=function(e){return n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`> AsyncJobQueue::setConcurrency [${this.name}](${e})`),this.concurrency=!!e,n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::setConcurrency"),this},this.setName=function(e){return n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`> AsyncJobQueue::setName [${this.name}](${e})`),this.name=e,n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::setName"),this},this.setDefaultJobTimeout=function(e){return n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`> AsyncJobQueue::setDefaultJobTimeout [${this.name}](${e})`),this.defaultJobTimeout=e,n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::setDefaultJobTimeout"),this},this.setStopOnError=function(e=!0){return n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`> AsyncJobQueue::setStopOnError [${this.name}](${e})`),this.stopOnError=e,n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::setStopOnError"),this},this.isRunning=function(){return !!this.mainPromise&&this.mainPromise.isPending()},this._cleanUp=function(){this.jobId=0,this.enqueuedJobs=[],this.currentlyExecutingConcurrency="",this.queueIsProcessing=!1,this.runningPromise=null,this.cancelDfd.promise.catch((()=>{})),this.cancelDfd.reject("rejected due to _cleanUp called"),this.cancelDfd=new i("AsyncJobQueue::cancel");},this.workObjectsGenerator=function*(t,o){const i=this;let r,s,c,u,a,l,d,h;const m=this.cancelDfd.promise;function I(e,t,o,r){return n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${i.name}] starting timeout of jobId: ${e} ${t?" concurrencyId: "+t:""}`),Promise$1.delay(2*o.timeout).timeout(o.timeout,r)}for(;m.isPending()&&this.enqueuedJobs.length>0;){l=[];do{r=this.enqueuedJobs.pop(),s=r.workObject,u=r.concurrencyId,void 0!==u&&(this.currentlyExecutingConcurrency=u),c=typeof s,h=r.jobId;let t=!1,o=!1;if("object"===c&&s.then)o=!0,n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${this.name}] pushing promise with  jobId: ${h} ${u?" concurrencyId: "+u:""}`),d=s;else if("function"===c){n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${this.name}] executing func with  jobId: ${h} ${u?" concurrencyId: "+u:""}`);try{d=s(),n.LOG_DETAIL&&e.UI.longStackTraces&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${this.name}] function was: ${s.name}`),d&&d.then||(d=Promise$1.resolve());}catch(e){if(n.error("AsyncJobQueue::workObjectsGenerator ["+this.name+"] exception caught: "+e.message),this.stopOnError)throw e;t=!0,d=Promise$1.resolve();}}const m=e.UI.Promise.getStackTrace(d);if(n.LOG_DETAIL&&m&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${this.name}] stacktrace of this promise: ${m}`),!t&&r.timeout){const e=r.timeoutMessage||"jobId: "+h;o||r.timeoutStarter||"number"!=typeof r.timeout||(d=d.timeout(r.timeout,e)),"object"==typeof r.timeoutStarter&&r.timeoutStarter.then&&(d=Promise$1.race([d,r.timeoutStarter.then(I.bind(this,h,u,r,e))]));}d=d.then(function(e,t){n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${i.name}] finished jobId: ${e} ${t?" concurrencyId: "+t:""}`);}.bind(null,h,u)).catch((e=>{n.LOG_ERROR&&n.log(n.LOG_ERROR,`AsyncJobQueue::workObjectsGenerator [${i.name}] rejected jobId: ${h} ${u?" concurrencyId: "+u:""} with ${e}`);let t=r.continueOnErrors;if(!(!0===t||e&&Array.isArray(t)&&(t.includes(e)||t.includes(e.name))))throw e;n.error(`WARNING: AsyncJobQueue::workObjectsGenerator [${i.name}] Timeout of jobId: ${h} ${u?" concurrencyId: "+u:""}\nRecovering due to continueOnErrors=${t}`);})),l.push(d),this.concurrency&&(a=this.enqueuedJobs.length>0?this.enqueuedJobs[this.enqueuedJobs.length-1].concurrencyId:null);}while(this.concurrency&&void 0!==u&&u===a);1===l.length?(l[0].concurrencyId=u,yield l[0]):(l.concurrencyId=u,yield Promise$1.all(l));}m.isPending()?t():o(`workObjectsGenerator rejected because of an error=false or cancelPromise.isPending=${m.isPending()}`);},this.cancel=function(e){return new Promise$1((t=>{n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`> AsyncJobQueue::cancel [${this.name}]() - enqueuedJobs: ${this.enqueuedJobs.length}`),this.mainPromise&&this.mainPromise.isPending()?(this.mainPromise.then((()=>{n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::cancel resolved mainPromise");})).catch((()=>{n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::cancel rejected mainPromise");})).finally((()=>{t(),this._cleanUp();})),this.cancelDfd.reject(`AsyncJobQueue::cancel called for [${this.name}] by ${e}`),this.cancelDfd=new i("AsyncJobQueue::cancel"),this.workObjects.next()):(n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"< AsyncJobQueue::cancel"),t());}))},this.add=function(e,t,o,r,s,c=!1){if(this.jobId++,this.queueIsProcessing||n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::add [${this.name}] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> start processing`),n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::add [${this.name}] Adding jobId: ${this.jobId} ${t?"concurrencyId: "+t:""}, current len: ${this.enqueuedJobs.length+(this.queueIsProcessing?"":" start processing")}`),this.queueIsProcessing&&"function"==typeof e){if(!this.concurrency||0===this.enqueuedJobs.length&&this.currentlyExecutingConcurrency===t)n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::add [${this.name}] (queue empty, last item processing) -> executing job with jobId: ${this.jobId}`),(e=e())&&e.then||(e=Promise$1.resolve());else if(this.concurrency&&this.enqueuedJobs.length>0){const o=0===this.enqueuedJobs.filter((e=>e.concurrencyId!==t)).length;this.currentlyExecutingConcurrency===t&&o&&(n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::add [${this.name}] (queue has all same ids) -> executing job with jobId: ${this.jobId}`),(e=e())&&e.then||(e=Promise$1.resolve()));}}else n.LOG_DETAIL&&n.log(n.LOG_DETAIL,"AsyncJobQueue::add queue will start processing");const u={workObject:e,concurrencyId:t,jobId:this.jobId,timeout:o||this.defaultJobTimeout||0,timeoutMessage:r,timeoutStarter:s||0,continueOnErrors:c};return u.timeout||n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${this.name}] no timeout for jobId: ${this.jobId} ${t?" concurrencyId: "+t:""}`),!u.timeoutStarter&&u.timeout&&e.then&&(n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator [${this.name}] starting timeout (${u.timeout}) immediately for jobId: ${this.jobId} ${t?" concurrencyId: "+t:""}`),u.workObject=e.timeout(u.timeout,"string"==typeof r?r:void 0)),this.enqueuedJobs.unshift(u),this.queueIsProcessing||(this.queueIsProcessing=!0,this.mainDeferred=new i(this.name,((e,t)=>{this.workObjects=this.workObjectsGenerator((()=>{this.queueIsProcessing=!1,e();}),t);const o=e=>Promise$1.race([e,this.cancelDfd.promise]).then((t=>{let i=1;t&&t.length&&(i=t.length),n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator processNext [${this.name}] ${i} job(s) finished ${e.concurrencyId?"concurrencyId: "+e.concurrencyId:""} - remaining jobs:${this.enqueuedJobs.length}`);const r=this.workObjects.next();if(!r.done)return r.value.hasOwnProperty("concurrencyId")&&delete r.value.concurrencyId,this.runningPromise=r.value,o(r.value)})).catch((e=>{t(e);})),i=this.workObjects.next();return this.runningPromise=i.value,o(i.value)})),this.mainPromise=this.mainDeferred.promise,this.mainPromise.then((()=>{n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< [${this.name}] mainPromise resolved`);})).catch((e=>{n.LOG_DETAIL&&n.log(n.LOG_DETAIL,`AsyncJobQueue::workObjectsGenerator <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< [${this.name}] mainPromise REJECTED with reason: ${e}`);})).finally((()=>{this._cleanUp();}))),this.mainPromise};};e.UI.AsyncJobQueue=e.UI.AsyncJobQueue||s;return e.QueryString=e.QueryString||new function(){this.stringify=function(e,t){let n="",o=!1;for(let i in e)e.hasOwnProperty(i)&&(o&&(n+="&"),o=!0,n+=t?`${i}=${e[i]}`:encodeURIComponent(`${i}=${e[i]}`));return n},this.parse=function(e){let t={};if(!e)return t;let n=decodeURIComponent(e).split("&");for(let e=n.length-1;e>=0;e--){let o=n[e].split("=");t[o[0]]=o[1];}return t},this.set=function(e,t,n){"object"==typeof e&&(n=t,t=e,e=null);let o=this.get(e);Object.assign(o,t);let i=this.getBaseUrl(e),r=this.stringify(o,n);return r?i+"?"+r:i},this.get=function(e){let t=e||window.location.href;if(-1===t.indexOf("?"))return {};let n=t.split("?").splice(1).join("?");return this.parse(decodeURI(n))},this.getBaseUrl=function(e){return e?e.split("?")[0]:window.location.href.split("?")[0]};},EXTENSIONS=EXTENSIONS||{QueryString:e.QueryString,Promises:{Promise:e.UI.Promise,promise:e.UI.promise,deferred:e.UI.deferred,promisify:e.UI.promisify,serializeProcessing:e.UI.serializeProcessing,AsyncJobQueue:s}},EXTENSIONS};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.



	$MOD$ BaseService.js 4.3.1-210203-21-1b8704b6-1a04bc7d
	*/
	let _logger,_serviceEventObjMap={},_eventDelegatesMap=new Map,_serviceReadyEventRegisteringDone=!1,_registrationId=0;const getServiceClass=({Wincor:e,ext:r,jQuery:t,LogProvider:g,GatewayProvider:i})=>class{whenReady=null;gateway=null;responseMap=null;requestMap=null;eventMap=null;serviceProvider=null;logger=null;NAME="";REQUEST=null;RESPONSE=null;EVENT=null;SERVICE_EVENTS=null;ERROR_TYPE={REQUEST:"REQUEST",RESPONSE:"RESPONSE",EVENT:"EVENT",OTHER:"OTHER"};DISPOSAL_TRIGGER_DEACTIVATE="DEACTIVATE";DISPOSAL_TRIGGER_UNLOAD="UNLOAD";DISPOSAL_TRIGGER_ONETIME="ONETIME";DISPOSAL_TRIGGER_SHUTDOWN="SHUTDOWN";REQUEST_RESPONSE_OK="0";REQUEST_RESPONSE_ERROR="2";EventRegistration=function(){this.registrationId=-1,this.callback=null,this.persistent=!1,this.trigger=null;};constructor(r,{ServiceProvider:t}){this.NAME=r,this.responseMap=new Map,this.requestMap=new Map,this.eventMap=new Map,this.serviceProvider=t,_logger=g,this.logger=_logger;let s="";_logger.LOG_SRVC_INOUT&&arguments&&arguments.length>2&&(s=`, ${Object.values(arguments).slice(2)}`),_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> BaseService::BaseService[${this.NAME}](${r}, ServiceProvider: ${t}${s})`),this.REQUEST=Object.assign({},e.UI.Gateway.prototype.REQUEST),this.RESPONSE=Object.assign({},e.UI.Gateway.prototype.RESPONSE),this.EVENT=Object.assign({},e.UI.Gateway.prototype.EVENT),this.gateway=i.getGateway(),this.whenReady=null,_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< BaseService::BaseService[${this.NAME}]`);}translateResponse(e){return e}onResponse(e){try{if(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> Service::onResponse('${JSON.stringify(e)}')`),this.responseMap.has(e.callbackIdx)){let r=this.responseMap.get(e.callbackIdx);r?r(this.translateResponse(e)):_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. delegate for index '${e.callbackIdx}' is null.`),this.responseMap.delete(e.callbackIdx);}else _logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. No callback found for index '${e.callbackIdx}'.`);_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"< Service::onResponse");}catch(e){this.serviceProvider.propagateError(this.NAME,this.ERROR_TYPE.RESPONSE,e);}}onRequest(e){try{if(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> Service::onRequest('${JSON.stringify(e)}')`),this.requestMap.has(e.methodName)){let r=this.requestMap.get(e.methodName);r?r(e):_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. delegate for method '${e.methodName}' is null.`);}else _logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. No callback found for method '${e.methodName}'.`);_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"< Service::onRequest");}catch(e){this.serviceProvider.propagateError(this.NAME,this.ERROR_TYPE.REQUEST,e);}}onEvent(e){try{if(_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> Service::onEvent('${JSON.stringify(e)}')`),this.eventMap.has(e.eventName)){let r=this.eventMap.get(e.eventName);r?r(e):_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. delegate for event '${e.eventName}' is null.`);}else _logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. No callback found for event '${e.eventName}'.`);_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"< Service::onEvent");}catch(e){this.serviceProvider.propagateError(this.NAME,this.ERROR_TYPE.EVENT,e);}}sendRequest(e,r){return e=this.gateway.sendRequest(e,(e=>this.responseMap.set(e,r)))}sendResponse(e,r){return e=this.gateway.sendResponse(e,r)}sendEvent(e){return e=this.gateway.sendEvent(e)}installServiceEvents(){this.SERVICE_EVENTS&&"object"==typeof this.SERVICE_EVENTS&&(Object.keys(this.SERVICE_EVENTS).forEach((e=>{if(e in _serviceEventObjMap)throw `${this.NAME} tried to install SERVICE_EVENT ${e}, but this is already installed by ${_serviceEventObjMap[e]}`;_serviceEventObjMap[e]=this.NAME;})),_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. Service::installServiceEvents[${this.NAME}]${JSON.stringify(this.SERVICE_EVENTS)} succeeded.`));}registerForServiceEvent(e,r,t){_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> Service::registerForServiceEvent[${this.NAME}](${e}, ..., persistent: ${t})`);try{if(e in _serviceEventObjMap&&r&&"function"==typeof r){let g=new this.EventRegistration;_registrationId++,g.registrationId=_registrationId;let i=typeof t;return "string"===i?t!==this.DISPOSAL_TRIGGER_DEACTIVATE&&t!==this.DISPOSAL_TRIGGER_UNLOAD&&t!==this.DISPOSAL_TRIGGER_ONETIME&&t!==this.DISPOSAL_TRIGGER_SHUTDOWN||(g.trigger=t,t=!1):("boolean"===i||(t=!1),g.trigger=this.DISPOSAL_TRIGGER_DEACTIVATE),g.callback=r,g.persistent=t,_eventDelegatesMap.has(e)?_eventDelegatesMap.get(e).push(g):_eventDelegatesMap.set(e,[g]),_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< Service::registerForServiceEvent[${this.NAME}] returns regId: ${_registrationId}`),_registrationId}}catch(e){this.serviceProvider.propagateError(this.NAME,this.ERROR_TYPE.OTHER,e);}return _logger.log(_logger.LOG_ANALYSE,`. Service::registerForServiceEvent[${this.NAME}] WARNING: Could not register for serviceEventName=${e}`),-1}deregisterFromServiceEvent(e){let r,t;_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"> Service::deregisterFromServiceEvents()");let g=void 0===e;for(let[i,s]of _eventDelegatesMap){for(r=s.length-1;r>=0;r--)if(t=s[r],(g||t.registrationId===e)&&(t.callback=null,s.splice(r,1),!g))return _logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"< Service::deregisterFromServiceEvents returns: true"),!0;0===s.length&&_eventDelegatesMap.delete(i);}return _logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"< Service::deregisterFromServiceEvents returns: "+(g?"all registrations cleared":"false")),!!g}deregisterServiceEvents(e,r){_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> Service::deregisterServiceEvents[${this.NAME}](trigger: ${e}, eventName: ${r})`);let t,g,i,s=0;for(let[_,o]of _eventDelegatesMap){for(t=o.length-1;t>=0;t--)g="string"!=typeof r||r===_,i=o[t],!i.persistent&&i.trigger===e&&g&&(_logger.LOG_DETAIL&&_logger.log(_logger.LOG_DETAIL,`. removing ${_} regId <${i.registrationId}> of ${this.NAME}`),i.callback=null,o.splice(t,1),0===o.length&&_eventDelegatesMap.delete(_));o&&(s+=o.length);}_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< Service::deregisterServiceEvents[${this.NAME}] delegatesLeft: ${s}`);}hasReceivers(e){return _eventDelegatesMap.has(e)&&_eventDelegatesMap.get(e).length>0}fireServiceEvent(e,r){_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`> Service::fireServiceEvent[${this.NAME}](serviceEventName: ${e}, data: ${JSON.stringify(r)})`);let t,g=!1;if(_serviceEventObjMap[e]===this.NAME){if(_eventDelegatesMap.has(e)){let i=_eventDelegatesMap.get(e);for(t=i.length-1;t>=0;t--)if("function"==typeof i[t].callback){_logger.LOG_SRVC_DATA&&_logger.log(_logger.LOG_SRVC_DATA,`. Service::fireServiceEvent calling regId <${i[t].registrationId}>`);try{let e=!!i[t].callback(r);g=g||e;}catch(e){return this.serviceProvider.propagateError(this.NAME,this.ERROR_TYPE.OTHER,e),!1}}this.deregisterServiceEvents(this.DISPOSAL_TRIGGER_ONETIME,e);}}else _logger.error(`Error! Not allowed! ${this.NAME} tried to send foreign SERVICE_EVENT ${e}!`);return _logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,`< Service::fireServiceEvent[${this.NAME}]`),g}retrieveJSONData(e){let g=this.serviceProvider.baseUrl;return r.Promises.promise(((r,i)=>t.getJSON(g+(-1===e.lastIndexOf(".json")?e+".json":e),r).fail((e=>i(e)))))}onServicesReady(){_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"> Service::onServicesReady()"),this.ready=!0;const e=this,t=this.serviceProvider.ViewService;return !_serviceReadyEventRegisteringDone&&t&&(this.registerForServiceEvent(t.SERVICE_EVENTS.VIEW_CLOSING,(function(){e.deregisterServiceEvents(e.DISPOSAL_TRIGGER_DEACTIVATE);}),!0),this.registerForServiceEvent(t.SERVICE_EVENTS.VIEW_BEFORE_CHANGE,(function(){e.deregisterServiceEvents(e.DISPOSAL_TRIGGER_UNLOAD),e.deregisterServiceEvents(e.DISPOSAL_TRIGGER_ONETIME);}),!0),this.registerForServiceEvent(t.SERVICE_EVENTS.SHUTDOWN,(function(){e.deregisterServiceEvents(e.DISPOSAL_TRIGGER_DEACTIVATE),e.deregisterServiceEvents(e.DISPOSAL_TRIGGER_UNLOAD),e.deregisterServiceEvents(e.DISPOSAL_TRIGGER_ONETIME),e.deregisterServiceEvents(e.DISPOSAL_TRIGGER_SHUTDOWN);}),!0),_serviceReadyEventRegisteringDone=!0),_logger.LOG_SRVC_INOUT&&_logger.log(_logger.LOG_SRVC_INOUT,"< Service::onServicesReady"),r.Promises.Promise.resolve()}onSetup(e){return r.Promises.Promise.resolve()}onError(e,r,t){}setGateway(e){this.gateway=e;}convertToBoolean(e){return !!e&&(!0===e||(isNaN(e)?"true"===e.toLowerCase():parseInt(e)>0))}};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany
	 
	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.
	 
	 
	 $MOD$ wn.UI.Gateway.js 4.3.1-210203-21-1b8704b6-1a04bc7d
	 
	*/
	const getGateway=({Wincor:e,LogProvider:t}={})=>{const a=t;let o="request",s="response",n="event",i={service:""},r=[],g=[],c=new Map,y=function(e){this.name=e,this.socket=null,this.ready=!1,this.requestIdx=0,this.established=()=>{},this.connectionFailed=()=>{},this.dataTobeSend=[];};return e.UI.Gateway=class{gatewayName="";GATEWAY_TYPE=null;REQUEST=Object.assign(Object.assign({},i),{type:o,methodName:"",callbackIdx:-1});RESPONSE=Object.assign(Object.assign({},i),{type:s,methodName:"",result:""});EVENT=Object.assign(Object.assign({},i),{type:n,eventName:""});constructor(){a.LOG_DETAIL&&a.log(a.LOG_DETAIL,`> Gateway::Gateway for ${this.gatewayName}`),a.LOG_DETAIL&&a.log(a.LOG_DETAIL,"< Gateway::Gateway");}getBridge(e=this.gatewayName){return c.get(e)}getSocket(e=this.gatewayName){let t=c.get(e);return t?t.socket:null}setBridge(e){let t=null;return "object"==typeof e&&e.url&&(c.has(this.gatewayName)?(t=c.get(this.gatewayName),t&&(1===t.socket.readyState&&t.socket.close&&t.socket.close(4e3,{socket:"setBridge: Has been closed due to a new WebSocket opening."}),t.socket=e)):(t=new y,t.name=this.gatewayName,t.socket=e,c.set(this.gatewayName,t))),t}destroyBridge(e){this.destroyConnection(e);}destroyConnection(e){throw "not supported"}establishConnection(){throw "not supported"}pretranslateIncomingMessage(e){return e}posttranslateOutgoingMessage(e){return e}sendRequest(e,t){if(this.isConnected()){let a=this.getBridge();a.requestIdx++,e.callbackIdx=a.requestIdx,e.type=o,t&&t(e.callbackIdx),this.send(e);}else a.error("Wincor.UI.Gateway(sendRequest): no connection!");return e}sendResponse(e,t){return this.isConnected()?(e.result=t,e.type=s,this.send(e)):a.error("Wincor.UI.Gateway(sendResponse): no connection!"),e}sendEvent(e){return e.type=n,this.send(e),e}send(e){let t=this.posttranslateOutgoingMessage(e),a=this.getBridge();a&&a.socket.send(t);}isConnected(){let e=this.getBridge();return e&&e.ready}setConnectionReady(e){let t=this.getBridge();t&&(t.ready=e);}setName(e){this.gatewayName=e;}getName(){return this.gatewayName}registerConnectionReadyHandler(e){a.LOG_DETAIL&&a.log(a.LOG_DETAIL,"> Gateway::registerConnectionReadyHandler(...)"),r.push(e),a.LOG_DETAIL&&a.log(a.LOG_DETAIL,"< Gateway::registerConnectionReadyHandler");}registerConnectionLostHandler(e){a.LOG_DETAIL&&a.log(a.LOG_DETAIL,"> Gateway::registerConnectionLostHandler(...)"),g.push(e),a.LOG_DETAIL&&a.log(a.LOG_DETAIL,"< Gateway::registerConnectionLostHandler");}fireConnectionReady(){if(a.LOG_DETAIL&&a.log(a.LOG_DETAIL,`> Gateway::fireConnectionReady() for ${this.gatewayName}`),r&&this.gatewayName===this.GATEWAY_TYPE_WEBSOCKET)for(let e=0;e<r.length;e++)r[e].apply(this,[]);else a.LOG_DETAIL&&a.log(a.LOG_DETAIL,`. Gateway::fireConnectionReady not allowed for ${this.gatewayName}`);a.LOG_DETAIL&&a.log(a.LOG_DETAIL,"< Gateway::fireConnectionReady");}fireConnectionLost(){if(a.LOG_DETAIL&&a.log(a.LOG_DETAIL,`> Gateway::fireConnectionLost() for ${this.gatewayName}`),g&&this.gatewayName===this.GATEWAY_TYPE_WEBSOCKET)for(let e=0;e<g.length;e++)g[e].apply(this,[]);else a.LOG_DETAIL&&a.log(a.LOG_DETAIL,`. Gateway::fireConnectionLost not allowed for ${this.gatewayName}`);a.LOG_DETAIL&&a.log(a.LOG_DETAIL,"< Gateway::fireConnectionLost");}onMessage(t){try{if(this.gatewayName===this.GATEWAY_TYPE){let i=this.pretranslateIncomingMessage(t);if(e.UI.Service.Provider.hasService(i.service)){let t=e.UI.Service.Provider[i.service];if(null!==t)switch(i.type){case o:t.onRequest(i);break;case s:t.onResponse(i);break;case n:t.onEvent(i);break;default:a.error(`Wincor.UI.Gateway::onMessage for ${this.gatewayName} - unknown type '${i.type}'.`);}else a.error(`Wincor.UI.Gateway::onMessage for ${this.gatewayName} - delegate for service '${i.service}' is null.`);}else i.hasOwnProperty("providerMethod")?(console.log(`Wincor.UI.Gateway::onMessage - ServiceProvider message = ${JSON.stringify(i)}`),e.UI.Service.Provider[i.providerMethod](i)):console.log(`Wincor.UI.Gateway::onMessage for ${this.gatewayName} - No delegate found for service '${i.service}'.`);}}catch(e){setTimeout((()=>{try{a.error(`Exception in Gateway::onMessage for ${this.gatewayName}! \n ${e.message}`);}finally{throw e}}),1);}}onOpen(e){a.LOG_DETAIL&&a.log(a.LOG_DETAIL,`> Gateway::onOpen for ${this.gatewayName}: ('${JSON.stringify(e)}')`),this.setConnectionReady(!0),setTimeout(this.fireConnectionReady.bind(this),1),a.LOG_DETAIL&&a.log(a.LOG_DETAIL,"< Gateway::onOpen");}onClose(e){a.LOG_DETAIL&&a.log(a.LOG_DETAIL,`> Gateway::onClose for ${this.gatewayName}: ('${JSON.stringify(e)}')`),this.setConnectionReady(!1),setTimeout(this.fireConnectionLost.bind(this),1),a.LOG_DETAIL&&a.log(a.LOG_DETAIL,"< Gateway::onClose");}onError(e){a.error(`Wincor.UI.Gateway::onError for ${this.gatewayName} - bridge error: '${JSON.stringify(e)}'.`),this.setConnectionReady(!1),setTimeout(this.fireConnectionLost.bind(this),1);}}};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany
	 
	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.
	 
	 
	 $MOD$ wn.UI.Gateway.WebSocket.js 4.3.1-210127-21-34ae33df-1a04bc7d
	 
	*/
	const getWebSocket=({Wincor:e,ext:t,Gateway:s}={})=>{const o="ws://127.0.0.1:",n="WEBSOCKET";return e.UI.Gateway.Websocket=class extends s{socketPort=8091;socketURL=o;socketURI=null;onMessageReceiver=null;establishConnectionPromise=null;hsID=0;constructor(e="WEBSOCKET",s){super(),this.GATEWAY_TYPE_WEBSOCKET=n,this.establishConnectionPromise=t.Promises.Promise.resolve(),this.setName(e),this.socketPort=8091,this.socketURL=o,this.socketURI=null,this.onMessageReceiver=s;}establishConnection(){return this.establishConnectionPromise.isPending()||(this.establishConnectionPromise=new t.Promises.Promise(((e,t)=>{try{let s=this.socketURI||this.socketURL+this.socketPort,o=new WebSocket(s),n=this.setBridge(o);n.established=e,n.connectionFailed=t,o.onopen=this.onOpen.bind(this),o.onclose=this.onClose.bind(this),o.onerror=this.onError.bind(this),this.onMessageReceiver&&"function"==typeof this.onMessageReceiver?o.onmessage=this.onMessageReceiver:o.onmessage=this.onMessage.bind(this);}catch(e){t(e);}}))),this.establishConnectionPromise}destroyConnection(t){let s=this.getSocket();s&&s.close?(s.onclose=()=>{this.onClose(`destroyConnection ${this.gatewayName} invoked`),e.UI.Gateway.GatewayProvider.setGateway(null),t&&t();},this.isSocketOk()?s.close():e.UI.Gateway.GatewayProvider.setGateway(null)):e.UI.Gateway.GatewayProvider.setGateway(null);}async onOpen(e){console.log("WebSocket has been opened"),super.onOpen(e);let t=this.getBridge();if(t){if(t.established(),0!==this.hsID){let e={};e.hsID=this.hsID;let s=this.posttranslateOutgoingMessage(e);t.socket.send(s),this.hsID=0;}t.dataTobeSend.length&&(t.dataTobeSend.forEach((e=>{let s=this.posttranslateOutgoingMessage(e);t.socket.send(s);})),t.dataTobeSend.length=0);}}onClose(e){console.log("WebSocket has been closed"),super.onClose(e);}onError(e){let t=this.getBridge();t&&t.connectionFailed(),super.onError(e);}isSocketOk(){let e=this.getBridge();return e&&e.socket.readyState===e.socket.OPEN}async checkConnection(){let e=this.isSocketOk();if(!e)try{await this.establishConnection(),e=this.isSocketOk();}catch(e){console.error(e);}return e}pretranslateIncomingMessage(e){return JSON.parse(e.data)}posttranslateOutgoingMessage(e){return JSON.stringify(e)}send(e){if(this.isSocketOk())super.send(e);else {let t=this.getBridge();t&&t.dataTobeSend.push(e),setTimeout((()=>{this.checkConnection().then((()=>{console.log("WebSocket::send Connection reestablished after connection lost");})).catch((e=>{console.error(e);}));}),5e3);}}}};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany
	 
	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.
	 
	 
	 $MOD$ wn.UI.GatewayProvider.js 4.3.1-210127-21-34ae33df-1a04bc7d
	 
	*/
	let PROVIDER;const getGatewayProvider=({Wincor:e,LogProvider:t,Websocket:a}={})=>{const r=t;let o=null,y=!1,G=[],_=[];const O="WEBSOCKET";return PROVIDER=PROVIDER||new class{GATEWAY_TYPE_WEBSOCKET=O;constructor(){this.GATEWAY_TYPE_WEBSOCKET=O;}getGateway(){return o}setGateway(e){null!==o&&null===e&&o.setConnectionReady(!1),o=e;}createGateway(e){r.LOG_SRVC_INOUT&&r.log(r.LOG_SRVC_INOUT,`> GatewayProvider::createGateway() options: ${e?e.toString():"undefined"}`);let t=localStorage.getItem("gatewayType"),y=localStorage.getItem("gatewayWebSocketPort"),G=localStorage.getItem("gatewayHsID");t||(t=O);const _=Object.assign({type:t},e||{});return o||(r.LOG_SRVC_DATA&&r.log(r.LOG_SRVC_DATA,`. gateway-type=${_.type}`),_.type===O?(o=new a,o.GATEWAY_TYPE=t,y&&(r.LOG_SRVC_DATA&&r.log(r.LOG_SRVC_DATA,`Setting webSocketPort to ${y}`),o.socketPort=y),G&&(o.hsID=G)):r.error(`Wincor.UI.Gateway.GatewayProvider(createGateway): unknown _gateway type '${_.type}'.`)),o?(o.registerConnectionReadyHandler(this.onReady.bind(this)),o.registerConnectionLostHandler(this.onClose.bind(this))):(r.error(`The gateway of type=${_.type} could not been created!`),o=null),r.LOG_SRVC_INOUT&&r.log(r.LOG_SRVC_INOUT,"< GatewayProvider::createGateway"),o}destroyGateway(e){r.LOG_SRVC_INOUT&&r.log(r.LOG_SRVC_INOUT,"> GatewayProvider::destroyGateway()"),o?o.destroyBridge(e):(o=null,e&&e()),r.LOG_SRVC_INOUT&&r.log(r.LOG_SRVC_INOUT,"< GatewayProvider::destroyGateway");}isConnected(){return y}fireReady(){for(r.LOG_SRVC_INOUT&&r.log(r.LOG_SRVC_INOUT,"> GatewayProvider::fireReady()");_[0];)_.shift().apply(e.UI.Gateway.GatewayProvider,[]);r.LOG_SRVC_INOUT&&r.log(r.LOG_SRVC_INOUT,"< GatewayProvider::fireReady");}fireClose(){for(r.LOG_SRVC_INOUT&&r.log(r.LOG_SRVC_INOUT,"> GatewayProvider::fireClose()");G[0];)G.shift().apply(e.UI.Gateway.GatewayProvider,[]);r.LOG_SRVC_INOUT&&r.log(r.LOG_SRVC_INOUT,"< GatewayProvider::fireClose");}registerReadyHandler(e){r.LOG_SRVC_INOUT&&r.log(r.LOG_SRVC_INOUT,"> GatewayProvider::registerReadyHandler()"),_.push(e),r.LOG_SRVC_INOUT&&r.log(r.LOG_SRVC_INOUT,"< GatewayProvider::registerReadyHandler");}registerClosedHandler(e){r.LOG_SRVC_INOUT&&r.log(r.LOG_SRVC_INOUT,"> GatewayProvider::registerClosedHandler()"),G.push(e),r.LOG_SRVC_INOUT&&r.log(r.LOG_SRVC_INOUT,"< GatewayProvider::registerClosedHandler");}onReady(){y=!0,this.fireReady();}onClose(){y=!1,this.fireClose();}},e.UI.Gateway.GatewayProvider=e.UI.Gateway.GatewayProvider||PROVIDER,PROVIDER};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	$MOD$ wn.UI.Service.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/
	const jQuery$1=window.jQuery,ext=getExtensions({Wincor: Wincor$2,LogProvider}),Gateway=getGateway({Wincor: Wincor$2,LogProvider}),Websocket=getWebSocket({Wincor: Wincor$2,ext,Gateway}),GatewayProvider=getGatewayProvider({Wincor: Wincor$2,LogProvider,Websocket}),BaseService=getServiceClass({Wincor: Wincor$2,ext,jQuery: jQuery$1,LogProvider,GatewayProvider});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.



	$MOD$ PTService.js 4.3.1-210203-21-1b8704b6-1a04bc7d
	*/
	let crossCallId=0;const getServiceClass$1=({Wincor:e,ext:s,LogProvider:t,BaseService:a})=>class extends a{NAME="PTService";FRM_EVENT=null;FRM_RESOLVE_REQUEST=null;METHOD_FRM_RESOLVE="FrmResolve";FRM_ASYNC_RESOLVE_REQUEST=null;METHOD_FRM_ASYNC_RESOLVE="FrmAsyncResolve";EVENT_ON_FRM_EVENT="OnFrmEvent";META_TYPE={CHAR_ANSI:"CHAR_ANSI",PARLIST_ANSI:"PARLIST_ANSI",CHAR_UTF8:"CHAR_UTF8",PARLIST_UTF8:"PARLIST_UTF8",WCHAR:"WCHAR",HEX:"HEX",SHORT:"SHORT",USHORT:"USHORT",LONG:"LONG",ULONG:"ULONG",NULL:"NULL"};constructor(e,s){super(e,s),this.NAME=e,this.logger.log(this.logger.LOG_SRVC_INOUT,"> PTService::PTService"),this.FRM_RESOLVE_REQUEST=Object.assign(Object.assign({},this.REQUEST),{service:this.NAME,methodName:this.METHOD_FRM_RESOLVE,FWName:"",FWFuncID:0,param1:"",meta1:[],param2:"",meta2:[],param3:"",meta3:[],param4:"",meta4:["NULL",0],param5:"",meta5:["NULL",0],paramUL:0,RC:-1}),this.FRM_ASYNC_RESOLVE_REQUEST=Object.assign(Object.assign({},this.REQUEST),{service:this.NAME,methodName:this.METHOD_FRM_ASYNC_RESOLVE,FWName:"",FWFuncID:0,param1:"",meta1:[],param2:"",meta2:[],param3:"",meta3:[],param4:"",meta4:["NULL",0],param5:"",meta5:["NULL",0],paramUL:0,RC:-1}),this.logger.log(this.logger.LOG_SRVC_INOUT,"< PTService::PTService");}FrmResolve(e,s){return this.sendRequest(Object.assign(Object.assign({},this.FRM_RESOLVE_REQUEST),e||{}),s)}crossCall(t,a,r=[],l=this.NAME,i={}){crossCallId++;const o=this.serviceProvider.getInstanceName(),c={service:l,type:"request",methodName:a,args:r,caller:o,acknowledgeId:"",extraData:Object.assign({},i),result:""};c.acknowledgeId=`${o}->${t}.${this.NAME}::${a}_crossCall_${crossCallId}`;const g=Object.assign({},e.UI.Gateway.prototype.REQUEST);return g.service=this.NAME,g.methodName="FrmResolve",g.FWName=t,g.FWFuncID=60,g.param1=JSON.stringify(c),g.meta1=[this.META_TYPE.CHAR_UTF8,-1],g.param2="",g.meta2=["NULL",0],g.param3="",g.meta3=["NULL",0],g.param4="",g.meta4=["NULL",0],g.param5="",g.meta5=["NULL",0],g.paramUL=0,g.RC=-1,this.logger.LOG_SRVC_INOUT&&this.logger.log(this.logger.LOG_SRVC_INOUT,`> PTService::crossCall(${JSON.stringify(g,null," ")})\nccid=${c.acknowledgeId}`),s.Promises.promise(((e,s)=>{this.eventMap.set(c.acknowledgeId,(s=>{this.logger.LOG_SRVC_INOUT&&this.logger.log(this.logger.LOG_SRVC_INOUT,`< PTService::crossCall returns ${JSON.stringify(s,null," ")}\nccid=${c.acknowledgeId}`),e(s.result),this.eventMap.delete(c.acknowledgeId);})),this.FrmResolve(g,(e=>{0!==e.RC&&(this.eventMap.delete(c.acknowledgeId),s(e.RC),this.logger.LOG_ERROR&&this.logger.log(this.logger.LOG_ERROR,`< PTService::crossCall returned ${e.RC})\nccid=${c.acknowledgeId}`));}));}))}crossCallAcknowledge(t,a,r,l,i={}){return s.Promises.promise(((s,o)=>{const c={service:a,type:"event",eventName:r,result:l,extraData:Object.assign({},i)},g=Object.assign({},e.UI.Gateway.prototype.REQUEST);g.service=this.NAME,g.methodName="FrmResolve",g.FWName=t,g.FWFuncID=60,g.param1=JSON.stringify(c),g.meta1=[this.META_TYPE.CHAR_UTF8,-1],g.param2="",g.meta2=["NULL",0],g.param3="",g.meta3=["NULL",0],g.param4="",g.meta4=["NULL",0],g.param5="",g.meta5=["NULL",0],g.paramUL=0,g.RC=-1,this.logger.LOG_SRVC_INOUT&&this.logger.log(this.logger.LOG_SRVC_INOUT,`> PTService::crossCallAcknowledge(${JSON.stringify(g,null," ")})\nccid=${r}`),this.FrmResolve(g,(e=>{this.logger.LOG_SRVC_INOUT&&this.logger.log(this.logger.LOG_SRVC_INOUT,`< PTService::crossCallAcknowledge returns ${JSON.stringify(e,null," ")}\nccid=${r}`),0===e.RC?s():o(`PTService::crossCallAcknowledge failed with RC!=0 -> ${JSON.stringify(e)}`);}));}))}crossCallEvent(t,a,r,l){crossCallId++;const i=this.serviceProvider.getInstanceName(),o={service:a,type:"event",eventName:r,caller:i,acknowledgeId:"",eventData:l};o.acknowledgeId=`${i}->${t}.${this.NAME}:${r}_crossCallEvent_${crossCallId}`;const c=Object.assign({},e.UI.Gateway.prototype.REQUEST);return c.service=this.NAME,c.methodName="FrmResolve",c.FWName=t,c.FWFuncID=60,c.param1=JSON.stringify(o),c.meta1=[this.META_TYPE.CHAR_UTF8,-1],c.param2="",c.meta2=["NULL",0],c.param3="",c.meta3=["NULL",0],c.param4="",c.meta4=["NULL",0],c.param5="",c.meta5=["NULL",0],c.paramUL=0,c.RC=-1,this.logger.LOG_SRVC_INOUT&&this.logger.log(this.logger.LOG_SRVC_INOUT,`> PTService::crossCallEvent(${JSON.stringify(c,null," ")})\nccid=${o.acknowledgeId}`),s.Promises.promise(((e,s)=>{this.eventMap.set(o.acknowledgeId,(s=>{this.logger.LOG_SRVC_INOUT&&this.logger.log(this.logger.LOG_SRVC_INOUT,`< PTService::crossCallEvent returns ${JSON.stringify(s,null," ")}\nccid=${o.acknowledgeId}`),e(s.result),this.eventMap.delete(o.acknowledgeId);})),this.FrmResolve(c,(e=>{0!==e.RC&&(this.logger.LOG_ERROR&&this.logger.log(this.logger.LOG_ERROR,`< PTService::crossCallEvent returned ${e.RC})\nccid=${o.acknowledgeId}`),s(`PTService::crossCallEvent failed with RC!=0 -> ${JSON.stringify(e)}`));}));}))}};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	$MOD$ wn.UI.Service.PTService.js 4.3.1-210127-21-34ae33df-1a04bc7d
	 */

	const ext$1 = getExtensions({Wincor: Wincor$2, LogProvider});

	// inject dependencies and export
	/**
	 * @function
	 * @param {Wincor} Wincor
	 * @param {Class} Class
	 * @param {ext} ext
	 * @param {LogProvider} LogProvider
	 * @param {BaseService} BaseService
	 */
	const PTService = getServiceClass$1({ Wincor: Wincor$2, ext: ext$1, LogProvider, BaseService });

	const jQuery$2 = window.jQuery;
	const ext$2 = getExtensions({ Wincor: Wincor$2, LogProvider });
	const Gateway$1 = getGateway({ Wincor: Wincor$2, LogProvider });
	const Websocket$1 = getWebSocket({ Wincor: Wincor$2, ext: ext$2, Gateway: Gateway$1 });
	const GatewayProvider$1 = getGatewayProvider({ Wincor: Wincor$2, LogProvider, Websocket: Websocket$1 });

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.BaseProxy.js 4.3.1-210127-21-34ae33df-1a04bc7d

	*/
	let _logger$1;const _shadowServices={crossCallTargets:{}},getBaseProxy=({Wincor:e,ext:r,jQuery:o,LogProvider:t}={})=>e.UI.Service.BaseProxy=class{constructor(){_logger$1=t,this.serviceName="";}ensureInterface(t,g){const l="SERVICE_EVENTS";let s=!1;const n=this;_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`> BaseProxy::ensureInterface() for ${g.NAME}`),Object.keys(t).forEach((function(e){0===e.indexOf("Expand")&&Array.isArray(t[e].attributes)&&(_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::ensureInterface decompressing interface definition for : ${JSON.stringify(t[e])}`),t[e].attributes.forEach((function(r){_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::ensureInterface extending interface: ${r}`);let g={};Object.prototype.hasOwnProperty.call(t,r)&&(g=t[r]),t[r]={},o.extend(!0,t[r],t[e],g),delete t[r].attributes;})),delete t[e]);})),t=Object.assign({},t),_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::ensureInterface interface: ${JSON.stringify(t,null," ")}`);const a="shadowValue",c=[];Object.keys(t).forEach((function(o){const l=t[o].type;_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::ensureInterface() checking svcImpl for ${l} '${o}'`);let _=Object.prototype.hasOwnProperty.call(t[o],a);if(_||typeof g[o]===l||(_logger$1.error(`BaseProxy::ensureInterface() for ${g.NAME} failed on type inspection of ${o}`),s=!0),!s){let O;const E="function";if(O=l===E?!Object.prototype.hasOwnProperty.call(t[o],"traceable")||!0===t[o].traceable:Object.prototype.hasOwnProperty.call(t[o],"traceable")&&!0===t[o].traceable,_){const e=t[o].shadowValue;typeof e===l?(_shadowServices[n.NAME]||(_shadowServices[n.NAME]={}),_shadowServices[n.NAME][o]=e):l===E&&"string"==typeof e?(_shadowServices[n.NAME]||(_shadowServices[n.NAME]={}),_shadowServices[n.NAME][o]=new Function(e)):_=!1;}if(_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::ensureInterface() proxy tracing is ${O?"enabled":"disabled"} for ${l} '${o}'`),l===E||n[o]&&!_){let r;if(l===E&&(!n[o]||_)){if(Object.prototype.hasOwnProperty.call(t[o],"callbackArgumentIndex")){_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::ensureInterface() generating promisificated proxy function for '${o}'`);const l=t[o].callbackArgumentIndex,s="number"==typeof l&&l>=0;r=function(...r){const t=s?l:r.length;return e.UI.promise((function(l,s){try{const s=r[t];s&&"function"!=typeof s&&e.UI.Service.Provider.propagateError("BaseProxy","ServiceCall - callback index is wrong either in interface or call...");const a=function(...e){const r=e.length<2?e[0]:e;O&&_logger$1.LOG_DETAIL&&_logger$1.log(_logger$1.LOG_DETAIL,`* ${n.NAME}::${o} returns ${JSON.stringify(r)}`),l(r),s&&s.apply(null,e);};r.length>t?r.splice(t,1,a):r[t]=a,O&&_logger$1.LOG_DETAIL&&_logger$1.log(_logger$1.LOG_DETAIL,`> ${n.NAME}::${o}()`),_?_shadowServices[n.NAME][o].apply(g,r):g[o].apply(g,r),O&&_logger$1.LOG_DETAIL&&_logger$1.log(_logger$1.LOG_DETAIL,`< ${n.NAME}::${o}`);}catch(t){_logger$1.error(`promisified function failed ${t}\n originalFunc: ${g[o]}\n\n called with:\n ${r.map((e=>"argument"+r.indexOf(e)+": "+e+"\n"))}`),e.UI.Service.Provider.propagateError("BaseProxy","ServiceCall",t),s();}}))},!1!==t[o].internal&&Object.defineProperty(n,o,{get:()=>r,set:e=>{_logger$1.error(`Tried to reassign ${n.NAME}::${o} ${_?"shadowed ":""}function to ${e}`);}});}else _logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::ensureInterface() generating standard proxy function for '${o}'`),r=function(...r){try{let e;return O&&_logger$1.LOG_DETAIL&&_logger$1.log(_logger$1.LOG_DETAIL,`> ${n.NAME}::${o}()`),e=_?_shadowServices[n.NAME][o].apply(g,r):g[o].apply(g,r),O&&_logger$1.LOG_DETAIL&&_logger$1.log(_logger$1.LOG_DETAIL,`< ${n.NAME}::${o} returns ${e}`),e}catch(t){return _logger$1.error(`standard proxy function caught exception ${t} \noriginalFunc: ${g[o]}\n\n called with:\n ${r.map((e=>"argument"+r.indexOf(e)+": "+e+"\n"))}`),e.UI.Service.Provider.propagateError("BaseProxy","ServiceCall",t),Promise.reject()}},!1!==t[o].internal&&Object.defineProperty(n,o,{get:()=>r,set:e=>{_logger$1.error(`Tried to reassign ${n.NAME}::${o} ${_?"shadowed ":""}function to ${e}`);}});(t[o].external||t[o].crossCall)&&(void 0===g.requestMap&&(g.requestMap=new Map),_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::ensureInterface() exposing proxy function for '${o}'`),g.requestMap.set(o,r));}}else {_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::ensureInterface() generating attribute accessor (get) for${_?" shadowed value":""} '${o}'`);const E={get:function(){const e=_?_shadowServices[n.NAME][o]:g[o];return O&&_logger$1.LOG_DETAIL&&_logger$1.log(_logger$1.LOG_DETAIL,`* ${n.NAME}::${o} accessor get returns${_?" shadowed value":""} '${e}'`),e}};if(!_&&t[o].serviceEvent){const l=o.toUpperCase()+"_CHANGED";g.SERVICE_EVENTS||(g.SERVICE_EVENTS={},t.SERVICE_EVENTS||(t.SERVICE_EVENTS={type:"object",crossCall:!!t[o].crossCall})),g.SERVICE_EVENTS[l]=l,t[o].crossCall||c.push(l),n.SERVICE_EVENTS||(n.SERVICE_EVENTS={}),n.SERVICE_EVENTS[l]=l;const s=g;_logger$1.LOG_SRVC_DATA&&_logger$1.log(_logger$1.LOG_SRVC_DATA,`* BaseProxy::ensureInterface installing service attribute trap for ${s.NAME}::${o}`);let _=s[o];!Object.prototype.hasOwnProperty.call(t[o],a)&&t[o].serviceEvent&&(s.SERVICE_EVENTS||(s.SERVICE_EVENTS={}),s.SERVICE_EVENTS[l]=l),Object.defineProperty(s,o,{get:()=>_,set:t=>{_=t;let g=r.Promises.Promise.resolve();i.forEach((r=>{_logger$1.LOG_SRVC_DATA&&_logger$1.log(_logger$1.LOG_SRVC_DATA,`* BaseProxy::ensureInterface crossCallAttribute ${s.NAME}::${o} changed sending to ${r}...`),g=d.add(function(r,t){return s.crossCallEvent.call(s,r,s.NAME,`${e.UI.Service.Provider.getInstanceName()}:${s.NAME}:${o}`,t).then((e=>{_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`* BaseProxy::ensureInterface received ack with rc=${e}`);})).catch((e=>{_logger$1.LOG_ERROR&&_logger$1.log(_logger$1.LOG_ERROR,`* BaseProxy::ensureInterface sending crossCallEvent rejected with ${e}`);}))}.bind(n,r,t),++I);})),g.then(function(e,r){e in this.SERVICE_EVENTS&&this.fireServiceEvent(e,r);}.bind(s,l,t)).catch((e=>{_logger$1.LOG_ERROR&&_logger$1.log(_logger$1.LOG_ERROR,`* BaseProxy::ensureInterface sending crossCallEvent rejected with ${e}`);}));}});}const S=!Object.prototype.hasOwnProperty.call(t[o],"writable")||t[o].writable;S?_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::ensureInterface() generating attribute accessor (set) for${_?" shadowed value":""} '${o}'`):_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::ensureInterface() generating failure accessor (set) for${_?" shadowed value":""} '${o}'`),E.set=function(e){O&&S&&_logger$1.LOG_DETAIL&&_logger$1.log(_logger$1.LOG_DETAIL,`* ${n.NAME}::${o} accessor set${_?" shadowed value":""} '${e}'`),S&&typeof e===t[o].type?_?_shadowServices[n.NAME][o]=e:g[o]=e:typeof e!==t[o].type?_logger$1.error(`Tried to set ${n.NAME}::${o} ${_?"shadowed ":""}property to wrong type '${typeof e}' with value: <${e}>! Type should be ${t[o].type}`):_logger$1.error(`Tried to set ${n.NAME}::${o} ${_?"shadowed ":""}readonly property to <${e}>`);},Object.defineProperty(n,o,E),"object"===l&&t[o].keys&&t[o].keys.forEach((function(e){_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::ensureInterface() checking for key '${e}' of object '${o}'`),null!==g[o]&&void 0!==g[o][e]||(_logger$1.error(`BaseProxy::ensureInterface() for ${g.NAME} failed due non existence of ${o}.${e}`),s=!0);}));}}}));const _=g,i=new Set([]);let O;function E(){if(_logger$1.log(_logger$1.LOG_INOUT,"> BaseProxy::readInstalledInstances"),O)return _logger$1.log(_logger$1.LOG_INOUT,`< BaseProxy::readInstalledInstances already done - returning ${JSON.stringify(O)}`),r.Promises.Promise.resolve(O);if(!e.applicationMode)return r.Promises.Promise.reject("remote instances not supported in designmode");const o=e.UI.Service.Provider.getInstanceName(),t=[],g=[];return ["GUIAPP","GUIDM","GUIVIDEO","GUISOP"].filter((e=>e!==o)).forEach((r=>{const o=e.UI.Service.Provider.ConfigService.getConfiguration(`CCOPEN\\GUI\\${r}`,["Browser"]).then((e=>{_logger$1.log(_logger$1.LOG_INOUT,`. BaseProxy::readInstalledInstances checking 'Browser' config of ${r} -> ${JSON.stringify(e)}`),e.Browser&&t.push(r);}));g.push(o);})),r.Promises.Promise.all(g).then((()=>(O=t,_logger$1.log(_logger$1.LOG_INOUT,`< BaseProxy::readInstalledInstances returns ${JSON.stringify(t)}`),t))).catch((e=>{_logger$1.error(`BaseProxy::readInstalledInstances failed: ${e}`);}))}_.requestMap&&_.requestMap.set("getRemoteInterface",(function(e){let r;if(_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,"> BaseProxy::getRemoteInterface()"),e.caller&&e.acknowledgeId){_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`> BaseProxy::createRemoteInterfaceObject() of ${_.NAME}`);try{r={};const e="DISPOSAL_TRIGGER_";if(t.SERVICE_EVENTS){r.SERVICE_EVENTS=o.extend({},t.SERVICE_EVENTS);let e={};Object.keys(_.SERVICE_EVENTS).forEach((r=>{c.includes(r)||(e[r]=_.SERVICE_EVENTS[r]);})),r.SERVICE_EVENTS.value=e;}Object.keys(t).forEach((g=>{if(g.startsWith(e)&&(r[g]=o.extend({},t[g]),r[g].value=_[g]),t[g].crossCall){if(g===l)return void _logger$1.error("createRemoteInterfaceObject SERVICE_EVENTS are generated automatically, crossCall marker not necessary");if(r[g]=o.extend({},t[g]),"function"!==t[g].type){if(r.SERVICE_EVENTS&&t[g].serviceEvent){const e=g.toUpperCase()+"_CHANGED";r.SERVICE_EVENTS.value[e]=e;}r[g].value=_[g];}else if(0===i.size){_logger$1.LOG_SRVC_DATA&&_logger$1.log(_logger$1.LOG_SRVC_DATA,`* BaseProxy::createRemoteInterfaceObject installing function trap for ${_.NAME}::${g}`);const e=_.requestMap.get(g);_.requestMap.set(g,(function(r){let o;if(r.caller&&r.acknowledgeId){try{o=e.apply(_,r.args);}catch(e){}o&&o.then?o.then((e=>{_.crossCallAcknowledge.call(_,r.caller,r.service,r.acknowledgeId,e).catch((e=>{_logger$1.LOG_ERROR&&_logger$1.log(_logger$1.LOG_ERROR,`* BaseProxy::ensureInterface sending crossCallAcknowledge rejected with ${e}`);}));})):_.crossCallAcknowledge.call(_,r.caller,r.service,r.acknowledgeId,o).catch((e=>{_logger$1.LOG_ERROR&&_logger$1.log(_logger$1.LOG_ERROR,`* BaseProxy::ensureInterface sending crossCallAcknowledge rejected with ${e}`);}));}else t[g].external&&e.call(_,r);}));}else _logger$1.LOG_SRVC_DATA&&_logger$1.log(_logger$1.LOG_SRVC_DATA,`* BaseProxy::createRemoteInterfaceObject already installed function trap for ${_.NAME}::${g}`);}}));}catch(r){_logger$1.error(`BaseProxy::createRemoteInterfaceObject getRemoteInterface event ${JSON.stringify(e)} exception ${r.message}!`);}i.add(e.caller),_.crossCallAcknowledge.call(_,e.caller,e.service,e.acknowledgeId,r).catch((e=>{_logger$1.error(e);})),_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`< BaseProxy::createRemoteInterfaceObject sends:\n${JSON.stringify(r,null," ")}`);}else _logger$1.error("BaseProxy::getRemoteInterface functions are not externally usable!");_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,"< BaseProxy::getRemoteInterface");})),_.requestMap&&_.requestMap.set("registerForServiceEvent",(function(r){let o;if(_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`> BaseProxy::registerForServiceEvent() requested by ${r.caller}`),r.caller&&r.acknowledgeId){try{const t=r.args[0],g=r.args[2];o=_.registerForServiceEvent.call(_,t,(g=>{let l=`${e.UI.Service.Provider.getInstanceName()}_${r.service}_${t}_EventReg_${o}`;_.crossCallEvent(r.caller,r.service,l,g).catch((e=>{_logger$1.LOG_ERROR&&_logger$1.log(_logger$1.LOG_ERROR,`* BaseProxy::ensureInterface sending crossCallEvent rejected with ${e}`);}));}),g);}catch(e){_logger$1.error(`BaseProxy::ensureInterface registerForServiceEvent event ${JSON.stringify(r)} exception ${e.message}!`);}_.crossCallAcknowledge.call(_,r.caller,r.service,r.acknowledgeId,o).catch((e=>{_logger$1.LOG_ERROR&&_logger$1.log(_logger$1.LOG_ERROR,`* BaseProxy::ensureInterface sending crossCallAcknowledge rejected with ${e}`);})).finally((()=>{_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`< BaseProxy::registerForServiceEvent done for ${r.caller}`);}));}else _logger$1.error("BaseProxy::ensureInterface service event functions are not externally usable!");})),_.requestMap&&_.requestMap.set("deregisterFromServiceEvent",(function(e){let r;if(_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`> BaseProxy::deregisterFromServiceEvent() requested by ${e.caller}`),e.caller&&e.acknowledgeId){try{r=_.deregisterFromServiceEvent.apply(_,e.args);}catch(r){_logger$1.LOG_ERROR&&_logger$1.log(_logger$1.LOG_ERROR,`* BaseProxy::ensureInterface deregisterFromServiceEvent ${JSON.stringify(e)} exception ${r.message}!`);}_.crossCallAcknowledge.call(_,e.caller,e.service,e.acknowledgeId,r).catch((e=>{_logger$1.LOG_ERROR&&_logger$1.log(_logger$1.LOG_ERROR,`* BaseProxy::ensureInterface deregisterFromServiceEvent cca exception ${e}!`);})).finally((()=>{_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`< BaseProxy::registerForServiceEvent done for ${e.caller}`);}));}else _logger$1.error("BaseProxy::ensureInterface service event functions are not externally usable!");}));let S=e=>r.Promises.promise(((o,t)=>(_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`> BaseProxy getRemoteInstance(${e})`),this.hasRemoteInstance(e).then((()=>{const g=_shadowServices.crossCallTargets[e];if(!g||!g[_.NAME]){_logger$1.LOG_SRVC_DATA&&_logger$1.log(_logger$1.LOG_SRVC_DATA,". BaseProxy getRemoteInstance remoteInterface currently unknown - requesting");const g=()=>(_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,"> BaseProxy getRemoteInterface()"),_logger$1.LOG_SRVC_DATA&&_logger$1.log(_logger$1.LOG_SRVC_DATA,`. getRemoteInterface from ${e}'s ${_.NAME}`),_.crossCall.call(_,e,"getRemoteInterface",[],_.NAME).catch((o=>(_logger$1.LOG_WARNING&&_logger$1.log(_logger$1.LOG_WARNING,`* BaseProxy::getRemoteInterface from ${e}'s ${_.NAME} returned ${o} - retrying in 2000ms`),r.Promises.Promise.resolve().delay(2e3).then(g)))));return g().then((t=>{_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,"* BaseProxy received remoteInterface..."),_shadowServices.crossCallTargets[e]||(_shadowServices.crossCallTargets[e]={}),_shadowServices.crossCallTargets[e][_.NAME]||(_shadowServices.crossCallTargets[e][_.NAME]={}),Object.keys(t).forEach((function(r){let o=!0===t[r].traceable,g=!1!==t[r].traceable;if("function"!==t[r].type){let g;_logger$1.LOG_SRVC_DATA&&_logger$1.log(_logger$1.LOG_SRVC_DATA,`. BaseProxy getRemoteInstance() creating remote instance '${e}' crossCallAttribute for attr '${r}' current value: '${t[r].value}'`),g=_shadowServices.crossCallTargets[e][_.NAME][r]=t[r].value;const l=`${e}:${_.NAME}:${r}`;_logger$1.LOG_SRVC_DATA&&_logger$1.log(_logger$1.LOG_SRVC_DATA,`* BaseProxy getRemoteInstance installing event-handler for crossCallAttributeChanged eventId: ${l}`),_.eventMap.set(l,(e=>{_logger$1.LOG_SRVC_DATA&&_logger$1.log(_logger$1.LOG_SRVC_DATA,`* BaseProxy getRemoteInstance crossCallAttributeChanged received: ${JSON.stringify(e,null," ")}`),g=e.eventData,_.crossCallAcknowledge(e.caller,e.service,e.acknowledgeId,0);})),_logger$1.LOG_SRVC_DATA&&_logger$1.log(_logger$1.LOG_SRVC_DATA,`. BaseProxy getRemoteInstance() creating attribute accessor (get) '${e}' for '${r}' current value: '${t[r].value}'`);const s=t[r].crossCallWritable,a=t[r].type,c={get:()=>(o&&_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`* ${e}::${n.NAME}::${r} accessor get returns ${g}`),g),set:o=>{s?typeof o===a?g=o:_logger$1.error(`Tried to assign wrong type ${typeof o} val:'${o}' to remote instance attribute ${e}::${r}`):_logger$1.error(`Tried to set non writable remote instance attribute ${e}::${r} to '${o}'`);}};Object.defineProperty(_shadowServices.crossCallTargets[e][_.NAME],r,c);}else _logger$1.LOG_SRVC_DATA&&_logger$1.log(_logger$1.LOG_SRVC_DATA,`. BaseProxy getRemoteInstance() creating remote instance '${e}' crossCall for function '${r}'`),_shadowServices.crossCallTargets[e][_.NAME][r]=(...o)=>(g&&_logger$1.LOG_DETAIL&&_logger$1.log(_logger$1.LOG_DETAIL,`> ${e}::${n.NAME}::${r}()`),_.crossCall.apply(_,[e,r,o,_.NAME]).then((o=>(g&&_logger$1.LOG_DETAIL&&_logger$1.log(_logger$1.LOG_DETAIL,`< ${e}::${n.NAME}::${r} returns ${JSON.stringify(o)}`),o))));})),function(e){_shadowServices.crossCallTargets[e]||(_shadowServices.crossCallTargets[e]={}),_shadowServices.crossCallTargets[e][_.NAME]||(_shadowServices.crossCallTargets[e][_.NAME]={}),_shadowServices.crossCallTargets[e][_.NAME].registerForServiceEvent&&_logger$1.error("BaseProxy::ensureInterface service event functions registerForServiceEvent are installed automatically when using cross calls. Please remove explicit configuration from interface!");let o=[];_shadowServices.crossCallTargets[e][_.NAME].registerForServiceEvent=(r,t,g)=>(_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`> ${e}::${_.NAME}::registerForServiceEvent(${r}, fx, ${g})`),_.crossCall.apply(_,[e,"registerForServiceEvent",[r,null,g],_.NAME]).then((g=>{const l=`${e}_${_.NAME}_${r}_EventReg_${g}`;return o.push(l),_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`* ${e}::${_.NAME}::registerForServiceEvent ${r} -> registered events '${JSON.stringify(o,null," ")}'`),_.eventMap.set(l,(r=>{_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`* ${e}::${_.NAME} received ccEvent:\n${JSON.stringify(r,null," ")}`),t(r.eventData),_.crossCallAcknowledge(r.caller,r.service,r.acknowledgeId,0);})),_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`< ${e}::${_.NAME}::registerForServiceEvent(${r} returned regId ${g}`),g})).catch((e=>{_logger$1.error(e);}))),_shadowServices.crossCallTargets[e][_.NAME].deregisterFromServiceEvent&&_logger$1.error("BaseProxy::ensureInterface service event functions deregisterFromServiceEvent are installed automatically when using cross calls. Please remove explicit configuration from interface!"),_shadowServices.crossCallTargets[e][_.NAME].deregisterFromServiceEvent=t=>{_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`> ${e}::${_.NAME}::deregisterFromServiceEvent(${t})`);let g=[],l=t;if("number"==typeof l){const r=`${e}_${_.NAME}_.*_EventReg_${l}`;_.eventMap.forEach(((e,o)=>{o.search(r)>-1&&g.push(o);})),l=[l];}else g=o,l=g.map((e=>parseInt(e.split("_").pop()))),o=[];return _logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`. ${e}::${_.NAME}::deregisterFromServiceEvent found in eventMap ${JSON.stringify(g,null," ")}`),_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`. ${e}::${_.NAME}::deregisterFromServiceEvent regIds ${JSON.stringify(l,null," ")}`),g.forEach((e=>{_.eventMap.delete(e);})),r.Promises.Promise.all(l.map((r=>_.crossCall.apply(_,[e,"deregisterFromServiceEvent",[r],_.NAME]).then((o=>(_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`< ${e}::${_.NAME}::deregisterFromServiceEvent(${r} returned success ${o}`),o)))))).then((e=>e.reduce(((e,r)=>e&&r),!0))).catch((e=>{_logger$1.error(e);}))};}(e),o(new Proxy(_shadowServices.crossCallTargets[e][_.NAME],{}));})).catch((e=>{_logger$1.error(e),t(e);}))}o(new Proxy(_shadowServices.crossCallTargets[e][_.NAME],{}));})).catch((e=>{_logger$1.LOG_SRVC_DATA&&_logger$1.log(_logger$1.LOG_SRVC_DATA,`. BaseProxy getRemoteInstance hasRemoteInstance rejected - reason: ${e}`),t(e);}))))).then((e=>(_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`< BaseProxy getRemoteInstance returns ${JSON.stringify(e,((e,r)=>"function"==typeof r?"function":r)," ")}`),e))),d=(new r.Promises.AsyncJobQueue).setConcurrency(!0),I=0;return this.getRemoteInstance=o=>{if(_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`> BaseProxy::getRemoteInstance(${o})`),d.name.startsWith("AsyncJobQueue")&&e.UI.Service.Provider.getInstanceName()){let r=`${e.UI.Service.Provider.getInstanceName()}:${_.NAME}`;_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`. BaseProxy::getRemoteInstance renaming jobQueue ${d.name}->${r}`),d.setName(r);}return r.Promises.promise(((e,r)=>{const t=this;d.add(function(o){return S.call(t,o).then((e=>(_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,"< BaseProxy::getRemoteInstance"),e))).then(e).catch((e=>{r(e);}))}.bind(t,o),++I);}))},this.hasRemoteInstance=e=>r.Promises.promise(((r,o)=>{_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,"> BaseProxy::hasRemoteInstance"),E().then((t=>{_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`< BaseProxy::hasRemoteInstance ${t.includes(e)}`),t.includes(e)?r(!0):o(`No remote instance of ${e} available!`);})).catch(o);})),this.getRemoteInstanceNames=()=>E(),_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`< BaseProxy::ensureInterface returns ${!s}`),!s}getServiceName(){return this.serviceName}initializeService(t,g,l){return _logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,"> BaseProxy::initializeService"),r.Promises.promise(((s,n)=>{const a=t;_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::initializeService loading service ${a.service}`),_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::initializeService loaded service ${a.service}`);let c=l;"function"==typeof this.setService&&this.setService(c),this.serviceName=c.NAME,c.NAME&&e.UI.Service[c.NAME]&&(e.UI.Service[c.NAME]=void 0);const _=a.interface||{};o.extend(!0,_,g.interface);const i=a.entryPoints;let O=!1;i&&Array.isArray(i)&&i.forEach(function(e){_logger$1.LOG_ANALYSE&&_logger$1.log(_logger$1.LOG_ANALYSE,`. BaseProxy::initializeService checking requestMap + eventMap for entrypoint '${e}'...`),c.requestMap.has(e)||c.eventMap.has(e)||(_logger$1.error(`BaseProxy::initializeService '${c.NAME}' missing entrypoint '${e}' in requestMap or eventMap!`),O=!0);}.bind(this));try{const e=r.Promises.deferred(`${c.NAME}_whenReady`);c.whenReady=e.promise,!O&&this.ensureInterface(_,c)?(c.installServiceEvents&&c.installServiceEvents(),s(e)):n();}catch(e){_logger$1.error(`BaseProxy::initializeService: ${e}`),n(e);}_logger$1.LOG_SRVC_INOUT&&_logger$1.log(_logger$1.LOG_SRVC_INOUT,`< BaseProxy::initializeService returns ${JSON.stringify(a)}`);}))}};

	var wn_UI_Service_BaseProxy = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': getBaseProxy
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.



	$MOD$ ServiceProvider.js 4.3.1-210212-21-06af7f4f-1a04bc7d
	 */
	const deferredInitObjects={};let PROVIDER$1;const ServiceProvider=({Wincor:e,jQuery:r,ext:o,LogProvider:i,BaseProxyClass:t,GatewayProvider:s}={})=>{let c,a;return PROVIDER$1=PROVIDER$1||new class{NAME="ServiceProvider";serviceNames=[];services={};baseUrl="";constructor(){this.LogProvider=i,this.serviceNames.push("LogProvider"),this.proxyConfiguration={},this.masterConfig=[];}addService(r){console.log(`adding proxy ${r.NAME}`);const i=this.proxyConfiguration[r.NAME].__NAME;let t,s={},n=this.masterConfig.find((e=>e.serviceName===i));n&&(t=n.bundle.ServiceClass,s=n.bundle.ConstructorDependencies||{});const c=new t(i,Object.assign({ServiceProvider:this},s));return r.initializeService(this.proxyConfiguration[r.NAME],this.proxyConfiguration.General,c).then((i=>(r.initializeService=void 0,r.ensureInterface=void 0,o.Promises.promise(((o,t)=>{const s=r.getServiceName();this.services[r.NAME]=s,this.serviceNames.push(s);const n=new Proxy(r,{get:(o,i)=>i in o?o[i]:(e.UI.Diagnostics.LogProvider.error(`Access to unknown property '${i}' of ServiceProxy<${r.getServiceName()}>!`),null),has:(e,r)=>r in e}),c={get:()=>n,set:o=>{let i;try{i=JSON.stringify(o);}catch(e){i=o;}e.UI.Diagnostics.LogProvider.error(`Someone tried to reassign proxy reference to '${i}' on ServiceProxy<${r.getServiceName()}>!`);}};if(this[s]=n,Object.defineProperty(this,s,c),deferredInitObjects[s]=i,"LogService"===s){const i=e.UI.Diagnostics.LogProvider;r.readCurrentTraceBitStates().then((()=>{i.setLogger(r),i.log(i.LOG_ANALYSE,"* DUMPING ConsoleLogger queue"),e.UI.Diagnostics.ConsoleLogger.messageStack.forEach((e=>{e[0]?i.error(e[1]):i.log(i.LOG_ANALYSE,e[1]);})),o();}));}else o();})))))}importedFiles=[];async createMasterConfig(e){try{return console.log("> ServiceProvider::createMasterConfig()"),e.forEach((e=>{try{if(e.ServiceClass.prototype.NAME){const r=`ServiceProvider::createMasterConfig: Old ServiceBundle found: ${JSON.stringify(e,null," ")} prototype class creation not supported, use native classes instead.`;throw console.error(r),r}const o=e.ServiceInterface;if(!o){const r=`ServiceProvider::createMasterConfig: Inconsistent ServiceBundle: ${JSON.stringify(e,null," ")}`;throw console.error(r),r}let i=Object.keys(o)[0],t=i.replace("Proxy","Service");o[i].__NAME=t,r.extend(!0,this.proxyConfiguration,o),this.masterConfig.push({serviceName:t,interfaceName:i,bundle:e}),console.log(`ServiceProvider::createMasterConfig: added proxy config of '${t}'`);}catch(e){throw console.error(e),e}})),r.extend(!0,this.proxyConfiguration,a),console.log("< ServiceProvider::createMasterConfig"),this.masterConfig}catch(e){throw console.error(e),e}}setBaseUrl(e){console.log(`> ServiceProvider::setBaseUrl(${e})`),this.baseUrl=e,console.log("< ServiceProvider::setBaseUrl");}async loadServices(r,i){let c;a=i;const l={},v={},d=["General","Version","Import","Comment"];try{await this.createMasterConfig(r),c=Object.keys(this.proxyConfiguration).filter((e=>{let r=!0;return d.forEach((function(o){e.substr(0,o.length)===o&&(r=!1);})),r})).map((e=>{let r;return this.proxyConfiguration[e].proxy?(r=this.proxyConfiguration[e].proxy,l[r]=e):(r=e,this.proxyConfiguration[e].proxy=t),r})),console.log("finished loading proxy configuration..."),console.log("proxies: "+c);const i=c.indexOf("LogProxy");i>=0&&(c.splice(i,1),c.splice(0,0,"LogProxy")),console.log("sorted proxies: "+c),await o.Promises.serializeProcessing(c,(e=>{const r=e;return console.log("loading '"+e+"'..."),o.Promises.promise(((i,s)=>{o.Promises.Promise.resolve(this.proxyConfiguration[e].proxy).then((o=>{console.log(`...finished loading '${e}'`);try{let e;e=new class extends t{NAME=r},this.addService(e).then(i);}catch(r){console.log(`loadServices failed (${e}): ${r}`),o||console.log("parameter arg is undefined"),s();}}),(()=>{console.error(`could not find ${e}`),s();}));}))})),e.UI.Service.BaseService&&(e.UI.Service.BaseService=void 0),e.UI.Service.PTService&&(e.UI.Service.PTService=void 0),e.UI.Service.BaseProxy&&(e.UI.Service.BaseProxy=void 0);const n=Object.assign(Object.assign({},e.UI.Gateway.prototype.EVENT),{service:"ViewService",eventName:"BrowserReady"}),a=[];for(const[e,r]of Object.entries(deferredInitObjects))console.log(`${e}: ${r.id}`),a.push(r.promise);const g=s.getGateway();g&&g.sendEvent(n),console.log("loadServices successful"),v.init=o.Promises.Promise.all(a);}catch(e){throw e}return v}async setup(r){this.LogProvider.log(this.LogProvider.LOG_SRVC_INOUT,`> ServiceProvider::onSetup(${JSON.stringify(r)})`);const i=this.serviceNames.map((e=>{if(this[e].onSetup){this.LogProvider.log(this.LogProvider.LOG_DETAIL,`. calling onSetup of service: ${e})`);let o=this[e].onSetup.call(this[e],r);return o&&"function"!=typeof o.then&&(this.LogProvider.error(`Implementation error! Service <${e}::onSetup(...) implemented but not returning promise!>`),o=!0),o}return !0})),t=[];try{try{let e=-1;await Promise.race([o.Promises.Promise.all(i),new Promise(((r,o)=>{e=setTimeout(o,15e3);})).catch((e=>{throw e}))]).then((()=>{clearTimeout(e);})),console.log("ServiceProvider: onSetup callbacks completed");}catch(e){throw `onSetup promise failed ${e}`}c=r.instanceName;let n=this.serviceNames.map((e=>this[e].onServicesReady?(this.LogProvider.log(this.LogProvider.LOG_DETAIL,`. calling onServicesReady of service: ${e})`),this[e].onServicesReady.call(this[e]).then((()=>{this.LogProvider.log(this.LogProvider.LOG_DETAIL,`. onServicesReady of service: ${e} resolved... resolving whenReady promise`),t.push(e),deferredInitObjects[e].resolve();}))):(deferredInitObjects[e]&&(this.LogProvider.log(this.LogProvider.LOG_DETAIL,`. skip onServicesReady of service: ${e} ... resolving whenReady promise`),t.push(e),deferredInitObjects[e].resolve()),!0)));try{let e=-1;await Promise.race([o.Promises.Promise.all(n)],new Promise(((r,o)=>{e=setTimeout(o,15e3);})).then((()=>{clearTimeout(e);}))),console.log("ServiceProvider: onServiceReady callbacks completed");}catch(e){throw `onServicesReady promise failed ${e}`}const a=Object.assign(Object.assign({},e.UI.Gateway.prototype.EVENT),{service:"ViewService",eventName:"BrowserInitialized"}),l=s.getGateway();l&&l.sendEvent(a);}catch(r){let o=`failed setting up services! Unfinished: <${this.serviceNames.filter((e=>this[e].whenReady&&!t.includes(e)))}>\n${r} ${r.stack?r.stack:""}`;const i=Object.assign(Object.assign({},e.UI.Gateway.prototype.EVENT),{service:"ViewService",eventName:"BrowserFailed",eventData:o}),n=s.getGateway();throw n?n.sendEvent(i):console.error(o),o}}propagateError(e,r,o){let i="";const t=this,s=this.serviceNames.map((function(e){return t[e]}));if(o)i=`${o.message} + \n + ${o} ${o.stack?o.stack:""}`;else try{throw new Error("GeneratedStack")}catch(e){i=`${(o=e).message}\n${o.stack}\n`;}this.LogProvider.error(`ServiceProvider received exception ${r}  from '${e}': '${i}'`),s.forEach((function(i){if(Object.prototype.hasOwnProperty.call(i,"onError")&&"function"==typeof i.onError)try{i.onError(e,r,o);}catch(e){t.LogProvider.error("Exception in ServiceProvider::propagateError when calling '"+i+"'.onError! \n"+e.message);}}));}hasService(e){return -1!==this.serviceNames.indexOf(e)}getServiceNames(){return this.serviceNames.filter((function(){return !0}))}getInstanceName(){return c}},e.UI.Service.Provider=e.UI.Service.Provider||PROVIDER$1,PROVIDER$1};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.



	$MOD$ wn.UI.Service.Provider.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/
	var ServiceProvider$1 = ServiceProvider({Wincor: Wincor$2,jQuery: jQuery$2,ext: ext$2,LogProvider,BaseProxyClass:getBaseProxy({Wincor: Wincor$2,ext: ext$2,jQuery: jQuery$2,LogProvider}),GatewayProvider: GatewayProvider$1});

	function __variableDynamicImportRuntime0__(path) {
	   switch (path) {
	     case './proxies/wn.UI.Service.BaseProxy.js': return Promise.resolve().then(function () { return wn_UI_Service_BaseProxy; });
	     case './proxies/wn.UI.Service.Interfaces.js': return Promise.resolve().then(function () { return wn_UI_Service_Interfaces; });
	     case './proxies/wn.UI.Service.InterfacesDesignMode.js': return Promise.resolve().then(function () { return wn_UI_Service_InterfacesDesignMode; });
	     case './proxies/wn.UI.Service.InterfacesDesignModeDirectMarketing.js': return Promise.resolve().then(function () { return wn_UI_Service_InterfacesDesignModeDirectMarketing; });
	     case './proxies/wn.UI.Service.InterfacesDirectMarketing.js': return Promise.resolve().then(function () { return wn_UI_Service_InterfacesDirectMarketing; });
	     case './proxies/wn.UI.Service.InterfacesHeadless.js': return Promise.resolve().then(function () { return wn_UI_Service_InterfacesHeadless; });
	     default: return Promise.reject(new Error("Unknown variable dynamic import: " + path));
	   }
	 }
	let _initiator=null,_isControlPanelOption=!1,_onIframeContentLoaded=null,_gatewayReadyAlreadyProcessed=!1,_logger$2=LogProvider;function loadViewSet(e,t){ServiceProvider$1.ViewService.loadViewSet(e,t);}function eppKeyEvent(e){ServiceProvider$1.EppService.onEvent({methodName:"KeyPressed",key:e});}function startAda(){localStorage.setItem("adaStarted",!0),ServiceProvider$1.DataService.setValues("PROP_ADA_STATUS_VALUE","ON",null),ServiceProvider$1.AdaService.adaCommand({command:"START"}),ServiceProvider$1.AdaService.adaCommand({command:"FIRSTSTART"});}function startExtendedDesignMode(e){const t={20:"LOG_ANALYSE",21:"LOG_EXCEPTION",22:"LOG_ERROR",23:"LOG_WARNING",24:"LOG_INFO",25:"LOG_INOUT",26:"LOG_DATA",27:"LOG_SRVC_INOUT",28:"LOG_SRVC_DATA",29:"LOG_DETAIL"},a=(e,...a)=>{(a=0===a.length?[20,21,22,23,24,25,26,27,28,29]:a).forEach((a=>{"string"==typeof a?Object.values(t).includes(a)&&(LogProvider[a]=!!e&&parseInt(Object.keys(t).find((e=>t[e]===a)))):a in t&&(LogProvider[t[a]]=!!e&&a);}));};window.traceOff=(...e)=>{a(!1,...e);},window.traceOn=(...e)=>{a(!0,...e);},"true"===localStorage.getItem("activateTraceOn")?window.traceOn():window.traceOff(),e&&localStorage.setItem("currentViewSet",e),_initiator&&_initiator();}function listenerRemoved(){}function getQueryStringValue(e){e=e.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]");let t=new RegExp("[\\?&]"+e+"=([^&#]*)").exec(location.search);return null===t?"":decodeURIComponent(t[1].replace(/\+/g," "))}function showStandardMenuForExtendedDesignMode(e,t){e.slideDown({duration:660,easing:"easeOutQuart",complete:function(){const e=jQuery$2("#extendedDesignModeMenu");e.show({duration:300,easing:"easeOutQuart",start:function(){e.css("display","flex");let t=localStorage.getItem("controlPanelOn");"true"===t?(_isControlPanelOption=!0,jQuery$2("#controlPanelCheckBox").attr("checked",t)):(_isControlPanelOption=!1,jQuery$2("#controlPanelCheckBox").removeAttr("checked"));let a=localStorage.getItem("keepViewKeyOn");"true"===a?jQuery$2("#keepViewKeyCheckBox").attr("checked",a):jQuery$2("#keepViewKeyCheckBox").removeAttr("checked");let o=localStorage.getItem("keepStyleTypeOn");"true"===o?jQuery$2("#keepStyleTypeCheckBox").attr("checked",o):jQuery$2("#keepStyleTypeCheckBox").removeAttr("checked");let r=localStorage.getItem("activateTimeoutsOn");"true"===r?jQuery$2("#activateTimeoutsCheckBox").attr("checked",r):jQuery$2("#activateTimeoutsCheckBox").removeAttr("checked");let n=localStorage.getItem("activateAdaOn");"true"===n?jQuery$2("#activateAdaCheckBox").attr("checked",n):jQuery$2("#activateAdaCheckBox").removeAttr("checked");},complete:function(){t.html("...Please select...");}});}});}function init(){const e=jQuery$2(".state"),t=["show","true","1","yes"],a=["hide","false","0","no"];let o=null;console.log("init..."),e.html("initializing...");const r=-1!==t.indexOf(getQueryStringValue("extendedDesignMode").toLowerCase()),n=window.Wincor.toolingEDM=!r&&-1!==t.indexOf(getQueryStringValue("toolingEDM").toLowerCase()),i=window.Wincor.applicationMode=!r&&!n;if(Wincor$2.UI.longStackTraces=t.includes(getQueryStringValue("longStackTraces").toLowerCase()),Promise.setScheduler&&Promise.config({longStackTraces:!!Wincor$2.UI.longStackTraces}),i?(window.Wincor.applicationRoot=getQueryStringValue("applicationRoot"),localStorage.setItem("activeFrameName","applicationContent"),jQuery$2("#applicationMode").css("display","block")):n&&(localStorage.clear(),localStorage.setItem("activeFrameName","toolingEDMContent"),jQuery$2("#toolingEDM").css("display","block")),i||n)!function(){const e="WEBSOCKET";let t,a;console.log("setting gatewayType to WEBSOCKET"),jQuery$2(".gwType").html("gateway type: WEBSOCKET"),localStorage.setItem("gatewayType",e),t=getQueryStringValue("gatewayWebSocketPort"),t&&(console.log(`setting gatewayWebSocketPort to ${t}`),localStorage.setItem("gatewayWebSocketPort",t)),a=getQueryStringValue("gatewayHsID"),a&&localStorage.setItem("gatewayHsID",a);let o=GatewayProvider$1.createGateway();if(o){o.registerConnectionReadyHandler(c);try{o.establishConnection().catch((e=>{console.error(`Connection failed for WEBSOCKET! ${e}`);}));}catch(e){console.error("Connection failed for WEBSOCKET!");}}}();else if(r){localStorage.setItem("activeFrameName","extendedDesignModeContent"),_initiator=c;const a=jQuery$2("#extendedDesignMode"),o=getQueryStringValue("viewSet"),r=getQueryStringValue("viewKey");r&&(localStorage.setItem(`currentViewKey_${document.location.href}`,r),localStorage.setItem("keepViewKeyOn","true")),"MercuryLight/"===localStorage.getItem("currentStyleType")&&jQuery$2("body").attr("data-style-type","MercuryLight"),getQueryStringValue("language")?localStorage.setItem("defaultLanguage",getQueryStringValue("language")):localStorage.removeItem("defaultLanguage"),"touch"===o||"softkey"===o?(a.css("display","block"),_isControlPanelOption=-1!==t.indexOf(getQueryStringValue("debugPanel").toLowerCase()),startExtendedDesignMode(o)):showStandardMenuForExtendedDesignMode(a,e);}else console.error("ERROR: no mode or unsupported mode is set");async function c(){if(n&&_gatewayReadyAlreadyProcessed)return;if(i||n?e.html("loading services..."):jQuery$2(".spinner").css("display","block"),n){const e=getQueryStringValue("viewSet"),t=getQueryStringValue("viewKey"),a=getQueryStringValue("styleType"),o=getQueryStringValue("animations");t&&(localStorage.setItem(`currentViewKey_${document.location.href}`,t),localStorage.setItem("keepViewKeyOn","true")),a&&(localStorage.setItem("currentStyleType",`${a}/`),jQuery$2("body").attr("data-style-type",a),localStorage.setItem("keepStyleTypeOn","true")),"touch"!==e&&"softkey"!==e||localStorage.setItem("currentViewSet",e),"false"===o?localStorage.setItem("animations","false"):localStorage.setItem("animations","true"),getQueryStringValue("language")?localStorage.setItem("defaultLanguage",getQueryStringValue("language")):localStorage.removeItem("defaultLanguage");}console.log("gatewayReady"),ServiceProvider$1.setBaseUrl("../../");let c=getQueryStringValue("interface");c?console.log(`interface set to: ${c}`):c="wn.UI.Service.Interfaces",c=c.replace(".json",""),c.toLowerCase().endsWith(".js")&&(c=c.slice(0,-3)),console.log(`coreResources.gatewayReady interfaceFile from queryString=${getQueryStringValue("interface")}, resulting interfaceFile=${c}`);try{let{ServiceBundle:l,InterfaceGeneral:s}=await __variableDynamicImportRuntime0__(`./proxies/${c}.js`);const{init:d}=await ServiceProvider$1.loadServices(l,s);if(r||n){const t=getQueryStringValue("instanceName")||"GUIAPP";await ServiceProvider$1.setup({instanceName:t.toUpperCase()}),await d,e.html("ready.");}r&&(jQuery$2("#extendedDesignModeMenu").fadeOut(),jQuery$2("H1,H2").fadeOut());const u=ServiceProvider$1.ConfigService,g=ServiceProvider$1.ViewService,S=ServiceProvider$1.DataService,m=ServiceProvider$1.ControlPanelService,y=ServiceProvider$1.AdaService,E=ServiceProvider$1.EppService,v=localStorage.getItem("activeFrameName");if(g.registerForServiceEvent(g.SERVICE_EVENTS.SHUTDOWN,(()=>{const e=jQuery$2(`#${v}`);e.after('<div id="hideCursorLayerInternal" style="position: absolute; top: 0; bottom: 0; right: 0; left: 0; cursor: none; z-index: 100;"></div>');let t=jQuery$2("body");t.removeClass("default/"===g.currentStyleType?"backgroundMercuryLight":"backgroundMercury"),t.addClass("MercuryLight/"===g.currentStyleType?"backgroundMercuryLight":"backgroundMercury"),e.contents()[0].removeEventListener("DOMContentLoaded",listenerRemoved,!1);}),!0),_onIframeContentLoaded=async e=>{if(e){const o=jQuery$2(e).contents()[0];let r=jQuery$2(o.getElementsByTagName("body")[0]);r.length?r.keydown((e=>{let t=e.target.nodeName.toLowerCase();8===e.which&&"input"!==t&&"textarea"!==t&&(e.preventDefault(),e.stopPropagation(),_logger$2.LOG_DETAIL&&_logger$2.log(_logger$2.LOG_DETAIL,"coreResources.loadServices backspace prevented from history navigation back."));})):_logger$2.error(`DOM operation backspace prevent from default failed: Could not get body of active frame=${v}`),u.whenReady.then((async()=>{const e=u.configuration.instanceName;await g.whenReady,g.registerForServiceEvent(g.SERVICE_EVENTS.VIEW_BEFORE_CHANGE,(()=>{jQuery$2(".instance").html(e);}),g.DISPOSAL_TRIGGER_ONETIME),u.getConfiguration(e,null,(r=>{let n;u.configuration[e]=r,n=void 0!==r.HideCursor?!0===r.HideCursor||t.includes(r.HideCursor)||!(!1===r.HideCursor||a.includes(r.HideCursor)):!!i;const c=jQuery$2(o.getElementsByTagName("body")[0]);c.length?(c.css("cursor",n?"none":"auto"),_logger$2.LOG_DETAIL&&_logger$2.log(_logger$2.LOG_DETAIL,`coreResources.loadServices hideCursor=${n}, cursor set to ${c.css("cursor")}`)):_logger$2.error("DOM operation hiding cursor failed: Could not get body of active frame="+v);}));}));try{o.getElementsByTagName("html")[0].addEventListener("contextmenu",(e=>{e.preventDefault();}));}catch(e){_logger$2.error(`Could not prevent from default context menu activation: ${e}`);}}setTimeout((()=>{jQuery$2("#hideCursorLayerInternal").remove();}),250);},_isControlPanelOption||i&&-1!==t.indexOf(getQueryStringValue("debugPanel").toLowerCase())){const e=650,t=1e3;try{const a={F1:{status:!1,claims:!1,cmdState:!1},F2:{status:!1,claims:!1,cmdState:!1},F3:{status:!1,claims:!1,cmdState:!1},F4:{status:!1,claims:!1,cmdState:!1},F5:{status:!1,claims:!1,cmdState:!1},F6:{status:!1,claims:!1,cmdState:!1},F7:{status:!1,claims:!1,cmdState:!1},F8:{status:!1,claims:!1,cmdState:!1},1:{status:!1,claims:!1,cmdState:!1},2:{status:!1,claims:!1,cmdState:!1},3:{status:!1,claims:!1,cmdState:!1},4:{status:!1,claims:!1,cmdState:!1},5:{status:!1,claims:!1,cmdState:!1},6:{status:!1,claims:!1,cmdState:!1},7:{status:!1,claims:!1,cmdState:!1},8:{status:!1,claims:!1,cmdState:!1},9:{status:!1,claims:!1,cmdState:!1},0:{status:!1,claims:!1,cmdState:!1},"*":{status:!1,claims:!1,cmdState:!1},CANCEL:{status:!1,claims:!1,cmdState:!1},CONFIRM:{status:!1,claims:!1,cmdState:!1},CLEAR:{status:!1,claims:!1,cmdState:!1},BACKSPACE:{status:!1,claims:!1,cmdState:!1},HELP:{status:!1,claims:!1,cmdState:!1}},r=knockout_mapping.fromJS(a),n=function(e){_logger$2.LOG_DETAIL&&_logger$2.log(_logger$2.LOG_DETAIL,"coreResources.updateViewModel"+JSON.stringify(e)),Object.keys(e).forEach((t=>{e[t]&&0===e[t].claims&&(e[t].claims=!1);})),knockout_mapping.fromJS(e,r);},i={0:"ENABLED",1:"PRESSED",2:"DISABLED",3:"HIDDEN",4:"DYNAMIC",5:"NONE"};window.addEventListener("unload",(()=>{o&&(jQuery$2(o).off("load"),speechSynthesis.speaking&&speechSynthesis.cancel(),o.close(),o=null,localStorage.setItem("controlPanelActive","false"));}),!1),o=window.open("assets/ControlPanel.html","",`width=${e},height=${t},menubar=0,toolbar=0,statusbar=0,location=0,directories=no,location=no,resizable=1,scrollbars=0`),o?(o.Wincor=Wincor$2,jQuery$2(o).on("load",(()=>{m.setControlPanel(o),o.resizeTo(e,t),localStorage.setItem("controlPanelActive","true"),knockout.applyBindings(r,o.document.getElementById("eppClaims"));}))):console.error("no control panel window available!");const c=localStorage.getItem("activateAdaOn"),l=new Audio;let s=-1;const d=function(e,t){if(Wincor$2.UI.Content){const o=Wincor$2.UI.Content.Commanding;let r={};Object.keys(a).forEach((function(e){let t=o.getByEppKey(e);t&&t[0]&&0!==t[0].viewState.value()?r[e]={cmdState:i[t[0].viewState.value()]}:r[e]={cmdState:!1};})),_logger$2.LOG_DETAIL&&_logger$2.log(_logger$2.LOG_DETAIL,"coreResources.serviceEventReceived"),n(e?jQuery$2.extend(!0,t,r):r);}},u=function(e){o&&"true"===c&&("BEREADY"===e?o.updateAdaState("enable"):o.updateAdaState("disable"));};E.registerForServiceEvent(E.SERVICE_EVENTS.CLAIM_STATUS_CHANGED,d.bind(null,!0),!0);let v={};g.registerForServiceEvent(g.SERVICE_EVENTS.VIEW_ACTIVATED,(function(){const e=Wincor$2.UI.Content.Commanding;e.registerForStateChange({context:v,listener:function(t){_logger$2.LOG_DETAIL&&_logger$2.log(_logger$2.LOG_DETAIL,`cmdStateChanged: ${JSON.stringify(t)}`);let o,r={};Object.keys(a).forEach((function(a){o=e.get(t.id),o.eppKeys&&-1!==o.eppKeys.indexOf(a)&&(0!==t.viewState?r[a]={cmdState:i[t.viewState]}:r[a]={cmdState:!1});})),n(r);}}),d(!1);}),!0),g.registerForServiceEvent(g.SERVICE_EVENTS.CONTENT_UPDATE,d.bind(null,!1),!0),g.registerForServiceEvent(g.SERVICE_EVENTS.POPUP_ACTIVATED,d.bind(null,!1),!0),g.registerForServiceEvent(g.SERVICE_EVENTS.POPUP_DEACTIVATED,d.bind(null,!1),!0),g.registerForServiceEvent(g.SERVICE_EVENTS.VIEW_CLOSING,d.bind(null,!1),!0),"true"===c&&(y.state=y.STATE_VALUES.BEREADY,g.registerForServiceEvent(g.SERVICE_EVENTS.NAVIGATE_SPA,(function(e){-1!==s&&(window.clearInterval(s),s=-1),"IdleLoopPresentation"===e.viewKey?(S.setValues("PROP_ADA_STATUS_VALUE","OFF",null),localStorage.setItem("adaStarted",!1),y.adaCommand({command:"STOP"}),y.adaCommand({command:"LASTSTOP"}),y.adaCommand({command:"IDLE"}),S.updateValues("PROP_UI_STYLE_TYPE_KEY","default/"),l.setAttribute("src","assets/Hello.wav"),s=window.setInterval((()=>l.play()),2e4)):(l.pause(),l.setAttribute("src",""),u(null),"OutOfServiceInfo"===e.viewKey?(l.setAttribute("src","assets/OutOfService.wav"),s=window.setInterval((()=>l.play()),2e4)):"true"===localStorage.getItem("adaStarted")&&"SPEAK"!==y.state&&y.adaCommand({command:"START"}));}),!0),y.registerForServiceEvent(y.SERVICE_EVENTS.FIRST_START,u,!0),y.registerForServiceEvent(y.SERVICE_EVENTS.LAST_STOP,u,!0),y.registerForServiceEvent(y.SERVICE_EVENTS.STATE_CHANGED,u,!0));}catch(e){console.error(`failed claim status stuff ${e.message}`);}}else localStorage.setItem("controlPanelActive","false");jQuery$2(".spinner").css("display","none");}catch(e){jQuery$2(".spinner").css("display","none"),console.error(`failed loading services! ${e}`);}_gatewayReadyAlreadyProcessed=!0;}}window.startAda=startAda,window.startExtendedDesignMode=startExtendedDesignMode,window.loadViewSet=loadViewSet,window.eppKeyEvent=eppKeyEvent,window.contentLoaded=function(e){_onIframeContentLoaded&&_onIframeContentLoaded(e);},window.controlPanelHandler=function(e){localStorage.setItem("controlPanelOn",e),_isControlPanelOption=e;},window.keepViewKeyHandler=function(e){localStorage.setItem("keepViewKeyOn",e);},window.keepStyleTypeHandler=function(e){localStorage.setItem("keepStyleTypeOn",e);},window.activateTimeoutsHandler=function(e){localStorage.setItem("activateTimeoutsOn",e);},window.activateAdaHandler=function(e){localStorage.setItem("activateAdaOn",e);},Wincor$2.UI.Content?.designMode||init();

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.



	$MOD$ wn.UI.Service.LogService.js 4.3.1-210204-21-e1b78e33-1a04bc7d
	 */

	/**
	 * @module
	 */
	const getServiceClass$2 = ({ BaseService }) => {
	    return class LogService extends BaseService {
	        //Hint: don't write a log in here!!!

	        /**
	         * "LogService" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "LogService";

	        /**
	         * The type of this logger. Used by the service-provider.
	         * @const
	         * @type {string}
	         */
	        TYPE = "TRACELOG";

	        /**
	         * The trace level "trace"
	         * @const
	         * @type {String}
	         */
	        METHOD_LOG = "trace";

	        /**
	         * The trace level "error"
	         * @const
	         * @type {String}
	         */
	        METHOD_ERROR = "error";

	        /**
	         * The message that has to be logged
	         * @type {Object}
	         */
	        LOG_MESSAGE = null;

	        /**
	         * Set of trace bits
	         * @type {Object}
	         */
	        TRACEBIT_SET = null;

	        /**
	         * "traceBitStates" - the array containg the states for the trace bits
	         * @type {object}
	         */
	        traceBitStates = {};

	        traceBitsChangedHandler = [];

	        /**
	         * See {@link Wincor.UI.Service.PTService#constructor}.
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            this.traceBitStates = {
	                20: false,
	                21: false,
	                22: false,
	                23: false,
	                24: false,
	                25: false,
	                26: false,
	                27: false,
	                28: false,
	                29: false
	            };

	            this.LOG_MESSAGE = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                eventName: this.METHOD_LOG,
	                traceBit: null,
	                logText: "" // text to log or write error
	            });

	            this.ERROR_MESSAGE = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                eventName: this.METHOD_ERROR,
	                logText: "" // text to log or write error
	            });

	            this.TRACEBIT_SET = Object.assign(Object.assign({}, this.REQUEST), {
	                service: this.NAME,
	                methodName: "trcCheckBit",
	                result: false
	            });

	            this.eventMap.set("setTraceBits", this.setTraceBits.bind(this));
	        }

	        /**
	         * This method logs the given "data" with the traceBit as source identifier
	         * The changed key will be updated in the DataRegistration structure, which contains all prior requested keys.
	         * @param {int} traceBit
	         * @param {string} data
	         */
	        log(traceBit, data) {
	            // Simplify this to speed up things. Errors should be handled in native code
	            if (!traceBit) {
	                return;
	            }
	            // TODO: Check if we really want to auto convert
	            data = "" + data; // implicit conversion
	            // cause of UTF-8 the max net trace is the half of 64K in order to avoid that
	            // nothing is traced of this log entry, which is always the case when the limit of 32K is exceeded
	            if (data.length > 30500) {
	                data = data.substring(0, 30500);
	                data = `${data}...truncated`;
	            }
	            this.LOG_MESSAGE.traceBit = traceBit;
	            this.LOG_MESSAGE.logText = data;
	            this.sendEvent(this.LOG_MESSAGE);
	        }

	        /**
	         * This method triggers an event, to log an error with the given data.
	         * @param {string} data
	         */
	        error(data) {
	            // TODO: Check if we really want to auto convert
	            data = "" + data; // implicit conversion
	            this.ERROR_MESSAGE.logText = data;
	            this.sendEvent(this.ERROR_MESSAGE);
	        }

	        /**
	         * Check if a trace bit is set.
	         * @param {int} traceBit
	         * @return {boolean}
	         */
	        isTraceBitSet(traceBit) {
	            return this.traceBitStates[traceBit];
	        }

	        /**
	         * Reads the tracebit states from business logic
	         * @param callback Callback function is called when all responses did arrive
	         */
	        readCurrentTraceBitStates(callback) {
	            let count = 10;
	            for (let i = 20; i < 30; i++) {
	                let message = Object.assign(Object.assign({}, this.TRACEBIT_SET), {
	                    traceBit: i
	                });
	                this.traceBitStates[i] = false;
	                this.sendRequest(message, response => {
	                    this.traceBitStates[response.traceBit] = response.result;
	                    count--;
	                    if (count === 0) {
	                        this.traceBitsChangedHandler.forEach(h => h(this.traceBitStates));
	                        if (callback) {
	                            callback();
	                        }
	                    }
	                });
	            }
	        }

	        /**
	         *
	         * @param handler
	         * @return {number}
	         */
	        registerTraceBitsChangedHandler(handler) {
	            if (this.traceBitsChangedHandler.indexOf(handler) === -1) {
	                this.traceBitsChangedHandler.push(handler);
	                return this.traceBitsChangedHandler.length - 1;
	            }
	            return -1;
	        }

	        removeTraceBitsChangedHandler(id) {
	            this.traceBitsChangedHandler.splice(id, 1);
	        }

	        /**
	         * Called from business logic to set tracebits, if they did change
	         * @param {object} message
	         */
	        setTraceBits(message) {
	            this.log(20, "LogService.setTraceBits: " + JSON.stringify(message)); //we can not use LOG_ANALYSE here
	            Object.keys(message.traceBits).forEach(
	                function(bit) {
	                    if (parseInt(bit) in this.traceBitStates) {
	                        this.traceBitStates[parseInt(bit)] = message.traceBits[bit];
	                    }
	                }.bind(this)
	            );
	            this.traceBitsChangedHandler.forEach(h => h(this.traceBitStates));
	        }

	        /**
	         *
	         */
	        onGatewayReady() {
	            super.onGatewayReady();
	            this.readCurrentTraceBitStates();
	        }
	    };
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ LogServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass = getServiceClass$2({
	    BaseService
	});

	const ServiceInterface = {
	    LogProxy: {
	        entryPoints: ["setTraceBits"],
	        service: "../service/wn.UI.Service.LogService.js",
	        interface: {
	            log: {
	                type: "function",
	                traceable: false,
	            },
	            error: {
	                type: "function",
	                traceable: false,
	            },
	            isTraceBitSet: {
	                type: "function",
	                traceable: false,
	            },
	            registerTraceBitsChangedHandler: {
	                type: "function",
	                traceable: false,
	            },
	            readCurrentTraceBitStates: {
	                type: "function",
	                traceable: false,
	                callbackArgumentIndex: 0,
	            },
	            TYPE: {
	                type: "string",
	                writable: false,
	            },
	        },
	    },
	};

	var LogService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface,
		ServiceClass: ServiceClass
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.AdaService.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$3 = ({ Wincor, ext, LogProvider, PTService }) => {
	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;

	    
	    return class AdaService extends PTService {
	        /**
	         * The logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         * @default "AdaService"
	         */
	        NAME = "AdaService";

	        /**
	         * Defines the response internal name mapping for the function {@link Wincor.UI.Service.AdaService#adaCommand}
	         * for the business-logic dispatching a request to us.
	         * @const
	         * @private
	         * @type {string}
	         * @default "adaCommand"
	         */
	        METHOD_ADACOMMAND = "adaCommand";

	        /**
	         * The actual state of ADA service, changed by function {@link Wincor.UI.Service.AdaService#adaCommand}.
	         * For possible values see: {@link Wincor.UI.Service.AdaService#STATE_VALUES}
	         * @type {string}
	         */
	        state = "";

	        /**
	         * Object containing the value definitions for state of ADA service {@link Wincor.UI.Service.AdaService#state}.
	         * @enum {string}
	         */
	        STATE_VALUES = {
	            /**
	             * Defines the inactive state for ADA service.
	             * ViewModel should do nothing.
	             * @type {string}
	             */
	            DONOTHING: "DONOTHING",
	            /**
	             * Defines the idle state for ADA service.
	             * ViewModel should prepare ADA texts.
	             * @type {string}
	             */
	            BEREADY: "BEREADY",
	            /**
	             * Defines the active state for ADA service.
	             * ViewModel should prepare ADA texts and speak them.
	             * @type {string}
	             */
	            SPEAK: "SPEAK"
	        };

	        /**
	         * This flag is true when error happens in ADA framework and one view in the GUI have to be ended
	         * with ADA error return code.
	         * This flag should be set to false when the one view in the GUI is ended with ADA error return code.
	         * @type {boolean}
	         * @default false
	         */
	        errorHappened = false;

	        /**
	         * This flag is true when ADA service enters active state and no speak is done yet.
	         * This flag should be set to false when the first speak is done or ADA service leaves active state.
	         * @type {boolean}
	         * @default false
	         */
	        firstSpeak = false;

	        /**
	         * This flag is true when ADA service is speaking.
	         * @type {boolean}
	         * @default false
	         */
	        isSpeaking = false;

	        /**
	         * This flag is true, if autoRepeat has been called with argument > 0
	         * @type {boolean}
	         * @default false
	         */
	        isAutoRepeatActive = false;

	        /**
	         * Events register IDs for control of isSpeaking flag.
	         * @type {number}
	         * @private
	         */
	        event1Id = 0;
	        event2Id = 0;
	        event4Id = 0;
	        event5Id = 0;

	        /**
	         * Object containing the definitions of view-service events other services or view-models  may register for.
	         * @enum {string}
	         */
	        SERVICE_EVENTS = {
	            /**
	             * Sent when state of ADA service {@link Wincor.UI.Service.AdaService#state} changes.
	             * @see {@link Wincor.UI.Service.AdaService#STATE_VALUES}
	             * @event Wincor.UI.Service.AdaService#SERVICE_EVENTS:STATE_CHANGED
	             * @eventtype service
	             */
	            STATE_CHANGED: "STATE_CHANGED",
	            /**
	             * Sent when error handling flag {@link Wincor.UI.Service.AdaService#errorHappened} is set to true.
	             * @type {String}
	             * @event Wincor.UI.Service.AdaService#SERVICE_EVENTS:ERROR_HAPPENED
	             * @eventtype service
	             */
	            ERROR_HAPPENED: "ERROR_HAPPENED",
	            /**
	             * Sent when ADA speaking flag {@link Wincor.UI.Service.AdaService#isSpeaking} is changing from true to false.
	             * @type {String}
	             * @event Wincor.UI.Service.AdaService#SERVICE_EVENTS:SPEAKING_STOPPED
	             * @eventtype service
	             */
	            SPEAKING_STOPPED: "SPEAKING_STOPPED",
	            /**
	             * Sent once when the ADA transaction begins.
	             * @type {String}
	             * @event Wincor.UI.Service.AdaService#SERVICE_EVENTS:FIRST_START
	             * @eventtype service
	             */
	            FIRST_START: "FIRST_START",
	            /**
	             * Sent once when the ADA transaction ends.
	             * @type {String}
	             * @event Wincor.UI.Service.AdaService#SERVICE_EVENTS:LAST_STOP
	             * @eventtype service
	             */
	            LAST_STOP: "LAST_STOP",

	            /**
	             * Sent when ADA text is on repeat.
	             * @type {String}
	             * @event Wincor.UI.Service.AdaService#SERVICE_EVENTS:REPEAT
	             * @eventtype service
	             */
	            REPEAT: "REPEAT"
	        };

	        /**
	         * See {@link Wincor.UI.Service.PTService#constructor}.<br>
	         * This method initialise METHOD_ADACOMMAND request delegate.
	         * The member {@link Wincor.UI.Service.AdaService#state} is initialised to DONOTHING.
	         *
	         * @param {Array} args
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaService::AdaService");

	            this.state = this.STATE_VALUES.DONOTHING;
	            this.viewIdWhenRepeatWasStarted = -1;
	            this.FRM_RESOLVE_REQUEST.service = this.NAME;
	            this.FRM_RESOLVE_REQUEST.FWName = "CCAdaFW";

	            //fill up request delegate
	            this.requestMap.set(this.METHOD_ADACOMMAND, this.adaCommand.bind(this));
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::AdaService");
	        }
	        
	        /**
	         * Called automatically as soon as there is an answer to an asynchronous ProTopas request. See {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * This method retruns return code (RC) of supported function ID's, else (-1)
	         *
	         * @param {object} message    Response object, see {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * @returns {number} ret      Return code (RC) of supported function ID's, else (-1).
	         */
	        translateResponse(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> AdaService::translateResponse('${JSON.stringify(message)}')`);
	            // if Speak("some text", ...) is OK then TTS is speaking!
	            let ret,
	                funcId = message.FWFuncID;

	            if (funcId === 4) {
	                if (message.RC === 0 && message.param1 && message.param1.length !== 0) {
	                    if (!this.isSpeaking) {
	                        this.isSpeaking = true;
	                    }
	                }
	            }
	            // always return message.RC
	            ret = message.RC;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< AdaService::translateResponse returns ${ret}`);
	            return ret;
	        }

	        /**
	         * This delegate is called when the speaking is completed.
	         * @private
	         * @fires Wincor.UI.Service.AdaService#SERVICE_EVENTS:SPEAKING_STOPPED
	         */
	        onAdaEventSpeakCompleted() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaService::onAdaEventSpeakCompleted");
	            // check if we still show the view where HELP has been pressed on
	            let currId = this.serviceProvider.ViewService.viewContext.viewID;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `. AdaService::onAdaEventSpeakCompleted forID/currID ${this.viewIdWhenRepeatWasStarted}/${currId}`);
	            if (this.viewIdWhenRepeatWasStarted === currId) {
	                this.viewIdWhenRepeatWasStarted = -1;
	                // if a timeout popup is open it is using own timer handling and thus the view must not restart its own timer
	                const vmHelper = Wincor.UI.Content.ViewModelHelper;
	                if (!vmHelper.isTimeoutPopupActive()) {
	                    // in this case the repeat event results from pressing 'HELP' button on EPP -> refresh interaction timeout of ViewService
	                    this.serviceProvider.ViewService.refreshTimeout();
	                } else {
	                    const timerInfo = vmHelper.getTimerInfo();
	                    _logger.LOG_SRVC_DATA &&
	                        _logger.log(_logger.LOG_SRVC_DATA, `* AdaService::onAdaEventSpeakCompleted currently a timeout popup is open - refreshing timeout for popup with name=${timerInfo.name}: ${timerInfo.timeLen}`);
	                    vmHelper.refreshTimer(timerInfo.timeLen, timerInfo.name);
	                }
	            }
	            if (this.isSpeaking) {
	                this.isSpeaking = false;
	                this.fireServiceEvent(this.SERVICE_EVENTS.SPEAKING_STOPPED);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::onAdaEventSpeakCompleted");
	        }

	        /**
	         * This delegate is called when the speaking is cancelled.
	         * @private
	         * @fires Wincor.UI.Service.AdaService#SERVICE_EVENTS:SPEAKING_STOPPED
	         */
	        onAdaEventSpeakCancelled() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaService::onAdaEventSpeakCancelled");
	            if (this.isSpeaking) {
	                this.isSpeaking = false;
	                this.fireServiceEvent(this.SERVICE_EVENTS.SPEAKING_STOPPED);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::onAdaEventSpeakCancelled");
	        }

	        /**
	         * This delegate is called when the ADA is stopped.
	         * @private
	         * @fires Wincor.UI.Service.AdaService#SERVICE_EVENTS:SPEAKING_STOPPED
	         */
	        onAdaEventStop() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaService::onAdaEventStop");
	            if (this.isSpeaking) {
	                this.isSpeaking = false;
	                this.fireServiceEvent(this.SERVICE_EVENTS.SPEAKING_STOPPED);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::onAdaEventStop");
	        }

	        /**
	         * This delegate is called when the repeat is triggered.
	         * @private
	         */
	        onAdaEventRepeat() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaService::onAdaEventRepeat");
	            if (!this.isAutoRepeatActive && !this.isSpeaking) {
	                // we will refresh it on next Completed event
	                this.serviceProvider.ViewService.clearTimeout();
	                this.viewIdWhenRepeatWasStarted = this.serviceProvider.ViewService.viewContext.viewID;
	                // if a timeout popup is open it is using own timer handling
	                const vmHelper = Wincor.UI.Content.ViewModelHelper;
	                if (vmHelper.isTimeoutPopupActive()) {
	                    const timerInfo = vmHelper.getTimerInfo();
	                    _logger.LOG_SRVC_DATA &&
	                        _logger.log(_logger.LOG_SRVC_DATA, `* AdaService::onAdaEventRepeat currently a timeout popup is open - refreshing timeout for popup with name=${timerInfo.name}: ${timerInfo.timeLen}`);
	                    vmHelper.refreshTimer(timerInfo.timeLen, timerInfo.name);
	                }
	                this.fireServiceEvent(this.SERVICE_EVENTS.REPEAT);
	            }

	            if (this.isSpeaking === false) {
	                this.isSpeaking = true;
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::onAdaEventRepeat");
	        }

	        /**
	         * This function delete blanks from the input text.
	         * @private
	         *
	         * @param {string} text       Input raw text.
	         * @returns {string}          Output filtered text.
	         */
	        removeBlanks(text) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> AdaService::removeBlanks('${text}')`);
	            let retText = "";

	            if (text === " ") {
	                // special for view start ... let this go as it is!
	                retText = text;
	            } else {
	                // remove blanks at begin and end
	                retText = text.trim();
	                // remove 2 and more blanks in text
	                retText = retText.replace(/ +/g, " ");
	            }

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< AdaService::removeBlanks returns '${retText}'`);
	            return retText;
	        }

	        /**
	         * Text that should be spoken
	         *
	         * @param {string=} text        Text to speech
	         * @param {number=} prio        Possibilities: 0 (CCADAFW_PRIO_NO_PURGE), 1 (CCADAFW_PRIO_LOW), 2 (CCADAFW_PRIO_HIGH)
	         * @param {number=} privacy     Possibilities: 0 (CCADAFW_PRIVACY_NONCONFIDENTIAL), 1 (CCADAFW_PRIVACY_CONFIDENTIAL), 10 (CCADAFW_PRIVACY_USE_DEFAULT)
	         * @param {function=} callback  Reference to a function receiving the return code as a parameter.
	         */
	        speak(text, prio, privacy, callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> AdaService::speak(txt:${text}, prio:${prio}, privacy:${privacy}, ...)`);
	            // this check is done to prevent error log from ADA framework!
	            if (this.state === this.STATE_VALUES.SPEAK) {
	                let strText = "";
	                let usPrio = 0; // CCADAFW_PRIO_NO_PURGE
	                let usPrivacy = 10; // CCADAFW_PRIVACY_USE_DEFAULT

	                if (text) {
	                    strText = this.removeBlanks(text);
	                }
	                if (prio) {
	                    usPrio = prio;
	                }
	                if (privacy) {
	                    usPrivacy = privacy;
	                }

	                // this check is done to make instance switching audible!
	                if (this.firstSpeak) {
	                    // Prio 2 purges all texts
	                    usPrio = 2;
	                    this.firstSpeak = false;
	                }

	                this.FRM_RESOLVE_REQUEST.FWFuncID = 4; // CCADAFW_FUNC_SPEAK_W
	                this.FRM_RESOLVE_REQUEST.param1 = strText;
	                this.FRM_RESOLVE_REQUEST.meta1 = ["WCHAR", -1]; // -1 is for automatic length detection
	                this.FRM_RESOLVE_REQUEST.param2 = usPrio;
	                this.FRM_RESOLVE_REQUEST.meta2 = ["USHORT", 0];
	                this.FRM_RESOLVE_REQUEST.param3 = usPrivacy;
	                this.FRM_RESOLVE_REQUEST.meta3 = ["USHORT", 0];
	                this.FRM_RESOLVE_REQUEST.paramUL = 0;

	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	                this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	            } else {
	                // if user wants callback ...
	                if (callback) {
	                    // emulate ADA framework return code for this case!
	                    callback(-100); // CCADAFW_RC_IGNORED ... CCADAFW_RC_ERROR will cause ADA error handling in Ada.js!
	                }
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::speak");
	        }

	        /**
	         * Volume will be increased
	         *
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        increaseVolume(callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaService::increaseVolume()");
	            this.FRM_RESOLVE_REQUEST.FWFuncID = 52; // CCADAFW_FUNC_INC_VOL
	            this.FRM_RESOLVE_REQUEST.param1 = "";
	            this.FRM_RESOLVE_REQUEST.meta1 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param2 = "";
	            this.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param3 = "";
	            this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.paramUL = 0;

	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::increaseVolume");
	        }

	        /**
	         * Volume will be decreased
	         *
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        decreaseVolume(callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaService::decreaseVolume()");
	            this.FRM_RESOLVE_REQUEST.FWFuncID = 53; // CCADAFW_FUNC_DEC_VOL
	            this.FRM_RESOLVE_REQUEST.param1 = "";
	            this.FRM_RESOLVE_REQUEST.meta1 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param2 = "";
	            this.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param3 = "";
	            this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.paramUL = 0;

	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::decreaseVolume");
	        }

	        /**
	         * Rate will be increased
	         *
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        increaseRate(callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaService::increaseRate()");
	            this.FRM_RESOLVE_REQUEST.FWFuncID = 55; // CCADAFW_FUNC_INC_RATE
	            this.FRM_RESOLVE_REQUEST.param1 = "";
	            this.FRM_RESOLVE_REQUEST.meta1 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param2 = "";
	            this.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param3 = "";
	            this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.paramUL = 0;

	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `Wincor.UI.Service.AdaService.increaseRate() Request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::increaseRate");
	        }

	        /**
	         * Rate will be decreased
	         *
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        decreaseRate(callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaService::decreaseRate()");
	            this.FRM_RESOLVE_REQUEST.FWFuncID = 56; // CCADAFW_FUNC_DEC_RATE
	            this.FRM_RESOLVE_REQUEST.param1 = "";
	            this.FRM_RESOLVE_REQUEST.meta1 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param2 = "";
	            this.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param3 = "";
	            this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.paramUL = 0;

	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::decreaseRate");
	        }

	        /**
	         * Ada focus is switched to UI application instance
	         * @param {boolean} [stopSpeaking=true]
	         * @returns {Promise<number>}
	         */
	        switchToApp(stopSpeaking = true) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> AdaService::switchToApp()`);
	            // copy request data, since we use other AdaSync for this request
	            const req = Object.assign({}, this.FRM_RESOLVE_REQUEST);
	            req.FWFuncID = 97; // internal switchToApp of AdaSync
	            req.FWName = "AdaSync";
	            req.param1 = "";
	            req.meta1 = ["NULL", 0];
	            req.param2 = "";
	            req.meta2 = ["NULL", 0];
	            req.param3 = "";
	            req.meta3 = ["NULL", 0];
	            req.paramUL = 0;

	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. request to send: '${JSON.stringify(req)}'.`);
	            return ext.Promises.promise((resolve, reject) => {
	                this.FrmResolve(req, rc => {
	                    if (rc <= -1000) {
	                        _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `. AdaService::switchToApp ada not installed or func not supported... ignore`);
	                        rc = 0;
	                    }
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< AdaService::switchToApp returns ${rc}`);
	                    if (rc === 0) {
	                        if (stopSpeaking) {
	                            this.speak(" ", 2, 0, () => {
	                                resolve(rc);
	                            });
	                        } else {
	                            resolve(rc);
	                        }
	                    } else {
	                        reject(`AdaService::switchToApp returned ${rc}`);
	                    }
	                });
	            });
	        }

	        /**
	         * Text that should be spoken when user press repeat EPP function key, overloads standard repeat behaviour!
	         *
	         * @param {string=} text            Text that should be spoken, turns this functionality ON. An empty string turns this functionality OFF!
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        setRepeatText(text, callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> AdaService::setRepeatText(${text})`);
	            if (this.state === this.STATE_VALUES.SPEAK) {
	                let strText = "";

	                if (text) {
	                    strText = this.removeBlanks(text);
	                }

	                this.FRM_RESOLVE_REQUEST.FWFuncID = 18; // CCADAFW_FUNC_REPEAT_FIXED_W
	                this.FRM_RESOLVE_REQUEST.param1 = strText;
	                this.FRM_RESOLVE_REQUEST.meta1 = ["WCHAR", -1]; // -1 is for automatic length detection
	                this.FRM_RESOLVE_REQUEST.param2 = "";
	                this.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	                this.FRM_RESOLVE_REQUEST.param3 = "";
	                this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	                this.FRM_RESOLVE_REQUEST.paramUL = 0;

	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	                this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	            } else {
	                // if user wants callback ...
	                if (callback) {
	                    // emulate ADA framework return code for this case!
	                    callback(-1); // CCADAFW_RC_ERROR
	                }
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::setRepeatText");
	        }

	        /**
	         * This method controls automatic repeat functionality. Call it with parameter > 0 and it will start,
	         * parameter 0 will stop functionality. The functionality is to call Repeat functionality
	         * after timer of parameterized time expires. The timer will run only, if there is no speaking.
	         * If some speaks occur, timer will be restarted at speak end!
	         * Functionality will auto end on call of Reset(), Stop() or WaitForStart() methodes of CCADAFW.
	         *
	         * @param {int=} repeatPause        The 0 or ommited argument stops the automatic repeat functionality. Positive number is pause in milliseconds between repeats.
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        autoRepeat(repeatPause, callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> AdaService::AutoRepeat(${repeatPause})`);

	            let repeatPauseTime = 0;
	            if (repeatPause && repeatPause > 0) {
	                repeatPauseTime = repeatPause;
	            }

	            this.isAutoRepeatActive = repeatPauseTime !== 0;

	            this.FRM_RESOLVE_REQUEST.FWFuncID = 67; // CCADAFW_FUNC_AUTO_REPEAT
	            this.FRM_RESOLVE_REQUEST.param1 = repeatPauseTime;
	            this.FRM_RESOLVE_REQUEST.meta1 = ["ULONG", 0];
	            this.FRM_RESOLVE_REQUEST.param2 = "";
	            this.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param3 = "";
	            this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.paramUL = 0;

	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::AutoRepeat");
	        }

	        /**
	         * register ADA events for control of isSpeaking flag
	         * @private
	         */
	        registerAdaEventsForSpeakingControl() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaService::registerAdaEventsForSpeakingControl()");
	            const evtService = this.serviceProvider.EventService;
	            this.event1Id = evtService.registerForEvent(
	                1,
	                "CCADAFW",
	                this.onAdaEventSpeakCompleted.bind(this),
	                () => _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaService::registerAdaEventsForSpeakingControl register callback for event (1): SpeakCompleted"),
	                "ASCII",
	                true
	            );
	            this.event2Id = evtService.registerForEvent(
	                2,
	                "CCADAFW",
	                this.onAdaEventSpeakCancelled.bind(this),
	                () => _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaService::registerAdaEventsForSpeakingControl register callback for event (2): SpeakCancelled"),
	                "ASCII",
	                true
	            );
	            this.event4Id = evtService.registerForEvent(
	                4,
	                "CCADAFW",
	                this.onAdaEventStop.bind(this),
	                () => _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaService::registerAdaEventsForSpeakingControl register callback for event (4): Stop"),
	                "ASCII",
	                true
	            );
	            this.event5Id = evtService.registerForEvent(
	                5,
	                "CCADAFW",
	                this.onAdaEventRepeat.bind(this),
	                () => _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaService::registerAdaEventsForSpeakingControl register callback for event (5): Repeat"),
	                "ASCII",
	                true
	            );
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::registerAdaEventsForSpeakingControl");
	        }

	        /**
	         * deregister ADA events for control of isSpeaking flag
	         * @private
	         * @fires Wincor.UI.Service.AdaService#SERVICE_EVENTS:SPEAKING_STOPPED
	         */
	        deregisterAdaEventsForSpeakingControl() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaService::deregisterAdaEventsForSpeakingControl()");
	            const evtService = this.serviceProvider.EventService;
	            if (this.event1Id !== 0) {
	                evtService.deregisterEvent(
	                    this.event1Id,
	                    () => _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaService::deregisterAdaEventsForSpeakingControl deregister callback for event (1): SpeakCompleted")
	                );
	                this.event1Id = 0;
	            }
	            if (this.event2Id !== 0) {
	                evtService.deregisterEvent(
	                    this.event2Id,
	                    () => _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaService::deregisterAdaEventsForSpeakingControl deregister callback for event (2): SpeakCancelled")
	                );
	                this.event2Id = 0;
	            }
	            if (this.event4Id !== 0) {
	                evtService.deregisterEvent(this.event4Id, () => _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaService::deregisterAdaEventsForSpeakingControl deregister callback for event (4): Stop"));
	                this.event4Id = 0;
	            }
	            if (this.event5Id !== 0) {
	                evtService.deregisterEvent(
	                    this.event5Id,
	                    () => _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaService::deregisterAdaEventsForSpeakingControl deregister callback for event (5): Repeat")
	                );
	                this.event5Id = 0;
	            }

	            if (this.isSpeaking) {
	                this.isSpeaking = false;
	                this.fireServiceEvent(this.SERVICE_EVENTS.SPEAKING_STOPPED);
	            }

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::deregisterAdaEventsForSpeakingControl");
	        }

	        /**
	         * This method is called by the ViewService to sync viewset switch
	         *
	         * @param {string} eventData    event data, possibilities: "FIRSTSTART", "FIRSTSTARTANDACTIVATE", "LASTSTOP"
	         */
	        externalAdaCommandAck(eventData) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> AdaService::externalAdaCommandAck('${eventData}')`);

	            if (eventData || eventData.length === 0) {
	                const msg = {};
	                msg.service = this.NAME;
	                msg.eventName = "4020"; //pce::gui::EVENT_ADA_COMMAND_ACK
	                msg.eventData = eventData;
	                try {
	                    this.sendEvent(msg);
	                } catch (e) {
	                    _logger.error(e.message);
	                }
	            } else {
	                _logger.error("AdaService::externalAdaCommandAck() has been called without a parameter!");
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::externalAdaCommandAck");
	        }

	        /**
	         * This method is called by the business logic to control ADA.
	         *
	         * @param {object} message      JSON object containing the key 'command'.
	         * @private
	         * @fires Wincor.UI.Service.AdaService#SERVICE_EVENTS:STATE_CHANGED
	         * @fires Wincor.UI.Service.AdaService#SERVICE_EVENTS:FIRST_START
	         * @fires Wincor.UI.Service.AdaService#SERVICE_EVENTS:LAST_STOP
	         * @fires Wincor.UI.Service.AdaService#SERVICE_EVENTS:ERROR_HAPPENED
	         */
	        adaCommand(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> AdaService::adaCommand('${JSON.stringify(message)}')`);

	            if (message.command !== undefined && message.command !== null) {
	                try {
	                    let fireAck = true; // flag for syncing with GuiSyncADA

	                    if (message.command === "IDLE") {
	                        this.state = this.STATE_VALUES.BEREADY;
	                        this.firstSpeak = false;
	                        this.errorHappened = false;
	                        this.deregisterAdaEventsForSpeakingControl();
	                        this.fireServiceEvent(this.SERVICE_EVENTS.STATE_CHANGED, this.state);
	                    } else if (message.command === "START") {
	                        this.state = this.STATE_VALUES.SPEAK;
	                        this.firstSpeak = true;
	                        this.registerAdaEventsForSpeakingControl();
	                        this.fireServiceEvent(this.SERVICE_EVENTS.STATE_CHANGED, this.state);
	                    } else if (message.command === "FIRSTSTART") {
	                        this.fireServiceEvent(this.SERVICE_EVENTS.FIRST_START, message.command);
	                        fireAck = false;
	                    } else if (message.command === "FIRSTSTARTANDACTIVATE") {
	                        this.fireServiceEvent(this.SERVICE_EVENTS.FIRST_START, message.command);
	                        fireAck = false;

	                        // activate speaking
	                        this.state = this.STATE_VALUES.SPEAK;
	                        this.firstSpeak = true;
	                        this.registerAdaEventsForSpeakingControl();
	                        // don't send SERVICE_EVENTS.STATE_CHANGED to stay silent in IdleLoop view
	                    } else if (message.command === "STOP") {
	                        this.state = this.STATE_VALUES.DONOTHING;
	                        this.firstSpeak = false;
	                        this.deregisterAdaEventsForSpeakingControl();
	                        this.fireServiceEvent(this.SERVICE_EVENTS.STATE_CHANGED, this.state);
	                    } else if (message.command === "LASTSTOP") {
	                        this.state = this.STATE_VALUES.DONOTHING;
	                        this.firstSpeak = false;
	                        this.deregisterAdaEventsForSpeakingControl();
	                        this.fireServiceEvent(this.SERVICE_EVENTS.STATE_CHANGED, this.state);

	                        this.fireServiceEvent(this.SERVICE_EVENTS.LAST_STOP, message.command);
	                        fireAck = false;
	                    } else if (message.command === "ERROR") {
	                        // Do "STOP" first
	                        this.state = this.STATE_VALUES.DONOTHING;
	                        this.firstSpeak = false;
	                        this.deregisterAdaEventsForSpeakingControl();
	                        this.fireServiceEvent(this.SERVICE_EVENTS.STATE_CHANGED, this.state);
	                        // Do "error handling"
	                        // NOTE: BL should only send ERROR if ADA is mandatory, otherwise BL should use STOP!
	                        this.errorHappened = true;
	                        this.fireServiceEvent(this.SERVICE_EVENTS.ERROR_HAPPENED);
	                    }

	                    if (fireAck) {
	                        const msg = {};
	                        msg.service = this.NAME;
	                        msg.eventName = "4020"; //pce::gui::EVENT_ADA_COMMAND_ACK
	                        msg.eventData = message.command;
	                        this.sendEvent(msg);
	                    }
	                } catch (e) {
	                    _logger.error(e.message);
	                }
	            } else {
	                _logger.error("AdaService::adaCommand() has been called without a command!");
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaService::adaCommand");
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ AdaServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$1 = getServiceClass$3({
	    Wincor: Wincor$2,
	    ext: ext$2,
	    LogProvider,
	    PTService,
	});

	const ServiceInterface$1 = {
	    AdaProxy: {
	        entryPoints: ["adaCommand"],
	        service: "../service/wn.UI.Service.AdaService.js",
	        interface: {
	            state: {
	                type: "string",
	            },
	            STATE_VALUES: {
	                type: "object",
	                keys: ["DONOTHING", "BEREADY", "SPEAK"],
	            },
	            errorHappened: {
	                type: "boolean",
	            },
	            isSpeaking: {
	                type: "boolean",
	                writable: false,
	            },
	            isAutoRepeatActive: {
	                type: "boolean",
	                writable: false,
	            },
	            SERVICE_EVENTS: {
	                type: "object",
	                keys: ["STATE_CHANGED", "ERROR_HAPPENED", "SPEAKING_STOPPED", "FIRST_START", "LAST_STOP"],
	                writable: false,
	            },
	            speak: {
	                type: "function",
	                callbackArgumentIndex: 3,
	            },
	            increaseVolume: {
	                type: "function",
	                callbackArgumentIndex: 0,
	            },
	            decreaseVolume: {
	                type: "function",
	                callbackArgumentIndex: 0,
	            },
	            increaseRate: {
	                type: "function",
	                callbackArgumentIndex: 0,
	            },
	            decreaseRate: {
	                type: "function",
	                callbackArgumentIndex: 0,
	            },
	            setRepeatText: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            autoRepeat: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            externalAdaCommandAck: {
	                type: "function",
	            },
	            switchToApp: {
	                type: "function",
	            },
	        },
	    },
	};

	var AdaService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$1,
		ServiceClass: ServiceClass$1
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.BeepService.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$4 = ({Wincor, ext, LogProvider, PTService}) => {

	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;
	    
	    return class BeepService extends PTService {
	    
	        /**
	         * The logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         * @default "BeepService"
	         */
	        NAME = "BeepService";
	    
	        /**
	         * This flag turns the beeping ON/OFF.
	         * It reflects the corresponding 'Beeping' registry parameter of Beep service and is initialised in {@link Wincor.UI.Service.BeepService#onServicesReady}.
	         * @type {boolean}
	         * @default true
	         */
	        beeping = true;
	    
	        /**
	         * This is the code for the beep of inactive EPP keys.
	         * It reflects the corresponding 'BEEP_INACTIVE_KEY_COMMAND' registry parameter of EppSync framework and is initialised in {@link Wincor.UI.Service.BeepService#onServicesReady}.
	         * Possible values are:<br>
	         *   <ul>
	         *     <li>0  = OFF</li>
	         *     <li>2  = SIU_KEYPRESS</li>
	         *     <li>4  = SIU_EXCLAMATION</li>
	         *     <li>8  = SIU_WARNING</li>
	         *     <li>16 = SIU_ERROR</li>
	         *     <li>32 = SIU_CRITICAL</li>
	         *   </ul>
	         * @type {number}
	         * @default 8
	         */
	        beepInactiveKeyCode = 8;
	    
	        /**
	         * See {@link Wincor.UI.Service.PTService#constructor}.
	         *
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> BeepService::BeepService");
	    
	            this.FRM_RESOLVE_REQUEST.service = this.NAME;
	            this.FRM_RESOLVE_REQUEST.FWName = "CCSelFW";
	    
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< BeepService::BeepService");
	        }
	        
	        /**
	         * Do a beep.
	         * If the beeping is activated {@link Wincor.UI.Service.BeepService#beeping},
	         * the asynchronous call to the SEL framework function CCSELFW_FUNC_SET_INDICATOR is done and its return code(RC) is given to the callback function,
	         * else the error return code (-1) is given to the callback function immediately.
	         *
	         * @param {number} [code=2]     beep type, possibilities:
	         * <ul>
	         *      <li>2  (CCSELFW_SIU_KEYPRESS)</li>
	         *      <li>4  (CCSELFW_SIU_EXCLAMATION)</li>
	         *      <li>8  (CCSELFW_SIU_WARNING)</li>
	         *      <li>16 (CCSELFW_SIU_ERROR)</li>
	         *      <li>32 (CCSELFW_SIU_CRITICAL)</li>
	         * </ul>
	         * @param {function} [callback=null]      Reference to a function receiving the return code as a parameter.
	         */
	        beep(code = 2, callback = null) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> BeepService::beep(code:${code}, ...)`);
	    
	            if(this.beeping) {
	                this.FRM_RESOLVE_REQUEST.FWFuncID   = 57;              // CCSELFW_FUNC_SET_INDICATOR
	                this.FRM_RESOLVE_REQUEST.param1     = 2;               // CCSELFW_SIU_AUDIO
	                this.FRM_RESOLVE_REQUEST.meta1      = ["USHORT", 0];
	                this.FRM_RESOLVE_REQUEST.param2     = code;
	                this.FRM_RESOLVE_REQUEST.meta2      = ["USHORT", 0];
	                this.FRM_RESOLVE_REQUEST.param3     = "";
	                this.FRM_RESOLVE_REQUEST.meta3      = ["NULL", 0];
	                this.FRM_RESOLVE_REQUEST.paramUL    = 0;
	    
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	                this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	            } else if (callback) { // if user wants callback ...
	                // emulate SEL framework return code for this case!
	                callback(-1);   // CCSELFW_ERROR
	            }
	    
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< BeepService::beep");
	        }
	    
	        /**
	         * Called automatically as soon as there is an answer to an asynchronous ProTopas request. See {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * This function handles the response for CCSELFW_FUNC_SET_INDICATOR request.
	         *
	         * @param {Object} message    Response object, see {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * @returns {number}          Return code (RC) for CCSELFW_FUNC_SET_INDICATOR, -1 for rest
	         */
	        translateResponse(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> BeepService::translateResponse('${JSON.stringify(message)}')`);
	            var ret;
	            if (message.FWFuncID === 57) {          //CCSELFW_FUNC_SET_INDICATOR
	                ret = message.RC;
	            } else {
	                _logger.error("Wincor.UI.Service.BeepService(onResponse): unknown function");
	                ret = -1;
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< BeepService::translateResponse returns ${ret}`);
	            return ret;
	        }
	    
	        /**
	         * See {@link Wincor.UI.Service.BaseService#onServicesReady}
	         * This function initialise the members {@link Wincor.UI.Service.BeepService#beeping} and {@link Wincor.UI.Service.BeepService#beepInactiveKeyCode} with corresponding registry values.
	         *
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onServicesReady() {
	            return ext.Promises.promise(resolve => {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> BeepService::onServicesReady()");
	                const configService = this.serviceProvider.ConfigService;
	                const generalSection = `${configService.configuration.instanceName}\\Services\\General`;
	                const key = "Beeping";
	                const keyBeep4InactiveKey = "BEEP_INACTIVE_KEY_COMMAND";
	    
	                configService.getConfiguration(generalSection, [key])
	                    .then(result => {
	                        if (result[key] === false) {
	                            this.beeping = false;
	                        }
	                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* BeepService::onServicesReady(): beeping=${this.beeping}`);
	                        return configService.getConfiguration("ADA\\CCEPPRTCFW", [keyBeep4InactiveKey]);
	                    })
	                    .then(result => {
	                        if (result[keyBeep4InactiveKey] !== void 0 && result[keyBeep4InactiveKey] !== null && result[keyBeep4InactiveKey] !== "") {
	                            this.beepInactiveKeyCode = parseInt(result[keyBeep4InactiveKey]);
	                        }
	                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* BeepService::onServicesReady(): beepInactiveKey=${this.beepInactiveKeyCode}`);
	                        _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< BeepService::onServicesReady");
	                        super.onServicesReady().then(resolve);
	                    });
	            });
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ BeepServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$2 = getServiceClass$4({
	    Wincor: Wincor$2,
	    ext: ext$2,
	    LogProvider,
	    PTService
	});

	const ServiceInterface$2 = {
	    BeepProxy: {
	        service: "../service/wn.UI.Service.BeepService.js",
	        interface: {
	            beeping: {
	                type: "boolean",
	                writable: false,
	            },
	            beepInactiveKeyCode: {
	                type: "number",
	                writable: false,
	            },
	            beep: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	        },
	    },
	};

	var BeepService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$2,
		ServiceClass: ServiceClass$2
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.ConfigService.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$5 = ({ Wincor, ext, LogProvider, PTService }) => {
	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @const
	     * @private
	     */
	    const _logger = LogProvider;

	    return class ConfigService extends PTService {
	        /**
	         * "ConfigService" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "ConfigService";

	        /**
	         * Holds the configuration for the ConfigService, currently only the instance name.
	         * @property {Object} configuration
	         * @property {String} configuration.instanceName the name of the instance e.g. <i>'GUIAPP', 'GUIDM' or 'GUIVIDEO'</i>
	         */
	        configuration = { instanceName: "" };

	        /**
	         * @see {@link Wincor.UI.Service.PTService#constructor}.
	         *
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ConfigService::ConfigService");
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ConfigService::ConfigService");
	        }
	        
	        /**
	         * @see {@link Wincor.UI.Service.BaseService#onSetup}
	         *
	         * Initially, the ConfigService needs the instance name (GUIAPP, GUIDM, ...), because this is needed for further requests.
	         *
	         * @param {object} message      A configuration object, which constains the instanceName.
	         * @lifecycle service
	         */
	        onSetup(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ConfigService::onSetup('${JSON.stringify(message)}')`);
	            this.configuration.instanceName = message.instanceName;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ConfigService::onSetup");
	            return ext.Promises.Promise.resolve(); // synchronous fulfillment
	        }

	        /**
	         * Gets a configuration from the central config source, e.g. Windows registry.
	         *
	         * TODO add some examples here, because the DataFW restrictions are a bit hard to explain. This examples should also show the result structure.
	         *
	         * @param {string} section                  Name e.g. "GUIAPP\\Services\\Timeouts"
	         * @param {Array<string> | string} keys     E.g. ["DEFAULT_PAGE_TIMEOUT", "DEFAULT_INPUT_TIMEOUT", ...] or null for requesting the whole section
	         * @param {function=} callback              Callback function, which receives the result. See {@link Wincor.UI.Service.ConfigService#translateResponse} for the result structure.
	         */
	        getConfiguration(section, keys, callback) {

	            keys = Array.isArray(keys) ? keys : [keys];

	            let path;
	            if (section.startsWith(this.configuration.instanceName)) { //it starts with GUIAPP or GUIDM
	                if (keys[0] === null) {
	                    path = `CCOPEN\\GUI\\${section}`;
	                } else {
	                    path = `.\\CCOPEN\\GUI\\${section}`;
	                }
	            } else { // it starts with some other section
	                if (keys[0] === null) { // a whole section is requested ?
	                    path = section; // we assume it's something located under ProTopas/CurrentVersion directly here - whole section reading works only under "\ProTopas\"
	                } else if(!section.startsWith("\\")) {
	                    path = `.\\${section}`;
	                } else { // We have a single parameter key name here.
	                    // Because the DataFW has the limitation that requesting a section outside of "\ProTopas" only works for single parameter not for the whole section
	                    path = section;
	                }
	            }

	            this.FRM_RESOLVE_REQUEST.service = this.NAME;
	            this.FRM_RESOLVE_REQUEST.FWName = "CCDataFW";

	            this.FRM_RESOLVE_REQUEST.FWFuncID = 7;  //CCDATAFW_FUNC_GET_STRING
	            this.FRM_RESOLVE_REQUEST.param1 = path;
	            if (keys[0] !== null) {
	                this.FRM_RESOLVE_REQUEST.param2 = keys;
	            } else {
	                this.FRM_RESOLVE_REQUEST.param2 = [];
	            }
	            this.FRM_RESOLVE_REQUEST.param3 = [];

	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `ConfigService::getConfiguration() Request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	        }

	        /**
	         * Called automatically as soon as there is an answer to an asynchronous ProTopas request. See {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * The returend object depends wether a single key or a complete section was requested.
	         *
	         * @param {object} message    Response object, see {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * @returns {object}        A JSON object:
	         *                          Each object parameter will be one of the requested keys/section.
	         *                          Each value will be either a string (if exactly one parameter was requested) or a JSON object (if a complete section was requested).
	         */
	        translateResponse(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ConfigService::translateResponse('${JSON.stringify(message)}')`);
	            const response = {};
	            if (message.FWFuncID === 7 && message.RC === 0) {
	                //
	                //  message.param2 has the keys,   i.e. [key1,   key2,   ...]
	                //  message.param3 has the values, i.e. [value1, value2, ...]

	                //  response will be an object:
	                //  response["key1"] = value1
	                //  response["key2"] = value2
	                //  ...

	                for (let i in message.param2) {
	                    if (message.param2.hasOwnProperty(i)) {
	                        let myKey = message.param2[i].toString();

	                        try {
	                            // try to copy a JSON object
	                            response[myKey] = JSON.parse(message.param3[i]);
	                        }
	                        catch (e) {
	                            // copy the string value
	                            response[myKey] = message.param3[i];
	                        }
	                    }
	                }
	            } else {
	                _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `Wincor.UI.Service.ConfigService(onResponse): message with FWFuncID '${message.FWFuncID}' and RC = '${message.RC}' will not be evaluated.`);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< ConfigService::translateResponse returns ${JSON.stringify(response)}`);
	            return response;
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ ConfigServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$3 = getServiceClass$5({
	    Wincor: Wincor$2,
	    ext: ext$2,
	    LogProvider,
	    PTService
	});

	const ServiceInterface$3 = {
	    ConfigProxy: {
	        service: "../service/wn.UI.Service.ConfigService.js",
	        interface: {
	            getConfiguration: {
	                type: "function",
	                callbackArgumentIndex: 2,
	            },
	            configuration: {
	                type: "object",
	                keys: ["instanceName"],
	            },
	            retrieveJSONData: {
	                type: "function",
	            },
	        },
	    },
	};

	var ConfigService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$3,
		ServiceClass: ServiceClass$3
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.UtilityService.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$6 = ({ Wincor, ext, LogProvider, PTService }) => {
	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;

	    return class UtilityService extends PTService {
	        /**
	         * "UtilityService" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "UtilityService";

	        /**
	         * @type {Number}
	         * @enum
	         */
	        IMG_FORMAT = {
	            /** -1 */
	            UNKNOWN: -1,
	            /** 0 */
	            BMP: 0,
	            /** 1 */
	            ICO: 1,
	            /** 2 */
	            JPEG: 2,
	            /** 2 */
	            JPG: 2,
	            /** 3 */
	            JNG: 3,
	            /** 4 */
	            KOALA: 4,
	            /** 5 */
	            LBM: 5,
	            /** 5 */
	            IFF: 5,
	            /** 6 */
	            MNG: 6,
	            /** 7 */
	            PBM: 7,
	            /** 8 */
	            PBMRAW: 8,
	            /** 9 */
	            PCD: 9,
	            /** 10 */
	            PCX: 10,
	            /** 11 */
	            PGM: 11,
	            /** 12 */
	            PGMRAW: 12,
	            /** 13 */
	            PNG: 13,
	            /** 14 */
	            PPM: 14,
	            /** 15 */
	            PPMRAW: 15,
	            /** 16 */
	            RAS: 16,
	            /** 17 */
	            TARGA: 17,
	            /** 18 */
	            TIFF: 18,
	            /** 19 */
	            WBMP: 19,
	            /** 20 */
	            PSD: 20,
	            /** 21 */
	            CUT: 21,
	            /** 22 */
	            XBM: 22,
	            /** 23 */
	            XPM: 23,
	            /** 24 */
	            DDS: 24,
	            /** 25 */
	            GIF: 25,
	            /** 26 */
	            HDR: 26
	        };

	        DEVICE_STATE = {
	            UNDEFINED: 0,
	            OPERATIONAL: 1,
	            NOT_OPERATIONAL: 2,
	            NOT_INSTALLED: 3,
	            DEACTIVATED: 6,
	            NOT_OPERATIONAL_DEACTIVATED: 7
	        };

	        INSTALL_STATE = {
	            NOT_INSTALLED: 0,
	            OPTIONAL: 1,
	            MANDATORY: 2
	        };

	        /**
	         * The standard working directories for transactions and sessions.
	         * @default
	         * <br><code>{<br>
	         *   TRANSACTION: "/TEMP_TRANSACTION/",<br>
	         *   SESSION: "/TEMP_SESSION/"<br>
	         * }</code>
	         * @enum {String}
	         */
	        WORKING_DIRS = {
	            /** The transaction folder */
	            TRANSACTION: "/TEMP_TRANSACTION/",
	            /** The session folder */
	            SESSION: "/TEMP_SESSION/"
	        };

	        /**
	         * This object contains all utility-service events, for which other services or view-models can register itself.
	         * @enum {string}
	         */
	        SERVICE_EVENTS = {
	            /**
	             * Sent if the business logic informs about a customer session has ended.
	             * @event Wincor.UI.Service.UtilityService#SERVICE_EVENTS:SESSION_END
	             * @eventtype service
	             */
	            SESSION_END: "SESSION_END"
	        };

	        /**
	         * See {@link Wincor.UI.Service.PTService#constructor}.
	         * Initializes members to their default values
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityService::UtilityService");
	            this.savedFiles = [];
	            this.imageStore = `${Wincor.applicationRoot}/WORK/TEMP_TRANSACTION/`;
	            this.imageStoreRoot = `${Wincor.applicationRoot}/WORK`; // c:/proflex4/base + /WORK
	            this.targetFileType = "bmp";
	            this.FRM_RESOLVE_IMG_CONV_REQUEST = Object.assign(this.FRM_RESOLVE_REQUEST);
	            this.FRM_RESOLVE_IMG_CONV_REQUEST.FWName = "CCImgCnv";

	            this.FRM_ASYNC_RESOLVE_REQUEST.service = this.NAME;
	            this.FRM_ASYNC_RESOLVE_REQUEST.FWName = "CCTransactionFW";
	            this.PATHS = {};
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityService::UtilityService");
	        }
	        
	        /**
	         * Called automatically as soon as there is an answer to an asynchronous ProTopas request. See {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * Translates message object to
	         *
	         * @param {object} message    Response object, see {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * @returns {Number} RC The original return code of the asynchronous function call
	         */
	        translateResponse(message) {
	            let ret;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> UtilityService::translateResponse('${JSON.stringify(message)}')`);
	            if (message.FWName === "CCErrMgrFW") {
	                ret = message;
	            } else {
	                ret = message.RC;
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityService::translateResponse returns " + ret);
	            return ret;
	        }

	        /**
	         * Loads an image into memory of CCImgCnv.dll to prepare manipulation.
	         * @param {string} srcFileName
	         * @param {string} srcFormat
	         * @param {number} flags
	         * @returns {Promise}
	         */
	        imgConvLoadImage(srcFileName, srcFormat, flags) {
	            const self = this;
	            return ext.Promises.promise(function(resolve, reject) {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityService::imgConvLoadImage");

	                self.FRM_RESOLVE_IMG_CONV_REQUEST.FWName = "CCImgCnv";
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.FWFuncID = 3; // CCIMGCNV_FUNC_LOADIMAGE
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.param1 = srcFormat;
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.meta1 = ["SHORT", 0];
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.param2 = srcFileName;
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.meta2 = ["CHAR_ANSI", -1];
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.param3 = flags;
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.meta3 = ["USHORT", 0];
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.paramUL = 0;

	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(self.FRM_RESOLVE_IMG_CONV_REQUEST)}'.`);
	                self.FrmResolve(self.FRM_RESOLVE_IMG_CONV_REQUEST, function(result) {
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityService::imgConvLoadImage returned " + result);
	                    if (result === 0) {
	                        resolve();
	                    } else {
	                        reject("result of UtilityService::imgConvLoadImage was: " + result);
	                    }
	                });
	            });
	        }

	        /**
	         * Unloads an image from memory of CCImgCnv.dll
	         * @returns {Promise}
	         */
	        imgConvUnloadImage() {
	            const self = this;
	            return ext.Promises.promise(function(resolve, reject) {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityService::imgConvUnloadImage");

	                self.FRM_RESOLVE_IMG_CONV_REQUEST.FWName = "CCImgCnv";
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.FWFuncID = 4; // CCIMGCNV_FUNC_UNLOADIMAGE
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.param1 = "";
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.meta1 = ["NULL", 0];
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.param2 = "";
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.meta2 = ["NULL", 0];
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.param3 = "";
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.meta3 = ["NULL", 0];
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.paramUL = 0;

	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(self.FRM_RESOLVE_IMG_CONV_REQUEST)}'.`);
	                self.FrmResolve(self.FRM_RESOLVE_IMG_CONV_REQUEST, function(result) {
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityService::imgConvUnloadImage returned " + result);
	                    if (result === 0) {
	                        resolve();
	                    } else {
	                        reject("result of UtilityService::imgConvUnloadImage was: " + result);
	                    }
	                });
	            });
	        }

	        /**
	         * Saves image to file from memory of CCImgCnv.dll
	         * @param {string} targetFileName
	         * @param {string} targetFormat
	         * @param {number} flags
	         * @returns {*}
	         */
	        imgConvSaveImage(targetFileName, targetFormat, flags) {
	            const self = this;
	            return ext.Promises.promise(function(resolve, reject) {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityService::imgConvSaveImage");

	                self.FRM_RESOLVE_IMG_CONV_REQUEST.FWFuncID = 5; // CCIMGCNV_FUNC_SAVEIMAGE
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.param1 = targetFormat;
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.meta1 = ["SHORT", 0];
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.param2 = targetFileName;
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.meta2 = ["CHAR_ANSI", -1];
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.param3 = flags;
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.meta3 = ["USHORT", 0];
	                self.FRM_RESOLVE_IMG_CONV_REQUEST.paramUL = 0;

	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(self.FRM_RESOLVE_IMG_CONV_REQUEST)}'.`);
	                self.FrmResolve(self.FRM_RESOLVE_IMG_CONV_REQUEST, function(result) {
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< UtilityService::imgConvSaveImage returned ${result}`);
	                    if (result === 0) {
	                        resolve();
	                    } else {
	                        reject("Result of UtilityService::imgConvSaveImage was: " + result);
	                    }
	                });
	            });
	        }

	        /**
	         * Convenience function used to convert an existing image on file system to a specific format.
	         * @param {string} srcFileName
	         * @param {string} srcFileFormat
	         * @param {string} targetFileName
	         * @param {string} targetFileFormat
	         */
	        convertFileType(srcFileName, srcFileFormat, targetFileName, targetFileFormat) {
	            const self = this;
	            return ext.Promises.promise(function(resolve, reject) {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> UtilityService::convertFileType(${srcFileName}, ${srcFileFormat}, ${targetFileName}, ${targetFileFormat})`);
	                const srcFormat = self.IMG_FORMAT[srcFileFormat.toUpperCase()];
	                const targetFormat = self.IMG_FORMAT[targetFileFormat.toUpperCase()];
	                const flags = 0;
	                if (!srcFormat) {
	                    reject("UtilityService::convertFileType srcFileFormat invalid: " + srcFileFormat);
	                } else if (targetFormat === void 0) {
	                    reject("UtilityService::convertFileType targetFileFormat invalid: " + targetFileFormat);
	                } else {
	                    // go
	                    self.imgConvLoadImage(srcFileName, srcFormat, flags)
	                        .then(function() {
	                            return self.imgConvSaveImage(targetFileName, targetFormat, flags);
	                        })
	                        .then(self.imgConvUnloadImage.bind(self))
	                        .then(function() {
	                            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityService::convertFileType");
	                        })
	                        .then(resolve, reject);
	                }
	            });
	        }

	        /**
	         * Removes the transparent window color of the browser window.
	         * @returns {Promise}
	         */
	        removeTransparentWindowColor() {
	            const self = this;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityService::removeTransparentWindowColor()");
	            return ext.Promises.promise(function(resolve, reject) {
	                self.FRM_RESOLVE_REQUEST.FWName = Wincor.UI.Service.Provider.ConfigService.configuration.instanceName;
	                self.FRM_RESOLVE_REQUEST.FWFuncID = 4029; // UI method removeTransparency
	                self.FRM_RESOLVE_REQUEST.param1 = "";
	                self.FRM_RESOLVE_REQUEST.meta1 = ["NULL", 0];
	                self.FRM_RESOLVE_REQUEST.param2 = "";
	                self.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	                self.FRM_RESOLVE_REQUEST.param3 = "";
	                self.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	                self.FRM_RESOLVE_REQUEST.param4 = "";
	                self.FRM_RESOLVE_REQUEST.meta4 = ["NULL", 0];
	                self.FRM_RESOLVE_REQUEST.paramUL = 0;
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(self.FRM_RESOLVE_REQUEST)}'.`);
	                self.FrmResolve(self.FRM_RESOLVE_REQUEST, function(rc) {
	                    const success = rc === 0;
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. UtilityService::removeTransparentWindowColor result: ${rc}`);
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityService::removeTransparentWindowColor gets " + (success ? "resolved" : "rejected"));
	                    success ? resolve() : reject("UtilityService::removeTransparentWindowColor returned error");
	                });
	            });
	        }

	        /**
	         * Uses the given color identifier (either in string format (#ffffff) or object {r:0,g:0,b:0} to set the color used for transparency of the browser window)
	         * Please mind that this function might not work on any browser used! Please refer to the Operation and User manual for more information.
	         * @param {string|object} hashHexColorOrRGB given as "#FFEE33" or object {r:0,g:0,b:0}
	         * @param {int} hashHexColorOrRGB.r red value 0-255
	         * @param {int} hashHexColorOrRGB.g green value 0-255
	         * @param {int} hashHexColorOrRGB.b blue value 0-255
	         * @returns {Promise}
	         */
	        setTransparentWindowColor(hashHexColorOrRGB) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> UtilityService::setTransparentWindowColor(${JSON.stringify(hashHexColorOrRGB)})`);
	            function getColorRef(hex) {
	                let result;
	                let colorRef;
	                if (typeof hex === "string") {
	                    result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	                    result = result
	                        ? {
	                            r: parseInt(result[1], 16),
	                            g: parseInt(result[2], 16),
	                            b: parseInt(result[3], 16)
	                        }
	                        : null;
	                } else {
	                    result = hex;
	                }
	                if (result && typeof result.r === "number" && typeof result.g === "number" && typeof result.b === "number") {
	                    colorRef = result.r | (result.g << 8) | (result.b << 16);
	                }
	                return colorRef;
	            }

	            const self = this;
	            const color = getColorRef(hashHexColorOrRGB);
	            if (color !== void 0) {
	                return ext.Promises.promise(function(resolve, reject) {
	                    self.FRM_RESOLVE_REQUEST.FWName = Wincor.UI.Service.Provider.ConfigService.configuration.instanceName;
	                    self.FRM_RESOLVE_REQUEST.FWFuncID = 4028; // UI method setTransparency
	                    self.FRM_RESOLVE_REQUEST.param1 = color;
	                    self.FRM_RESOLVE_REQUEST.meta1 = ["ULONG", 0];
	                    self.FRM_RESOLVE_REQUEST.param2 = "";
	                    self.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	                    self.FRM_RESOLVE_REQUEST.param3 = "";
	                    self.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	                    self.FRM_RESOLVE_REQUEST.param4 = "";
	                    self.FRM_RESOLVE_REQUEST.meta4 = ["NULL", 0];
	                    self.FRM_RESOLVE_REQUEST.paramUL = 0;
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(self.FRM_RESOLVE_REQUEST)}'.`);
	                    self.FrmResolve(self.FRM_RESOLVE_REQUEST, function(rc) {
	                        const success = rc === 0;
	                        _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. UtilityService::setTransparentWindowColor result: ${JSON.stringify(rc)}`);
	                        _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityService::setTransparentWindowColor gets " + (success ? "resolved" : "rejected"));
	                        success ? resolve() : reject("UtilityService::setTransparentWindowColor returned error");
	                    });
	                });
	            }
	            return ext.Promises.Promise.reject(`UtilityService::setTransparentWindowColor could not calculate COLORREF - maybe invalid input -> ${JSON.stringify(hashHexColorOrRGB)}`);
	        }

	        /**
	         * Saves image data to the filesystem using native UI component.
	         * File format is checked by the native component and call is rejected for invalid / corrupt data.
	         * @param {string} fileName Name without extension. If the name starts with a slash, it will be appended to imageStoreRoot (%PROTOPAS_ROOT%/WORK/...) folder and the imageStore config is not used!
	         *                 Using this variant, the caller can decide whether to store the image in TEMP_TRANSACTION or TEMP_SESSION (plus subfolders if desired)
	         *                 Otherwise the configurable imageStore location is used (defaults to %PROTOPAS_ROOT%/WORK/TEMP_TRANSACTION if not configured in registry).
	         *                 Please note: ImageStore locations are only valid within %PROTOPAS_ROOT%/WORK/TEMP_TRANSACTION or %PROTOPAS_ROOT%/WORK/TEMP_SESSION! Subfolders have to be created before usage!
	         * @param {string} imageData base64 coded
	         * @param {string} srcFileType
	         * @param {string=} id
	         * @param {string=} targetFileType
	         * @param {boolean=} base64Encoded
	         * @returns {Promise}
	         */
	        saveImageToFile(fileName, imageData, srcFileType, id, targetFileType, base64Encoded) {
	            const self = this;
	            if (base64Encoded === void 0) {
	                base64Encoded = true; //default
	            }
	            targetFileType = targetFileType || this.targetFileType;
	            return ext.Promises.promise(function(resolve, reject) {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> UtilityService::saveImageToFile(${fileName},... ,${srcFileType}, ${targetFileType}, ${base64Encoded})`);
	                if (fileName.indexOf("..") > -1) {
	                    const err = `UtilityService::saveImageToFile: '${fileName}' - Traversing backwards is not allowed for image store!`;
	                    _logger.error(err);
	                    reject(err);
	                    return;
	                }

	                let srcFileName;
	                let targetFileName;

	                if (fileName[0] === "/" || fileName[0] === "\\") {
	                    srcFileName = self.imageStoreRoot + fileName + "." + srcFileType;
	                    targetFileName = self.imageStoreRoot + fileName + "." + targetFileType;
	                } else {
	                    srcFileName = self.imageStore + fileName + "." + srcFileType;
	                    targetFileName = self.imageStore + fileName + "." + targetFileType;
	                }

	                self.sendRequest(
	                    Object.assign({}, Wincor.UI.Gateway.prototype.REQUEST, {
	                        service: self.NAME,
	                        methodName: "SaveFile",
	                        path: srcFileName,
	                        content: imageData,
	                        isBase64: base64Encoded
	                    }),
	                    function(result) {
	                        if (result !== 0) {
	                            reject("UtilityService::saveImageToFile: gui::SaveFile returned error");
	                        } else {
	                            if (self.savedFiles.indexOf(srcFileName) === -1) {
	                                self.savedFiles.push(srcFileName);
	                            }
	                            if (targetFileType && srcFileType.toLowerCase() === targetFileType.toLowerCase()) {
	                                self.PATHS[id] = srcFileName;
	                                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< UtilityService::saveImageToFile returned: ${result}`);
	                                resolve();
	                            } else {
	                                self.convertFileType(srcFileName, srcFileType, targetFileName, targetFileType)
	                                    .then(() => {
	                                        if (self.savedFiles.indexOf(targetFileName) === -1) {
	                                            self.savedFiles.push(targetFileName);
	                                        }
	                                        self.PATHS[id] = targetFileName;
	                                        _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< UtilityService::saveImageToFile returned: ${result}`);
	                                    })
	                                    .then(resolve, reject);
	                            }
	                        }
	                    }
	                );
	            });
	        }

	        /**
	         * This method runs an action of the transaction components
	         * @param {string} action Name of the activity to start
	         * @param {Array} args Arguments for this activity as array
	         * @returns {Promise} Resolving to rc of the flow
	         */
	        runAction(action, args = []) {
	            var self = this;

	            return ext.Promises.promise(function(resolve, reject) {
	                function actionCallback(result) {
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. | FLOW < ${action}, ${args} returned ${result}`);
	                    // decouple removing of this responseMap-entry
	                    _logger.log(_logger.LOG_SRVC_INOUT, `< FlowService::runAction returns ${result})`);
	                    setTimeout(() => {
	                        if (result >= 0) {
	                            resolve(result);
	                        } else {
	                            reject();
	                        }
	                    }, 1);
	                }

	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> FlowService::runAction(${action}, ${args})`);
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. | FLOW > ${action}, ${args}`);

	                if (typeof action !== "string" || args === void 0) {
	                    _logger.error(". | FLOW  ERROR INVALID ARGUMENTS!");
	                    reject();
	                }

	                if (!Array.isArray(args)) {
	                    args = [args];
	                    _logger.error(`. | FLOW  arguments not given as array - assuming ${args}`);
	                }

	                self.FRM_ASYNC_RESOLVE_REQUEST.FWFuncID = 8;
	                self.FRM_ASYNC_RESOLVE_REQUEST.param1 = `PROFLEX4_UI_UTILITY_SERVICE${" ".repeat(64 - "PROFLEX4_UI_UTILITY_SERVICE".length)}`; //64 bytes                                         ";//64 bytes
	                self.FRM_ASYNC_RESOLVE_REQUEST.meta1 = ["CHAR_ANSI", -1];
	                self.FRM_ASYNC_RESOLVE_REQUEST.param2 = action;
	                self.FRM_ASYNC_RESOLVE_REQUEST.meta2 = ["CHAR_ANSI", -1];
	                self.FRM_ASYNC_RESOLVE_REQUEST.param3 = args.join();
	                self.FRM_ASYNC_RESOLVE_REQUEST.meta3 = ["CHAR_ANSI", -1];
	                self.FRM_ASYNC_RESOLVE_REQUEST.paramUL = 0;
	                self.FrmResolve(self.FRM_ASYNC_RESOLVE_REQUEST, actionCallback);
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< FlowService::runAction");
	            });
	        }

	        /**
	         * Returns an array of [DEVICE_STATE, INSTALL_STATE] values for a given device
	         * @param {string} deviceName
	         * @async
	         */
	        async getDeviceState(deviceName) {
	            _logger.log(_logger.LOG_SRVC_DATA, `> UtilityService::getDeviceState(${deviceName})`);
	            let res = await ext.Promises.promise((resolve, reject) => {
	                this.FRM_RESOLVE_REQUEST.FWName = "CCErrMgrFW";
	                this.FRM_RESOLVE_REQUEST.FWFuncID = 7; // GetDeviceState
	                this.FRM_RESOLVE_REQUEST.param1 = deviceName;
	                this.FRM_RESOLVE_REQUEST.meta1 = ["CHAR_ANSI", -1];
	                this.FRM_RESOLVE_REQUEST.param2 = -1;
	                this.FRM_RESOLVE_REQUEST.meta2 = ["SHORT", 0];
	                this.FRM_RESOLVE_REQUEST.param3 = -1;
	                this.FRM_RESOLVE_REQUEST.meta3 = ["SHORT", 0];
	                this.FRM_RESOLVE_REQUEST.param4 = "";
	                this.FRM_RESOLVE_REQUEST.meta4 = ["NULL", 0];
	                this.FRM_RESOLVE_REQUEST.paramUL = 0;
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	                this.FrmResolve(this.FRM_RESOLVE_REQUEST, function(result) {
	                    result.RC === 0 ? resolve([result.param2, result.param3]) : reject();
	                });
	            });
	            _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `< UtilityService::getDeviceState returns: ${res}`);
	            return res;
	        }
	        
	        /**
	         * This method runs a subFlow of the business logic and returns the result by means of resolving the returned promise
	         * @param {string} flowName Arguments for this activity as an array
	         * @returns {Promise} Resolving to rc of the flow
	         * @async
	         */
	        async callFlow(flowName) {
	            const CALL_SCRIPT = "CALL_SCRIPT";
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> UtilityService::callFlow(${CALL_SCRIPT}, ${flowName})`);
	            _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. | FLOW > ${CALL_SCRIPT}, ${flowName}`);
	            const rc = await this.runAction(CALL_SCRIPT, [flowName]);
	            _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `< UtilityService::callFlow (${CALL_SCRIPT}, ${flowName} returns ${rc}`);
	            return rc;
	        }

	        /**
	         * This function is used to delete the images saved to the configured folders when a customer session ends
	         * @returns {*|Promise.<T>}
	         */
	        clearImageStore() {
	            const self = this;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityService::clearImageStore()");
	            if (this.savedFiles.length === 0) {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityService::clearImageStore store was empty");
	                return ext.Promises.Promise.resolve();
	            }
	            _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, ". processing: " + this.savedFiles);
	            return ext.Promises.serializeProcessing(this.savedFiles, function(fileName) {
	                return ext.Promises.promise(function(resolve, reject) {
	                    self.sendRequest(
	                        Object.assign({}, Wincor.UI.Gateway.prototype.REQUEST, {
	                            service: self.NAME,
	                            methodName: "DeleteFile",
	                            path: fileName
	                        }),
	                        function(result) {
	                            // clear paths anyways
	                            if (!result) {
	                                const reason = "Could not delete one or more of files: " + self.savedFiles;
	                                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `. UtilityService::clearImageStore error: ${reason}`);
	                                reject(reason);
	                            } else {
	                                resolve(result);
	                            }
	                            self.savedFiles = [];
	                            self.PATHS = {};
	                        }
	                    );
	                });
	            }).finally(() => {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityService::clearImageStore");
	            });
	        }

	        /**
	         * Adds a filter for tracing private information
	         * @param {string|number} filter
	         * @return {Promise<number>} error on negative values
	         */
	        addTraceFilter(filter) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityService::addTraceFilter()");
	            const dataType = typeof filter;
	            if (dataType !== "string") {
	                // convert to string but write error-log for all others than number data-type
	                filter = filter.toString();
	                if (dataType !== "number") {
	                    this.logger.error(`UtilityService::addTraceFilter() got unsupported argument type [${dataType}]`);
	                }
	            }
	            return ext.Promises.promise(resolve => {
	                this.sendRequest(
	                    Object.assign({}, Wincor.UI.Gateway.prototype.REQUEST, {
	                        service: this.NAME,
	                        methodName: "SetFilter",
	                        filter: filter
	                    }),
	                    function(result) {
	                        if (result < 0) {
	                            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `. UtilityService::addTraceFilter error adding filter`);
	                        }
	                        // an error may occur if the filter-string is too short, but this should not break the chain
	                        resolve(result);
	                    }
	                );
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityService::addTraceFilter");
	            });
	        }

	        /**
	         * Tries to stop the DM campaign
	         * @returns {Promise}
	         */
	        dmStop() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> UtilityService::dmStop`);

	            this.FRM_ASYNC_RESOLVE_REQUEST.FWName = "DMSYNC";
	            this.FRM_ASYNC_RESOLVE_REQUEST.FWFuncID = 4005;
	            this.FRM_ASYNC_RESOLVE_REQUEST.param1 = "";
	            this.FRM_ASYNC_RESOLVE_REQUEST.meta1 = ["NULL", 0];
	            this.FRM_ASYNC_RESOLVE_REQUEST.param2 = "";
	            this.FRM_ASYNC_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	            this.FRM_ASYNC_RESOLVE_REQUEST.param3 = "";
	            this.FRM_ASYNC_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	            this.FRM_ASYNC_RESOLVE_REQUEST.paramUL = 0;
	            return ext.Promises.promise((resolve, reject) => {
	                this.FrmResolve(this.FRM_ASYNC_RESOLVE_REQUEST, result => {
	                    // check result
	                    if (result === 0) {
	                        // RC_OK - function has worked successfully
	                        _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `UtilityService::dmStop ... FrmResolve returned ${result}: RC_OK: DM session successfully stopped`);
	                        resolve(result);
	                    } else if (result === -10) {
	                        // RC_IGNORED - no DM session running that can be stopped
	                        _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `UtilityService::dmStop ... FrmResolve returned ${result}: RC_IGNORED: no DM session running that can be stopped`);
	                        resolve(result);
	                    } else if (result === -1) {
	                        // RC_ERROR - internal stop method will be called.
	                        // The effects of the stop function should be the same like the positive case without errors
	                        _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `UtilityService::dmStop ... FrmResolve returned ${result}: RC_ERROR: internal stop method will be called`);
	                        resolve(result);
	                    } else {
	                        _logger.LOG_ERROR && _logger.log(_logger.LOG_ERROR, `UtilityService::dmStop ... FrmResolve returned ${result}: unexpected error`);
	                        reject(result);
	                    }
	                });
	                this.FRM_ASYNC_RESOLVE_REQUEST.FWName = "CCTransactionFW";
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< UtilityService::dmStop`);
	            });
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseService#onServicesReady}
	         * Reads the configuration for Services//UtilityService
	         *
	         * @async
	         * @lifecycle service
	         */
	        async onServicesReady() {
	            const configSvc = Wincor.UI.Service.Provider.ConfigService;
	            const eventSvc = Wincor.UI.Service.Provider.EventService;

	            eventSvc.whenReady.then(() => {
	                const TXN_EVENTS = eventSvc.getEventInfo("TRANSACTION_MODULE");
	                eventSvc.registerForEvent(
	                    TXN_EVENTS.ID_SESSION_END,
	                    TXN_EVENTS.NAME,
	                    () => {
	                        setTimeout(() => {
	                            this.clearImageStore();
	                            this.fireServiceEvent(this.SERVICE_EVENTS.SESSION_END, {});
	                        }, 1);
	                    },
	                    void 0,
	                    "ASCII",
	                    true
	                );
	            });
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityService::onServicesReady()");

	            const generalSection = `${configSvc.configuration.instanceName}\\Services\\UtilityService`;
	            const IMAGE_STORE = "ImageStore";
	            const IMAGE_DEFAULT_TARGET_FILE_TYPE = "ImageDefaultTargetFileType";
	            const keys = [IMAGE_STORE, IMAGE_DEFAULT_TARGET_FILE_TYPE];

	            let result = await configSvc.getConfiguration(generalSection, keys);
	            if (result[IMAGE_STORE]) {
	                this.imageStore = result[IMAGE_STORE];
	                if (this.imageStore[this.imageStore.length - 1] !== "/") {
	                    this.imageStore += "/";
	                }
	            }
	            _logger.log(_logger.LOG_ANALYSE, `* UtilityService::onServicesReady(): imageStore=${this.imageStore}`);

	            if (result[IMAGE_DEFAULT_TARGET_FILE_TYPE]) {
	                this.targetFileType = result[IMAGE_DEFAULT_TARGET_FILE_TYPE];
	                if (!(this.targetFileType in this.IMG_FORMAT)) {
	                    _logger.error(
	                        "* UtilityService::onServicesReady invalid config: ImageDefaultTargetFileType=" +
	                        this.targetFileType +
	                            " - resetting to 'bmp'\nPlease refer to the documentation of CCImgConv.dll for valid types"
	                    );
	                    this.targetFileType = "bmp";
	                }
	            }
	            _logger.log(_logger.LOG_ANALYSE, `* UtilityService::onServicesReady(): imageStore=${this.imageStore}`);
	             await super.onServicesReady();
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityService::onServicesReady");
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ UtilityServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$4 = getServiceClass$6({
	    Wincor: Wincor$2,
	    ext: ext$2,
	    LogProvider,
	    PTService
	});

	const ServiceInterface$4 = {
	    UtilityProxy: {
	        service: '../service/wn.UI.Service.UtilityService.js',
	        interface: {
	            SERVICE_EVENTS: {
	                type: 'object',
	                keys: ['SESSION_END'],
	                writable: false
	            },
	            PATHS: {
	                type: 'object',
	                writable: false
	            },
	            WORKING_DIRS: {
	                type: 'object',
	                writable: false
	            },
	            setTransparentWindowColor: {
	                type: 'function'
	            },
	            removeTransparentWindowColor: {
	                type: 'function'
	            },
	            saveImageToFile: {
	                type: 'function'
	            },
	            callFlow: {
	                type: 'function'
	            },
	            runAction: {
	                type: 'function'
	            },
	            addTraceFilter: {
	                type: 'function'
	            },
	            dmStop: {
	                type: 'function'
	            },
	            getDeviceState: {
	                type: 'function'
	            },
	            DEVICE_STATE: {
	                type: 'object',
	                writable: false
	            },
	            INSTALL_STATE: {
	                type: 'object',
	                writable: false
	            }
	        }
	    }
	};

	var UtilityService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$4,
		ServiceClass: ServiceClass$4
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.ControlPanelServiceMock.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$7 = ({ Wincor, ext, BaseService, LogProvider }) => {

	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;

	    let _controlPanel = null;

	    return class ControlPanelServiceMock extends BaseService {
	        /**
	         * The logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         * @default "ControlPanelService"
	         */
	        NAME = "ControlPanelService";

	        /**
	         * @see {@link Wincor.UI.Service.ViewService#SERVICE_EVENTS}.
	         * @enum {string}
	         */
	        SERVICE_EVENTS = {
	            /**
	             * Fired when a local timer has been newed.
	             */
	            NEW_TIMEOUT: "NEW_TIMEOUT",
	        };

	        /**
	         * @see {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.log(_logger.LOG_SRVC_INOUT, "> ControlPanelServiceMock::ControlPanelServiceMock");
	            _logger.log(_logger.LOG_SRVC_INOUT, "< ControlPanelServiceMock::ControlPanelServiceMock");
	        }
	        
	        /**
	         * Sets the control panel.
	         * @param {Object} panel the panel window
	         */
	        setControlPanel(panel) {
	            _controlPanel = panel;
	        }

	        /**
	         * Gets the control panel.
	         * @return {Object} the control panel window object
	         */
	        getControlPanel() {
	            return _controlPanel;
	        }

	        /**
	         * Gets the control panel context.
	         * @return {Object} the control panel context object
	         */
	        getContext() {
	            return (_controlPanel && _controlPanel.getContext && _controlPanel.getContext()) || {};
	        }

	        /**
	         * Updates the business properties of the control panel.
	         * @param {Map} propMap the property map contains a map of property keys and values
	         */
	        updateBusinessProperties(propMap) {
	            if (_controlPanel && _controlPanel.businessPropertiesUpdate) {
	                _controlPanel.businessPropertiesUpdate(propMap);
	            }
	        }

	        /**
	         * Should be called when a new local timer has been started.
	         * @param {Number} timeLen the time length
	         */
	        newTimerStarted(timeLen) {
	            this.fireServiceEvent(this.SERVICE_EVENTS.NEW_TIMEOUT, timeLen);
	        }

	        /**
	         * @see {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         *
	         * @param {Object} message      See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onSetup(message) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ControlPanelServiceMock::onSetup('${JSON.stringify(message)}')`);
	            return ext.Promises.promise(resolve => {
	                resolve();
	                _logger.log(_logger.LOG_SRVC_INOUT, "< ControlPanelServiceMock::onSetup");
	            });
	        }

	        /**
	         * @see {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}
	         * @async
	         * @lifecycle service
	         */
	        async onServicesReady() {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '> ControlPanelServiceMock::onServicesReady()');
	            await super.onServicesReady();
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '< ControlPanelServiceMock::onServicesReady');
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.BaseServiceMock.js 4.3.1-210614-21-db8848bb-1a04bc7d

	*/
	let _configService,_controlPanelService,_logger$3,_formatService=null,_viewKey="",_viewCtx={},_textKeys=null;const _serviceEventObjMap$1={},_eventDelegatesMap$1=new Map;let _serviceReadyEventRegisteringDone$1=!1;function replaceAt(e,t,r,i){return e&&e.length<524288&&r>t&&t<=e.length&&r<=e.length?`${e.substring(0,t)}${i}${e.substring(r)}`:e}const getServiceClass$8=({Wincor:e,ext:t,jQuery:r,LogProvider:i,GatewayProvider:s,Gateway:o})=>class n{NAME="";DISPOSAL_TRIGGER_DEACTIVATE="DEACTIVATE";DISPOSAL_TRIGGER_UNLOAD="UNLOAD";DISPOSAL_TRIGGER_ONETIME="ONETIME";DISPOSAL_TRIGGER_SHUTDOWN="SHUTDOWN";SERVICE_EVENTS=null;EVENT=null;logger=null;whenReady=null;_registrationId=0;ready=!1;responseTimeSimulation=1;requestMap=null;currentLanguageName="English";ERROR_TYPE={REQUEST:"REQUEST",RESPONSE:"RESPONSE",EVENT:"EVENT",OTHER:"OTHER"};EventRegistration=function(){this.registrationId=-1,this.callback=null,this.persistent=!1,this.trigger=null;};constructor(t,{ServiceProvider:r}){this.NAME=t,this.serviceProvider=r,this.logger=i,_logger$3=i;let s="";_logger$3.LOG_SRVC_INOUT&&arguments&&arguments.length>2&&(s=`, ${Object.values(arguments).slice(2)}`),_logger$3.log(_logger$3.LOG_SRVC_INOUT,`> BaseServiceMock::BaseServiceMock[${this.NAME}](${t}, ServiceProvider: ${r}${s})`),this.requestMap=new Map,e.toolingEDM?this.EVENT=Object.assign({},o.prototype.EVENT):this.EVENT={},this.whenReady=null,this._registrationId=0,_logger$3.log(_logger$3.LOG_SRVC_INOUT,`< BaseServiceMock::BaseServiceMock[${this.NAME}]`);}setViewCtx(e){_viewCtx=e;}getViewCtx(){return _viewCtx}setViewKey(e){_viewKey=e;}getViewKey(){return _viewKey}convertToBoolean(e){return !!e&&(!0===e||(isNaN(e)?"true"===e.toLowerCase():parseInt(e)>0))}retrieveJSONData(e){return _textKeys=null,t.Promises.promise(((t,i)=>r.getJSON(-1===e.lastIndexOf(".json")?e+".json":e,t).fail((e=>i(e)))))}installServiceEvents(){this.SERVICE_EVENTS&&"object"==typeof this.SERVICE_EVENTS&&(Object.keys(this.SERVICE_EVENTS).forEach((e=>{if(e in _serviceEventObjMap$1)throw `${this.NAME} tried to install SERVICE_EVENT ${e}, but this is already installed by ${_serviceEventObjMap$1[e]}`;_serviceEventObjMap$1[e]=this.NAME;})),_logger$3.LOG_SRVC_DATA&&_logger$3.log(_logger$3.LOG_SRVC_DATA,`. Service::installServiceEvents[${this.NAME}]${JSON.stringify(this.SERVICE_EVENTS)} succeeded.`));}registerForServiceEvent(t,r,i){_logger$3.log(_logger$3.LOG_SRVC_INOUT,`> BaseServiceMock::registerForServiceEvent[${this.NAME}](${t}, ..., persistent: ${i})`);try{if(t in _serviceEventObjMap$1&&r){let e=new this.EventRegistration;return this._registrationId++,e.registrationId=this._registrationId,"string"==typeof i?i!==this.DISPOSAL_TRIGGER_DEACTIVATE&&i!==this.DISPOSAL_TRIGGER_UNLOAD&&i!==this.DISPOSAL_TRIGGER_ONETIME&&i!==this.DISPOSAL_TRIGGER_SHUTDOWN||(e.trigger=i,i=!1):("boolean"==typeof i||(i=!1),e.trigger=this.DISPOSAL_TRIGGER_DEACTIVATE),e.callback=r,e.persistent=i,_eventDelegatesMap$1.has(t)?_eventDelegatesMap$1.get(t).push(e):_eventDelegatesMap$1.set(t,[e]),_logger$3.log(_logger$3.LOG_SRVC_INOUT,`< BaseServiceMock::registerForServiceEvent[${this.NAME}] returns regId: ${this._registrationId}`),this._registrationId}_logger$3.log(_logger$3.LOG_ANALYSE,`. BaseServiceMock::registerForServiceEvent[${this.NAME}] WARNING: Could not register for serviceEventName=${t}`);}catch(t){e.UI.Service.Provider.propagateError(this.NAME,this.ERROR_TYPE.OTHER,t);}return -1}deregisterServiceEvents(e,t){_logger$3.log(_logger$3.LOG_SRVC_INOUT,`> BaseServiceMock::deregisterServiceEvents[${this.NAME}](trigger: ${e}, eventName: ${t})`);let r,i,s,o=0;for(let[n,l]of _eventDelegatesMap$1){for(r=l.length-1;r>=0;r--)i="string"!=typeof t||t===n,s=l[r],!s.persistent&&s.trigger===e&&i&&(_logger$3.log(_logger$3.LOG_DETAIL,`. removing ${n} regId< ${s.registrationId} > of ${this.NAME}`),s.callback=null,l.splice(r,1),0===l.length&&_eventDelegatesMap$1.delete(n));l&&(o+=l.length);}_logger$3.log(_logger$3.LOG_SRVC_INOUT,`< BaseServiceMock::deregisterServiceEvents[${this.NAME}] delegatesLeft: ${o}`);}deregisterFromServiceEvent(e){let t,r;_logger$3.log(_logger$3.LOG_SRVC_INOUT,"> BaseServiceMock::deregisterFromServiceEvents()");let i=void 0===e;for(let[s,o]of _eventDelegatesMap$1){for(t=o.length-1;t>=0;t--)if(r=o[t],(i||r.registrationId===e)&&(r.callback=null,o.splice(t,1),!i))return _logger$3.log(_logger$3.LOG_SRVC_INOUT,"< BaseServiceMock::deregisterFromServiceEvents returns: true"),!0;0===o.length&&_eventDelegatesMap$1.delete(s);}return _logger$3.log(_logger$3.LOG_SRVC_INOUT,"< BaseServiceMock::deregisterFromServiceEvents returns: "),!0}fireServiceEvent(e,t){_logger$3.log(_logger$3.LOG_SRVC_INOUT,`> BaseServiceMock::fireServiceEvent[${this.NAME}](serviceEventName: ${e}, data: ${t})`);let r=!1;if(_serviceEventObjMap$1[e]===this.NAME){if(_eventDelegatesMap$1.has(e)){let i=_eventDelegatesMap$1.get(e);for(let e=i.length-1;e>=0;e--)"function"==typeof i[e].callback&&(r|=i[e].callback(t));this.deregisterServiceEvents(this.DISPOSAL_TRIGGER_ONETIME,e);}}else _logger$3.error(`BaseServiceMock::fireServiceEvent Error! Not allowed! ${this.NAME} tried to send foreign SERVICE_EVENT ${e}!`);return _logger$3.log(_logger$3.LOG_SRVC_INOUT,`< BaseServiceMock::fireServiceEvent[${this.NAME}]`),r}onSetup(e){return t.Promises.Promise.resolve()}onServicesReady(){_logger$3.log(_logger$3.LOG_SRVC_INOUT,"> BaseServiceMock::onServicesReady()"),this.ready=!0;const e=this.serviceProvider.ViewService;return e&&!_serviceReadyEventRegisteringDone$1&&(this.registerForServiceEvent(e.SERVICE_EVENTS.VIEW_CLOSING,(()=>{this.deregisterServiceEvents(this.DISPOSAL_TRIGGER_DEACTIVATE);}),!0),this.registerForServiceEvent(e.SERVICE_EVENTS.VIEW_BEFORE_CHANGE,(()=>{this.deregisterServiceEvents(this.DISPOSAL_TRIGGER_UNLOAD),this.deregisterServiceEvents(this.DISPOSAL_TRIGGER_ONETIME);}),!0),this.registerForServiceEvent(e.SERVICE_EVENTS.SHUTDOWN,(()=>{this.deregisterServiceEvents(this.DISPOSAL_TRIGGER_DEACTIVATE),this.deregisterServiceEvents(this.DISPOSAL_TRIGGER_UNLOAD),this.deregisterServiceEvents(this.DISPOSAL_TRIGGER_ONETIME),this.deregisterServiceEvents(this.DISPOSAL_TRIGGER_SHUTDOWN);}),!0),_serviceReadyEventRegisteringDone$1=!0),_formatService=this.serviceProvider.FormatService,_configService=this.serviceProvider.ConfigService,_controlPanelService=this.serviceProvider.ControlPanelService,_logger$3.log(_logger$3.LOG_SRVC_INOUT,"< BaseServiceMock::onServicesReady"),t.Promises.Promise.resolve()}generateSpecificResponse(e){return {}}callbackCaller(e){e&&window.setTimeout((()=>e(this.generateSpecificResponse.bind(this)())),this.responseTimeSimulation);}async getToolingProfile(){_logger$3.LOG_ANALYSE&&_logger$3.log(_logger$3.LOG_ANALYSE,"> | VIEW ViewServiceMock::getToolingProfile");let e=["",""];try{let t=await this.retrieveJSONData("../servicemocks/mockdata/profiles");_logger$3.LOG_ANALYSE&&_logger$3.log(_logger$3.LOG_ANALYSE,`* ViewServiceMock::getToolingProfile = ${JSON.stringify(t)}`);let r=t.selectedProfile;void 0!==r&&(e=["profile","_"+r]);}catch(e){}return e}replaceInMapping(t,r){let i;Object.keys(t).forEach((s=>{let o=t[s];o&&"string"==typeof o&&o.includes("(#")?(i=o.split("#")[1],r[i]&&(t[s]=Object.assign({},r[i]),e.toolingEDM&&(r[i].isTemplate=!0,t[s].fromTemplateKey=i,void 0===r[i].targetViewKey&&(r[i].targetViewKey=s)))):"object"==typeof o&&Object.keys(o).forEach((e=>{let t=o[e];if("string"==typeof t){let i=t.split("#");for(let t=0;t<i.length;t++){let s=i[t];if(r[s]){let t=o[e];const i="(#"+s+"#)";let n=t.indexOf(i),l=n+i.length;o[e]=replaceAt(t,n,l,r[s]);}}}}));}));}replaceTemplateUsage(t,r){let i=!0;return Object.keys(t).forEach((s=>{let o=t[s].useTemplate;if(void 0!==o){let n=r[o];void 0!==n?(t[s]=Object.assign({},n),e.toolingEDM&&(n.isTemplate=!0,t[s].fromTemplateKey=o,void 0===n.targetViewKey&&(n.targetViewKey=s))):(_logger$3.error(`BaseServiceMock::replaceTemplateUsage Could not replace viewKey=${t.viewKey} with template=${o} for viewKey=${_viewKey}!`),i=!1);}})),i}getPropValue(t,r){let i=null,s=e.UI.Service.Provider.ViewService.viewContext.viewKey,o=t.key;if(!o.startsWith(_configService.configuration.instanceName)&&o in r){if(s=s in r[o]?s:"*",s in r[o])if(-1===t.idx){let e=Array.isArray(r[o][s])?r[o][s][0]:r[o][s];i=t.attrChain?this.getValueFromJSON(e,t.attrChain):e;}else i=t.attrChain?Array.isArray(r[o][s])?this.getValueFromJSON(r[o][s][t.idx],t.attrChain):this.getValueFromJSON(r[o][s],t.attrChain):Array.isArray(r[o][s])?r[o][s][t.idx]:r[o][s];null==i?i=-1:Array.isArray(i)&&i.length&&(i=i[0]);}else i=this.serviceProvider.DataService.getPropertyString({propertyName:o,propertyValue:""})||-1;if(-1!==i){let e=this.buildKeyFromParts(t);e.includes("[0]")&&!e.includes(".")&&(e=e.substr(0,e.indexOf("[0]"))),_controlPanelService.updateBusinessProperties(new Map([[e,i]]));}return i}getTextValue(e,t){e=e.toLowerCase();const r=_textKeys||(_textKeys=Object.keys(t)),i=r.length;for(let s=0;s<i;s++)if(e===`${r[s]}`.toLowerCase())return this.getTextFromObj(t[r[s]]);return -1}getTextFromObj(e){if("object"==typeof e){let t=e[this.currentLanguageName];(e=t||e.General)||(e="");}if("object"==typeof e)try{e=JSON.stringify(e);}catch(t){_logger$3.error(`BaseServiceMock::getTextFromObj: Value isn't a JSON notated object which was expected at least.${t} for viewKey=${_viewKey}`),e="N/A";}return e.toString()}isIndexedPropertyKey(e){return null!=e&&e.includes("[")&&e.includes("]")&&!e.includes("[A")}extractPropertiesFromText(e){let t=[];if(e){let r,i,s;do{r=e.indexOf("[&"),i=e.indexOf("&]")+"&]".length,-1!==r&&-1!==i&&(s=e.substring(r,i),s=s.substring("[&".length,s.indexOf(";")),t.includes(s)||t.push(s),e=e.substring(i,e.length));}while(e&&-1!==r&&-1!==i)}return t}extractKeyPartsFromProperty(e){let t={key:e||"",idx:-1,attrChain:null};if(e&&this.isIndexedPropertyKey(e)&&(t.key=e.substring(0,e.indexOf("[")),t.idx=parseInt(e.substring(e.indexOf("[")+1,e.indexOf("]"))),t.idx=isNaN(t.idx)?-1:t.idx),e&&t.key.includes(".")){let e=t.key.split(".");t.key=e[0],e.shift(),t.attrChain=e;}return t}buildKeyFromParts(e){let t="";return e&&(t=`${e.key}${e.attrChain?"."+e.attrChain.join("."):""}${-1!==e.idx?`[${e.idx}]`:""}`),t}getValueFromJSON(e,t){let r=e;if(Array.isArray(t))try{r=t.reduce(((e,t)=>{if(e&&t in e)return e[t]}),JSON.parse(e));}catch(t){_logger$3.error(`BaseServiceMock::getValueFromJSON: Error data access via property with attribute notation expects a JSON value=${e} Error: ${t} for viewKey=${_viewKey}`);}return r?"object"==typeof r?JSON.stringify(r):r:e}setValueFromJSON(e,t,r){if(Array.isArray(t))try{e=JSON.parse(e);let i=t.length,s=0;t.reduce(((e,t)=>{if(e&&t in e){if(s!==i-1)return s++,e[t];if("string"==typeof r&&(r.startsWith("{")||r.startsWith("[")))try{r=JSON.parse(r);}catch(e){}e[t]=r;}}),e),e=JSON.stringify(e);}catch(t){_logger$3.error(`BaseServiceMock::setValueFromJSON: Error data access via property with attribute notation expects a JSON value=${e} Error: ${t} for viewKey=${_viewKey}`);}return e}propResolver(t,r,i,s){let o=s||0;if(50===o)return _logger$3.error(`BaseServiceMock::propResolver: Invalid token=${t} too many property keys - limit is 50 or even wrong template for viewKey=${_viewKey}!`),"";if("string"==typeof t){let s=t.indexOf("[&"),n=t.indexOf("&]",s)+"&]".length;if(-1===s||-1===n)return t;if(n<s)return _logger$3.error(`BaseServiceMock::propResolver: prop='${t.substring(s,n)}' for token='${t}' seems to be not a valid token for viewKey=${_viewKey}!`),"";let l=t.substring(s,n),g=l.substring("[&".length,l.indexOf(";")),a=this.extractKeyPartsFromProperty(g),_=l.substring(l.indexOf(";")+";".length,l.lastIndexOf(";")),E=l.substring(l.lastIndexOf(";")+";".length,l.indexOf("&]")),c=this.getPropValue(a,r);if(e.toolingEDM&&i&&-1===c&&!i.includes(g)&&i.push(g),c=-1!==c?c:E,_.length>0&&_formatService){let e={raw:c};_formatService.format(e,_,null,!0),c=e.result;}(t=replaceAt(t,s,n,c)).includes("[&")&&(o++,t=this.propResolver(t,r,i,o));}else _logger$3.error(`BaseServiceMock::propResolver: Invalid token=${t} which must be a string for viewKey=${_viewKey}!`),t="";return t}propResolverFromConditional(e,t,r){const i="EX:";let s=!1;if("string"==typeof e&&0===e.indexOf("P,")){let o=e.substring(e.indexOf("P,")+"P,".length,e.includes(i)?e.indexOf(",EX:"):e.length-1);s=function(e,t){let r=e===t;switch(t){case"SET":case"!EMPTY":r=null!=e&&""!==e;break;case"EMPTY":r=""===e;break;case"!SET":r=null===e;break;default:t.includes("![")?r=e!==(t=(t=t.substring("![".length)).substring(0,t.length-1)):0===t.indexOf("[")&&(r=e===(t=(t=t.substring("[".length)).substring(0,t.length-1)));}return r}(this.propResolver(`[&${o};;&]`,t,r),e.includes(i)?e.substring(e.indexOf(i)+i.length):"");}return s}static#isWXTextValid(e){let t=!0;if("string"==typeof e){let r=e.split("[%WX_TEXT[").length-1;r=r+e.split("[%IF_TEXT[").length-1,t=r===e.split("%]").length-1;}return t}static#findWXTextEndTag(e,t=0){function r(t,r){let i=e.indexOf("[%WX_TEXT[",r),s=e.indexOf("[%IF_TEXT[",r),o=e.indexOf("%]",r),n=[-1,""];return -1!==i&&i<o&&(i<s&&-1!==s||i>s&&-1===s)?(n[0]=i,n[1]="[%WX_TEXT[",n):-1!==s&&-1!==i&&s<i?(n[0]=s,n[1]="[%IF_TEXT[",n):(-1!==o&&(n[0]=o+"%]".length,n[1]="%]"),n)}let i=[-1],s=0,o=t;do{if(i=r(0,o),-1!==i[0])switch(i[1]){case"[%WX_TEXT[":s++,o=i[0]+"[%WX_TEXT[".length;break;case"[%IF_TEXT[":s++,o=i[0]+"[%IF_TEXT[".length;break;case"%]":s--,o=i[0];}}while(-1!==i[0]&&s>0);return i[0]}wxtKeyResolver(e,t,r,i,s){let o=i||0;if(150===o)return _logger$3.error(`BaseServiceMock::wxtKeyResolver: Invalid template=${e} too many WX_TEXT keys - limit is 150 or even wrong WX_TEXT template for viewKey=${_viewKey}!`),"";if(!n.#isWXTextValid(e))return _logger$3.error(`BaseServiceMock::wxtKeyResolver: Invalid template=${e} wrong WX_TEXT or IF_TEXT configuration found: Open tags [%WX_TEXT[/\n                           [%IF_TEXT[ not matching closing tags %], please check text config for viewKey=${_viewKey}!`),"";if("string"==typeof e){let i=e.indexOf("[%WX_TEXT["),l=e.indexOf("[%IF_TEXT["),g="[%WX_TEXT[";-1!==l&&(l<i||-1===i)&&(g="[%IF_TEXT[",i=l);let a=n.#findWXTextEndTag(e,i);if(-1===i||-1===a)return e;if(a<i)return _logger$3.error(`BaseServiceMock::wxtKeyResolver: wxTxt='${e.substring(i,a)}' for template='${e}'\n                               seems to be not a valid wx text template for viewKey=${_viewKey}!`),"";let _,E=e.substring(i,a),c=E.substring(g.length,E.indexOf(";")-";".length),v=E.substring(E.indexOf(";")+";".length,E.indexOf("%]"));v.includes("[%")&&(v=`${v}%]`),0===E.indexOf("[%IF_TEXT[")&&0===c.indexOf("P,")?(_=this.propResolverFromConditional(c,r,s),_=!0===_?"":v):_=this.getTextValue(c,t),_=-1!==_?_:v,e=replaceAt(e,i,a,_),((e=this.propResolver(e,r,s)).includes("[%WX_TEXT[")||e.includes("[%IF_TEXT["))&&(o++,e=this.wxtKeyResolver(e,t,r,o,s));}else _logger$3.error(`BaseServiceMock::wxtKeyResolver: Invalid template=${e} which must be a string for viewKey=${_viewKey}!`),e="";return e}onResponse(t){try{_logger$3.log(_logger$3.LOG_SRVC_INOUT,`> BaseServiceMock::onResponse('${JSON.stringify(t)}')`),_logger$3.log(_logger$3.LOG_SRVC_INOUT,"< BaseServiceMock::onResponse");}catch(t){e.UI.Service.Provider.propagateError(this.NAME,this.ERROR_TYPE.EVENT,t);}}onRequest(t){try{if(_logger$3.LOG_SRVC_INOUT&&_logger$3.log(_logger$3.LOG_SRVC_INOUT,`> BaseServiceMock::onRequest('${JSON.stringify(t)}')`),this.requestMap.has(t.methodName)){let e=this.requestMap.get(t.methodName);e?e(t):_logger$3.LOG_SRVC_DATA&&_logger$3.log(_logger$3.LOG_SRVC_DATA,`. delegate for method '${t.methodName}' is null.`);}else _logger$3.LOG_SRVC_DATA&&_logger$3.log(_logger$3.LOG_SRVC_DATA,`. No callback found for method '${t.methodName}'.`);_logger$3.LOG_SRVC_INOUT&&_logger$3.log(_logger$3.LOG_SRVC_INOUT,"< BaseServiceMock::onRequest");}catch(t){e.UI.Service.Provider.propagateError(this.NAME,this.ERROR_TYPE.EVENT,t);}}onEvent(t){try{_logger$3.log(_logger$3.LOG_SRVC_INOUT,`> BaseServiceMock::onEvent('${JSON.stringify(t)}')`),_logger$3.log(_logger$3.LOG_SRVC_INOUT,"< BaseServiceMock::onEvent");}catch(t){e.UI.Service.Provider.propagateError(this.NAME,this.ERROR_TYPE.EVENT,t);}}sendEvent(t){if(e.toolingEDM){const e=s.getGateway();return t=e&&e.sendEvent(t)}return {}}};

	const jQuery$3 = window.jQuery;
	const ext$3 = getExtensions({Wincor: Wincor$2, LogProvider});
	const Gateway$2 = getGateway({Wincor: Wincor$2, LogProvider});
	const Websocket$2 = getWebSocket({Wincor: Wincor$2, ext: ext$3, Gateway: Gateway$2});
	const GatewayProvider$2 = getGatewayProvider({Wincor: Wincor$2, LogProvider, Websocket: Websocket$2});
	const BaseService$1 = getServiceClass$8({Wincor: Wincor$2, ext: ext$3, jQuery: jQuery$3, LogProvider, GatewayProvider: GatewayProvider$2, Gateway: Gateway$2});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany
	 
	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.
	 
	 $MOD$ ControlPanelServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	 */

	const ServiceClass$5 = getServiceClass$7({
	    Wincor: Wincor$2,
	    ext: ext$3,
	    BaseService: BaseService$1,
	    LogProvider
	});


	const ServiceInterface$5 = {
	    "ControlPanelProxy": {
	        "service": "../servicemocks/wn.UI.Service.ControlPanelServiceMock.js",
	        "interface": {
	            "SERVICE_EVENTS": {
	                "type": "object",
	                "keys": [
	                    "NEW_TIMEOUT"
	                ],
	                "writable": false
	            },
	            "setControlPanel": {
	                "type": "function"
	            },
	            "getControlPanel": {
	                "type": "function"
	            },
	            "getContext": {
	                "type": "function"
	            },
	            "updateBusinessProperties": {
	                "type": "function"
	            },
	            "newTimerStarted": {
	                "type": "function"
	            }
	        }
	    }
	};

	var ControlPanelService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$5,
		ServiceClass: ServiceClass$5
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.



	$MOD$ wn.UI.Service.DataService.js 4.3.1-210212-21-06af7f4f-1a04bc7d
	 */

	/**
	 * @module
	 */
	const getServiceClass$9 = ({ Wincor, ext, LogProvider, PTService, UIPropertyKeyMap, BusinessPropertyKeyMap, BusinessPropertyCustomKeyMap }) => {
	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @const
	     * @private
	     */
	    const _logger = LogProvider;

	    const META_UTF8 = "PARLIST_UTF8";
	    const META_ANSI = "PARLIST_ANSI";
	    const BUFFER_LEN_UTF8 = 16000;
	    const BUFFER_LEN_ANSI = 8000;
	    const MAX_LEN_REQUESTED_KEYS = 131072; // 128KB
	    const MAX_LEN_REQUESTED_VALUES = 131072; // 128KB
	    const MAX_COUNT_REQUESTED_KEYS = 1024;

	    const VALUE_ARRAY_SEPARATOR = "_||_";
	    const VALUE_CHANGED_SEPARATOR = "_WNSEP_";
	    const KEY_ARRAY_INDICATOR = "[A]";
	    const PROP_INDEX_BEGIN_MARKER = "[";
	    const PROP_ATTRIBUTE_BEGIN_MARKER = ".";
	    return class DataService extends PTService {
	        /**
	         * The logical name of this service as used in the {@link Wincor.UI.Service.Provider}.
	         * @default DataService
	         * @const
	         * @type {string}
	         */
	        NAME = "DataService";

	        /**
	         * @type {Array<function(string):boolean>}
	         */
	        propertyHandler = null;

	        /**
	         * Structure containing the registered data keys
	         * @class
	         */
	        DataRegistration = function() {
	            /**
	             * The registered data keys of the business properties.
	             * @type {Array<string>}
	             */
	            this.keys = []; //the registered dataKeys

	            /**
	             * The key map may contain mapped business keys to original requested keys.
	             * E.g.: {"CCTAFW_PROP_CURRENCY": "PROP_CURRENCY_ISO"}
	             * @type {Object}
	             */
	            this.keyMap = {};

	            /**
	             * A callback function which is called when the dataChanged event is triggered
	             * @type {function}
	             */
	            this.onUpdate = null; //this callback is called when the dataChanged event is triggered

	            /**
	             * If registration is persistent (true), a content-page unload will not remove the registration, false otherwise.
	             * @type {boolean}
	             */
	            this.persistent = false; //if registration is persistent, a content-page unload will not remove the registration
	        };

	        /**
	         * Array containing elements of {@link Wincor.UI.Service.DataService#DataRegistration}.
	         * @type {Array}
	         */
	        dataArray = []; // [DataRegistration1, DataRegistration2, ... ]

	        /**
	         * Contains the business property keymap.
	         * @type {Object}
	         */
	        businessPropertyKeys = null;

	        /**
	         * Contains the UI specific property keys.
	         * @type {Object}
	         */
	        UIPropertyKeys = null;

	        /**
	         * The property request map.
	         * The map contain request id's with objects containing mapped properties.
	         * @example
	         * 4911:
	         * {
	         *      "CCTAFW_PROP_CURRENCY": "PROP_CURRENCY_ISO",
	         *      "CCTAFW_PROP_CURRENCY_EXPONENT": "PROP_CURRENCY_EXP"
	         * }
	         * @type {Map}
	         */
	        propRequestMap = null;

	        /**
	         * Initializes the member of this class.
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.PTService}.
	         */
	        constructor(...args) {
	            super(...args);
	            this.businessPropertyKeys = {};
	            this.UIPropertyKeys = {};
	            this.propRequestMap = new Map();
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> DataService::DataService");
	            this.FRM_RESOLVE_REQUEST.service = this.NAME;
	            this.FRM_RESOLVE_REQUEST.FWName = "CCDatDic";
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< DataService::DataService");
	        }

	        /**
	         * Called automatically as soon as there is an answer to an asynchronous ProTopas request. See {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * The response will be translated to the result expected by the requester.
	         *
	         * @param {Object} message    Response object, see {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * @returns {Object}               Depends on function
	         */
	        translateResponse(message) {
	            let ret = {};
	            try {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> DataService::translateResponse('${JSON.stringify(message)}')`);

	                //GETKEYS response
	                if(message.FWFuncID === 30) {
	                    if(message.RC === 0) {
	                        /*
	                         message.param1 has the keys,   i.e. [key1,   key2, ...]
	                         message.param2 has the values, i.e. [value1, value2, ...]
	                         message.param3 has the RCs, i.e. [RC1, RC2, ...]

	                         If 'key1' looks like 'PropName[A]' (i.e. with [A] at the end)
	                         then 'value1' will be a comma-separted list of values.
	                         This will be transferred into an array.

	                         getKeysResponse will be an object:
	                         getKeysResponse["key1"] = value1
	                         getKeysResponse["key2"] = value2
	                         getKeysResponse["key[A]"] = [value30, value32, value33, ...]
	                         ...
	                         */
	                        let response = {};
	                        for(let i in message.param1) {
	                            if(message.param1.hasOwnProperty(i)) {
	                                let key = message.param1[i].toString();
	                                //TODO: check RC? use null for invalid keys! same as LocalizeService.
	                                //if (message.param3[i].toString() === "0")
	                                //then response[key] = message.param2[i];
	                                //else response[key] = null;
	                                if(
	                                    key.indexOf(KEY_ARRAY_INDICATOR) === key.length - 3 || //if it ends with [A]
	                                    (key.indexOf("[A,") !== -1 && key.indexOf("]") === key.length - 1)
	                                ) {
	                                    //if it looks like [A,x]
	                                    response[key] = message.param2[i].split(VALUE_ARRAY_SEPARATOR);
	                                } else {
	                                    response[key] = message.param2[i];
	                                }
	                            }
	                        }
	                        ret = this.mapResponseKeys(response, message.callbackIdx); // replace business keys by the original requested mapped keys, if necessary
	                    }
	                } else if(message.FWFuncID === 31) {
	                    ret = message.RC; // always return rc
	                } else {
	                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. DataService::onResponse message with FWFuncID '${message.FWFuncID}' and RC = '${message.RC}' will not be evaluated.`);
	                }

	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< DataService::translateResponse returns: ${JSON.stringify(ret)}`);
	            } catch(e) {
	                // Provider writes error-log
	                Wincor.UI.Service.Provider.propagateError(this.NAME, this.ERROR_TYPE.RESPONSE, e);
	            }
	            return ret;
	        }

	        /**
	         * Gets a business property key map.
	         * @returns {Object} the property key map
	         */
	        getPropertyKeyMap() {
	            return this.businessPropertyKeys;
	        }

	        /**
	         * Gets a map with the given request id.
	         * @param {Number} reqId the request id from the original{@link Wincor.UI.Service.DataService#getValues} request
	         * @return {Object} the key map, if one found, or a plain object in case if not
	         */
	        getKeyMap(reqId) {
	            let mapVal = {};
	            if(this.propRequestMap.has(reqId)) {
	                mapVal = this.propRequestMap.get(reqId);
	            }
	            return mapVal;
	        }

	        /**
	         * Maps business keys which have to replaced by the original keys from request.
	         * If the given request id is exists the properties are mapped back into the given response.
	         * The map with request id is removed after mapping back.
	         * @param {Object} response the response which might containing business keys which we have to replace with the original keys from request
	         * @param {Number} reqId the request id from the original{@link Wincor.UI.Service.DataService#getValues} request
	         * @return {Object} the given response which might have mapped back property keys
	         */
	        mapResponseKeys(response, reqId) {
	            if(response && reqId && this.propRequestMap.has(reqId)) {
	                const mapVal = this.propRequestMap.get(reqId);
	                const respKeys = Object.keys(response);
	                const len = respKeys.length;
	                for(let i = 0; i < len; i++) {
	                    let key = respKeys[i]; // business key
	                    if(key in mapVal) {
	                        response[mapVal[key]] = response[key]; // add a new one with the original request key
	                        delete response[key]; // delete the one with the business key
	                    }
	                }
	                this.propRequestMap.delete(reqId); // finally delete mapping for that request id
	            }
	            return response;
	        }

	        /**
	         * Maps the requested key to the corresponding business key if necessary.
	         * @param {String} key the requested property key which might is a key which we have to map to a business key name using
	         * the 'BusinessPropertyKeyMap.json'
	         * @return {String} the mapped key or the given key in case of it could not mapped
	         */
	        mapKey(key) {
	            if(key && typeof key === "string") {
	                let attrMarker = key.indexOf(PROP_ATTRIBUTE_BEGIN_MARKER);
	                let arrayMarkerIdx = key.indexOf(PROP_INDEX_BEGIN_MARKER);
	                if(arrayMarkerIdx === -1 && attrMarker === -1) {
	                    return this.businessPropertyKeys[key] || key;
	                } else {
	                    let plainKey = attrMarker !== -1 ? key.substr(0, attrMarker) : key.substr(0, arrayMarkerIdx);
	                    let marker = attrMarker !== -1 ? key.substr(attrMarker) : key.substr(arrayMarkerIdx);
	                    if(plainKey in this.businessPropertyKeys) {
	                        return `${this.businessPropertyKeys[plainKey]}${marker}`;
	                    }
	                }
	            }
	            return key;
	        }

	        /**
	         * Maps the requested keys to the corresponding business keys if necessary.
	         * If a request id is given and there are keys to map it stores the mapping
	         * until {@link Wincor.UI.Service.DataService#mapResponseKeys} has been invoked with the same request id.
	         * @param {Array<String>} keys the requested property keys which might contain keys which we have to map to business key names using
	         * the 'BusinessPropertyKeyMap.json'
	         * @param {Number=} reqId the request id from the original{@link Wincor.UI.Service.DataService#getValues} request
	         * @return {Array} the keys array might contain mapped keys
	         */
	        mapKeys(keys, reqId) {
	            let mappedKeys = [];
	            let val = {};
	            let mapVal;
	            const len = keys.length;
	            for(let i = 0; i < len; i++) {
	                let key = keys[i];
	                if(typeof key !== "string" || !isNaN(key)) {
	                    _logger.error(
	                        `DataService::mapKeys the key='${key}' within the given keys=[${keys}] array is not a string, please check your DataService::getValues call(s) for viewKey=${this.serviceProvider.ViewService.viewContext.viewKey}`
	                    );
	                    continue;
	                }
	                let attrMarker = key.indexOf(PROP_ATTRIBUTE_BEGIN_MARKER);
	                let arrayMarkerIdx = key.indexOf(PROP_INDEX_BEGIN_MARKER);
	                let plainKey = null;
	                let marker = null;
	                if(arrayMarkerIdx !== -1 || attrMarker !== -1) {
	                    plainKey = attrMarker !== -1 ? key.substr(0, attrMarker) : key.substr(0, arrayMarkerIdx);
	                    marker = attrMarker !== -1 ? key.substr(attrMarker) : key.substr(arrayMarkerIdx);
	                }
	                key = plainKey || key;
	                let keyFromMap = this.businessPropertyKeys[key];
	                let propKey = keyFromMap || key;
	                propKey = plainKey ? `${propKey}${marker}` : propKey;
	                // force unique keys
	                if(!mappedKeys.includes(propKey)) {
	                    mappedKeys.push(propKey);
	                }
	                if(reqId && keyFromMap) {
	                    if(!mapVal) {
	                        if(this.propRequestMap.has(reqId)) {
	                            mapVal = this.propRequestMap.get(reqId);
	                        } else {
	                            mapVal = this.propRequestMap.set(reqId, val).get(reqId);
	                        }
	                    }
	                    mapVal[propKey] = plainKey ? `${key}${marker}` : key;
	                }
	            }
	            return mappedKeys;
	        }

	        /**
	         * Get the values of the requested parameters from the business logic.
	         * @param {Array<string> | string} keys e.g. single string or ["VAR_MY_HTML_NAME_S", "CUSTOMER_SURNAME", ...]
	         * @param {function(Object)} callback
	         * @param {function(Object)} onUpdateCallback callback is called when a key was updated.
	         * @param {boolean=} [persistent=false] persistent true, if the -onUpdateCallback callback function should stay persistent, even a
	         *        {@link Wincor.UI.Service.DataService#cleanDataRegistrations} is invoked, false otherwise.
	         */
	        getValues(keys, callback, onUpdateCallback, persistent = false) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> DataService::getValues(${keys})`);

	            //BEGIN: check input parameters
	            keys = Array.isArray(keys) ? keys : [keys];
	            let uniqueKeys = [];
	            let errorMessage;
	            const len = keys.length;
	            let overallLen = 0;
	            // must use forward loop, because of order of the keys (e.g. ProFlex4Op)
	            for(let i = 0; i < len; ++i) {
	                let key = keys[i];
	                //do NOT use '!keys[i]' because empty string is okay, 0 is okay
	                if(key !== void 0 && key !== null) {
	                    if(!uniqueKeys.includes(key)) {
	                        uniqueKeys.push(key);
	                        overallLen += key.length;
	                    } else {
	                        _logger.error(`Warning: DataService::getValues() double key detected: ${key}`);
	                    }
	                } else {
	                    errorMessage = "DataService::getValues() keys contains null or undefined.";
	                    break;
	                }
	            }
	            // check for potential argument error
	            if(overallLen > MAX_LEN_REQUESTED_KEYS || uniqueKeys.length > MAX_COUNT_REQUESTED_KEYS) {
	                errorMessage = `DataService::getValues() too many or too long property keys argument requested. Please check your keys array argument. Number of keys requested: ${uniqueKeys.length}, string len: ${overallLen}`;
	            }
	            keys = this.mapKeys(uniqueKeys);

	            if(errorMessage) {
	                _logger.error(errorMessage);
	                callback && callback({}); //call callback with empty object
	                Wincor.UI.Service.Provider.propagateError("DataService::getValues", this.ERROR_TYPE.REQUEST);
	                return;
	            }
	            //END: check input parameters

	            this.FRM_RESOLVE_REQUEST.FWFuncID = 30; //DATADICTIONARYEXT_FUNC_GET_KEY_VALUES
	            this.FRM_RESOLVE_REQUEST.param1 = keys;
	            this.FRM_RESOLVE_REQUEST.meta1 = [META_ANSI, -1];
	            this.FRM_RESOLVE_REQUEST.param2 = [];
	            this.FRM_RESOLVE_REQUEST.meta2 = [META_UTF8, BUFFER_LEN_UTF8];
	            this.FRM_RESOLVE_REQUEST.param3 = [];
	            this.FRM_RESOLVE_REQUEST.meta3 = [META_ANSI, BUFFER_LEN_ANSI];
	            this.FRM_RESOLVE_REQUEST.paramUL = 0;

	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `Wincor.UI.Service.DataService.getValues() Request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            let message = this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	            this.mapKeys(uniqueKeys, message.callbackIdx);
	            //build a new TranslateRegistration object and add it to our Array if (and only if!) an onUpdateCallback is given
	            if(onUpdateCallback) {
	                let dataReg = new this.DataRegistration();
	                dataReg.keys = keys;
	                dataReg.keyMap = this.getKeyMap(message.callbackIdx);
	                dataReg.onUpdate = onUpdateCallback;
	                dataReg.persistent = persistent ? persistent : false; // note, persistent arg is optional
	                this.dataArray.push(dataReg);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< DataService::getValues");
	        }

	        /**
	         * Set the values of the requested parameters to be stored within the business logic.
	         * @param {Array<string> | string} keys e.g. a single string or ["VAR_MY_HTML_NAME_S", "CUSTOMER_SURNAME", ...]
	         * @param {Array<string> | string} values e.g. a single string or ["cardinsert.html", "Doe", ...]
	         * @param {function(Number)} callback
	         */
	        setValues(keys, values, callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> DataService::setValues(${keys}, ${values})`);

	            //BEGIN: check input parameters
	            keys = Array.isArray(keys) ? keys : [keys];
	            values = Array.isArray(values) ? values : [values];
	            let uniqueKeys = [];
	            let correspondingValues = [];
	            let errorMessage;
	            if(keys.length !== values.length) {
	                errorMessage = "DataService::setValues(): keys and values do not have the same size.";
	            } else {
	                let overallKeysLen = 0;
	                let overallValuesLen = 0;
	                for(let i = 0; i < keys.length; ++i) {
	                    let key = keys[i];
	                    let value = values[i];
	                    if(key !== void 0 && key !== null) {
	                        // do NOT use '!keys[i]' because empty string is okay, 0 is okay
	                        let mappedKey = this.mapKey(key);
	                        if(!uniqueKeys.includes(mappedKey)) {
	                            uniqueKeys.push(mappedKey); // do the mapping of the key
	                            overallKeysLen += key.length;
	                            if(value !== void 0 && value !== null) {
	                                // do NOT use '!keys[i]' because empty string is okay, 0 is okay
	                                value = value.toString();
	                                correspondingValues.push(value);
	                                overallValuesLen += value.length;
	                            } else {
	                                errorMessage = "DataService::setValues() values contains null or undefined.";
	                                break;
	                            }
	                        } else {
	                            if(mappedKey !== key) {
	                                _logger.error(`Warning: DataService::setValues() double key detected: ${key} is the same as ${mappedKey}!`);
	                            } else {
	                                _logger.error(`Warning: DataService::setValues() double key detected: ${key}`);
	                            }
	                        }
	                    } else {
	                        errorMessage = "DataService::setValues() keys contains null or undefined.";
	                        break;
	                    }
	                }
	                // check for potential argument error
	                if(overallKeysLen > MAX_LEN_REQUESTED_KEYS || uniqueKeys.length > MAX_COUNT_REQUESTED_KEYS) {
	                    errorMessage = `DataService::setValues() too many or too long property keys argument requested. Please check your keys array argument. Number of keys argument requested: ${uniqueKeys.length}, string len: ${overallKeysLen}`;
	                } else if(overallValuesLen > MAX_LEN_REQUESTED_VALUES) {
	                    errorMessage = `DataService::setValues() too long values argument requested. Please check your values array argument. Number of values argument requested: ${correspondingValues.length}, string len: ${overallValuesLen}`;
	                }
	            }

	            if(errorMessage) {
	                _logger.error(errorMessage);
	                if(callback) {
	                    callback(-1); //call callback with a RC != 0
	                }
	                Wincor.UI.Service.Provider.propagateError("DataService::setValues", this.ERROR_TYPE.REQUEST);
	                return;
	            }
	            //END: check input parameters

	            this.FRM_RESOLVE_REQUEST.FWFuncID = 31; //DATADICTIONARYEXT_FUNC_SET_KEY_VALUES
	            this.FRM_RESOLVE_REQUEST.param1 = uniqueKeys;
	            this.FRM_RESOLVE_REQUEST.meta1 = [META_ANSI, -1];
	            this.FRM_RESOLVE_REQUEST.param2 = correspondingValues;
	            this.FRM_RESOLVE_REQUEST.meta2 = [META_UTF8, -1];
	            this.FRM_RESOLVE_REQUEST.param3 = [];
	            this.FRM_RESOLVE_REQUEST.meta3 = [META_ANSI, BUFFER_LEN_ANSI];
	            this.FRM_RESOLVE_REQUEST.paramUL = 0;

	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `Wincor.UI.Service.DataService.setValues() Request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< DataService::setValues");
	        }

	        /**
	         * Clean the {@link Wincor.UI.Service.DataService#dataArray} containing all
	         * {@link Wincor.UI.Service.DataService#DataRegistration} structures which has been set by the
	         * {@link Wincor.UI.Service.DataService#getValues} method.
	         */
	        cleanDataRegistrations() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> DataService::cleanDataRegistrations()");
	            let newDataArray = [];
	            // keep the persistent items in -newDataArray
	            for(let i = this.dataArray.length - 1; i >= 0; i--) {
	                if(this.dataArray[i].persistent) {
	                    // keep the persistent item
	                    newDataArray.push(this.dataArray[i]);
	                }
	            }
	            this.dataArray = newDataArray; // empty array or the persistent items kept
	            this.propRequestMap.clear(); // clean the property request map
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< DataService::cleanDataRegistrations");
	        }

	        /**
	         * Builds a result object and calls the registered update callbacks.
	         * @param {String} value the separated value string
	         * @private
	         */
	        valueChanged(value) {
	            let splitResult = value.split(VALUE_CHANGED_SEPARATOR);
	            let changedKey = splitResult[0];
	            let newValue = splitResult[1];
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `. DataService::onValueChanged changedKey='${changedKey}', newValue='${newValue}'`);
	            for(let i = 0; i < this.dataArray.length; i++) {
	                let dataReg = this.dataArray[i];
	                let keys = dataReg.keys;
	                for(let j = 0; j < keys.length; j++) {
	                    if(keys[j] === changedKey) {
	                        let result = {}; //build the object
	                        if(changedKey in dataReg.keyMap) {
	                            // must replace the business key by the original requested key?
	                            result[dataReg.keyMap[changedKey]] = newValue;
	                        } else {
	                            result[changedKey] = newValue;
	                        }
	                        dataReg.onUpdate(result); //call the callback with the object
	                    }
	                }
	            }
	        }

	        /**
	         * This method will be triggered when a value of a key has been changed.
	         * The changed key will be updated in the DataRegistration structure, which contains all prior requested keys.
	         * @param {Array} value e.g. ["VAR_MY_HTML_NAME_S", "CUSTOMER_SURNAME", ...]
	         */
	        onValueChanged(value) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> DataService::onValueChanged(${value})`);
	            this.valueChanged(Wincor.ConvHexToStr(value)); // values[0] has the message content
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< DataService::onValueChanged");
	        }

	        /**
	         * This method will be triggered when an Unicode (WCHAR*) value of a key has been changed.
	         * The changed key will be updated in the DataRegistration structure, which contains all prior requested keys.
	         * @param {String} value Key + separator + new Value (WCHAR*) e.g. "VIDEO_PEERID_NAME_WNSEP_"
	         */
	        onValueChangedUnicode(value) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> DataService::onValueChangedUnicode(${value})`);
	            this.valueChanged(value); // values[0] has the message content
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< DataService::onValueChangedUnicode");
	        }

	        /**
	         * Reads the <i>UIPropertyKeyMap.json</i>, the <i>BusinessPropertyKeyMap.json</i> and <i>BusinessPropertyCustomKeyMap.json</i> and stores the content in
	         *
	         * @param {Object} message See {@link Wincor.UI.Service.BaseService#onSetup}
	         * @returns {Promise}
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.BaseService#onSetup}
	         */
	        onSetup(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> DataService::onSetup('${JSON.stringify(message)}')`);
	            const self = this;
	            return Promise.resolve([BusinessPropertyKeyMap, BusinessPropertyCustomKeyMap, UIPropertyKeyMap])
	                .then(dataArray => {
	                    delete dataArray[1]["//"]; // remove possible comment
	                    self.businessPropertyKeys = Object.assign(dataArray[0], dataArray[1]); // standard keys with custom specific ones
	                    self.UIPropertyKeys = dataArray[2];
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< DataService::onSetup");
	                })
	                .catch(e => {
	                    _logger.error(`* importReference error getting BusinessPropertyKeyMap or BusinessPropertyCustomKeyMap ${e}`);
	                });
	        }

	        /**
	         * Registers for DataDictionary events for property changes.
	         * @returns {Promise}
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.BaseService#onServicesReady}
	         */
	        onServicesReady() {
	            return ext.Promises.promise(resolve => {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> DataService::onServicesReady()");
	                function registerCallback(message) {
	                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* DataService::onServicesReady (registerCallback): RC: ${message.RC}`);
	                }

	                this.serviceProvider.EventService.registerForEvent(666, "CCDatDic", this.onValueChangedUnicode.bind(this), registerCallback.bind(this), "UTF-8", true);
	                this.serviceProvider.EventService.registerForEvent(667, "CCDatDic", this.onValueChangedUnicode.bind(this), registerCallback.bind(this), "UTF-16", true);
	                const viewService = this.serviceProvider.ViewService;
	                viewService.registerForServiceEvent(viewService.SERVICE_EVENTS.VIEW_CLOSING, this.cleanDataRegistrations.bind(this), true);
	                viewService.registerForServiceEvent(
	                    viewService.SERVICE_EVENTS.SHUTDOWN,
	                    () => {
	                        this.cleanDataRegistrations();
	                        this.propertyHandler = null;
	                    },
	                    true
	                );
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< DataService::onServicesReady");

	                super.onServicesReady().then(resolve);
	            });
	        }

	        /**
	         * Callback for DataService~setPropertyHandler.
	         * @callback propertyHandlerCallback
	         * @async
	         * @param {object} propertyInfo The propertyInfo object
	         * @param {string} propertyInfo.key The name of the property to resolve
	         * @param {string} propertyInfo.value THe name of the property to resolve
	         * @returns {Promise<undefined|boolean>}
	         */

	        /**
	         * Adds a handler function to string property handlers
	         * @param {propertyHandlerCallback|null} handlerFx The handler function or null to reset
	         * @returns {boolean} success
	         */
	        setPropertyHandler(handlerFx) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> DataService::setPropertyHandler(...)`);
	            let ret = false;
	            if(!this.propertyHandler && typeof handlerFx === "function") {
	                const handler = handlerFx;
	                ret = true;
	                this.propertyHandler = (...args) => {
	                    try {
	                        return handler(...args);
	                    } catch(e) {
	                        _logger.error(`Error DataService: propertyHandler: ${handler ? handler.toString() : "<invalid_handler>"} caught ${JSON.stringify(e)}`);
	                    }
	                };
	            } else {
	                if(handlerFx == null) {
	                    this.propertyHandler = null;
	                    _logger.error(`DataService::setPropertyHandler resetting handlerFx`);
	                    ret = true;
	                } else if(this.propertyHandler) {
	                    _logger.error(`DataService::setPropertyHandler handler already set!`);
	                } else {
	                    _logger.error(`DataService::setPropertyHandler argment is not a function!`);
	                }
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< DataService::setPropertyHandler returns id <${ret}>`);
	            return ret;
	        }

	        /**
	         * This function can be called from outside the UI to retrieve arbitrary viewModel data as a property!
	         * The functionality relies on a naming convention regarding the attribute name and context to access.
	         * Naming convention is defined as follows:
	         * GUIINSTANCENAME_ATTRIBUTENAME_CONTEXTNAME, where "GUIINSTANCENAME_" will be cut by gui.dll and not arrive here!
	         * This automatic value resolution via naming convention heavily relies on a correct case-sensitive spelling, therefore mappings can be
	         * used within the file "core/servicedata/businessPropertyKeyMap.json"
	         * For CONTEXTNAME the "observableAreaId" of a corresponding viewModel can be given so that a valid name could be:
	         * "GUIAPP_flexHeader.date". Service attributes can also be accessed if exposed via proxy using the servicename as context like:
	         * "ViewService.viewContext.viewConfig"
	         * The result will be send back to the native part as response containing the stringified value of the attribute or null if it does not exist.
	         * @param {Object} message message containing request-data
	         * @param {String} message.propertyName contains the propertyName - has to follow the above naming convention
	         * @param {String} message.propertyValue will be set to the value of the property, unchanged if not found...
	         * @return {String} value for internal requests
	         */
	        getPropertyString(message) {
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `> DataService::getPropertyString(${JSON.stringify(message)})`);
	            let name = message.propertyName;
	            let value = null;
	            let ret;
	            // try to get it from mapping, otherwise try to disassemble directly
	            name = this.UIPropertyKeys[name] || name;
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. after mapping: ${name}`);
	            const prop = { key: name, value: undefined };
	            let handled = false;
	            if(this.propertyHandler) {
	                handled = this.propertyHandler(prop);
	            }

	            if(handled) {
	                // any invalid falsish value is reset to ""
	                if(!prop.value) {
	                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. DataService::getPropertyString propertyHandler returned invalid value <${prop.value}> resetting to ''`);
	                    prop.value = "";
	                }
	                _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. DataService::getPropertyString propertyHandler returned <${prop.value}>`);
	                value = prop.value;
	            } else {
	                // now we have: flexHeader.date -> first index is context, next attributes might be more than one for nested objects... walk structure hierarchy
	                let parts = name.split(".");
	                let contextName = parts.splice(0, 1)[0]; // pop first entry as context
	                let context = Wincor.UI.Service.Provider[contextName];

	                if(!context) {
	                    // it wasn't a service, look for specials
	                    if(contextName.indexOf("Wincor") === 0) {
	                        context = Wincor;
	                    } else if(contextName.indexOf("window") === 0) {
	                        context = window.frames[0];
	                    }
	                }

	                // If there is a viewset switch active, we won't have "Content" available!
	                if(!context && Wincor.UI.Content && Wincor.UI.Content.ViewModelContainer) {
	                    // at last try if there is an observable area / vm with this name...
	                    context = Wincor.UI.Content.ViewModelContainer.getById(contextName);
	                }

	                if(context) {
	                    value = parts.reduce(function(c, a) {
	                        if(c && a in c) {
	                            try {
	                                if(typeof c[a] === "function" && "__ko_proto__" in c[a]) {
	                                    return c[a]();
	                                } else {
	                                    return c[a];
	                                }
	                            } catch(e) {
	                                _logger.error(`DataService::getPropertyString exception during attribute evaluation: '${e.message}'`);
	                            }
	                        }
	                        return void 0;
	                    }, context);
	                }
	            }

	            if(value !== void 0 && value !== null) {
	                message.propertyValue = value.toString();
	                ret = this.REQUEST_RESPONSE_OK;
	                this.sendResponse(message, ret);
	            } else {
	                let err = name;
	                if(message.propertyName !== name) {
	                    err = message.propertyName + "' aka '" + name;
	                }
	                _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `DataService::getPropertyString attribute could not be found for: '${err}'`);
	                ret = "-1";
	                this.sendResponse(message, ret);
	            }

	            if(typeof value === "object") {
	                try {
	                    value = JSON.stringify(value);
	                } catch(e) {
	                    value = value.toString();
	                }
	            }

	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `< DataService::getPropertyString returns ${ret} data: ${JSON.stringify(message)}`);
	            return value;
	        }
	    };
	};

	var PROP_CURRENCY_ISO = "CCTAFW_PROP_CURRENCY";
	var PROP_CURRENCY_ADA_TEXT = "CCTAFW_PROP_CURRENCY_ADA_TEXT";
	var PROP_CURRENCY_EXP = "CCTAFW_PROP_CURRENCY_EXPONENT";
	var PROP_LISE_CONFIGURATION = "CCTAFW_PROP_LISE_CONFIGURATION";
	var PROP_LISE_INDEX = "CCTAFW_PROP_LISE_INDEX";
	var PROP_DISPLAY_VARIBALE = "CCHPFW_PROP_DISPLAY_VARIABLE";
	var PROP_FORMATTED_VALUE = "CCTAFW_PROP_UI_INPUT_FIELD_CONTENT_FORMATTED[0]";
	var PROP_UNFORMATTED_VALUE = "CCTAFW_PROP_UI_INPUT_FIELD_CONTENT_UNFORMATTED[0]";
	var PROP_UI_VIEWSET_KEY = "CCTAFW_PROP_UI_VIEWSET_KEY";
	var PROP_UI_STYLE_TYPE_KEY = "CCTAFW_PROP_UI_STYLESHEET_KEY";
	var PROP_MIXTURE_DATA = "CCTAFW_PROP_MIXTURE_DISPLAY_DATA";
	var PROP_DEPOSIT_CURRENCY = "CCCAINTAFW_PROP_JRN_CURRENCY";
	var PROP_DEPOSIT_RESULT = "CCCAINTAFW_PROP_JSON_RESULT";
	var PROP_DEPOSIT_L2_BOX_VALUE = "CCCAINTAFW_PROP_DISP_L2_AMOUNTS";
	var PROP_MAX_ITEMS_ON_STACKER = "CCTAFW_PROP_REMAINING_NOTES_ON_STACKER";
	var PROP_MEDIA_ON_STACKER = "CCCHCCDMTAFW_MEDIAONSTACKER";
	var PROP_REMAINING_MEDIA_ON_STACKER = "CCCHCCDMTAFW_MEDIAONSTACKER_REMAINING";
	var PROP_FRONT_IMAGE_PATH = "CCCHCCDMTAFW_FRONTIMAGE_FILE";
	var PROP_BACK_IMAGE_PATH = "CCCHCCDMTAFW_BACKIMAGE_FILE";
	var PROP_CHEQUE_AMOUNT = "CCCHCCDMTAFW_AMOUNT";
	var PROP_CHEQUE_ACCEPTED = "CCCHCCDMTAFW_CHEQUE_ACCEPTED";
	var PROP_CHEQUE_TOTAL_AMOUNT = "CCCHCCDMTAFW_SUM";
	var PROP_CHEQUE_CURRENT_CHEQUE_NO = "CCCHCCDMTAFW_CHEQUE_NR_ONSCREEN";
	var PROP_CHEQUE_SCORE_OCR = "CCCHCCDMTAFW_SCORE_OCR";
	var PROP_CHEQUE_SCORE_MICR = "CCCHCCDMTAFW_SCORE_MICR";
	var PROP_CHEQUE_DOCUMENT_TYPE = "CCCHCCDMTAFW_DOCUMENT_TYPE";
	var PROP_CHEQUE_START_INDEX = "CCCHCCDMTAFW_CHEQUE_START_INDEX";
	var PROP_SCANNER_TYPE = "CCCHCCDMTAFW_SCANNER_TYPE";
	var PROP_CHEQUE_HAS_SHOWN = "CCCHCCDMTAFW_CHEQUEONSCREEN";
	var PROP_TRANSACTION_AMOUNT = "CCTAFW_PROP_TRANSACTION_AMOUNT";
	var PROP_MIN_AMOUNT_ACT = "CCTAFW_PROP_MIN_AMOUNT_ACT";
	var PROP_MAX_AMOUNT_ACT = "CCTAFW_PROP_MAX_AMOUNT_ACT";
	var PROP_PIN_OPTIONS = "CCTAFW_PROP_PIN_OPTIONS";
	var PROP_PIN_DIGITS = "CCTAFW_PROP_PIN_DIGITS";
	var PROP_ROLLBACK_NOTES_DATA = "CCCAINTAFW_PROP_JSON_ROLLBACKNOTES";
	var PROP_ROLLBACK_COINS_DATA = "CCCAINTAFW_PROP_JSON_ROLLBACKCOINS";
	var PROP_SELECTION_GROUPS = "CCTAFW_PROP_GENERIC_LIST_SELECTION_JSON_GROUPS";
	var PROP_MENU_PREFERENCE = "CCTAFW_PROP_MENU_PREFERENCE";
	var PROP_DISPLAY_CHIP_CHARGE = "CCTAFW_PROP_CHIP_DISP_CHARGE_F";
	var PROP_DISPENSE_AMOUNT = "CCTAFW_PROP_DISPENSE_AMOUNT";
	var PROP_COIN_DISPENSE_AMOUNT = "CCTAFW_PROP_COIN_DISPENSE_AMOUNT";
	var PROP_NOTE_DISPENSE_AMOUNT = "CCTAFW_PROP_NOTE_DISPENSE_AMOUNT";
	var PROP_ETS_LAYOUT = "CCTAFW_PROP_ETS_LAYOUT";
	var PROP_INTERNAL_FUNCTION_SELECTION = "CCTAFW_PROP_INTERNAL_FUNCTION_SELECTION_CODE";
	var PROP_ADA_STATUS_VALUE = "CCTAFW_PROP_ADA_STATUS_VALUE";
	var PROP_TRANSACTION_STATUS = "CCTAFW_PROP_TRANSACTION_STATUS";
	var PROP_CARD_ACTIVE = "CCTAFW_PROP_CARD_ACTIVE";
	var PROP_VALID_PIN_ENTERED = "CCTAFW_PROP_VALID_PIN_ENTERED";
	var PROP_DOCUMENT_DATA = "CCTAFW_PROP_DOCUMENT_DATA_JSON";
	var PROP_DOCUMENT_TYPE = "CCTAFW_PROP_DOCUMENT_TYPE";
	var PROP_DOCUMENT_SIDE = "CCTAFW_PROP_DOCUMENT_SIDE";
	var PROP_LANGUAGE_SET_MANUALLY = "CCTAFW_PROP_LANGUAGE_SET_MANUALLY";
	var PROP_VIDEO_REQUEST_TELLERNAME = "VIDEO_REQUEST_TELLERNAME";
	var PROP_DEFAULT_LANGUAGE = "CCTAFW_PROP_DEFAULT_LANGUAGE";
	var PROP_DM_STATISTICS_ALL = "CCTAFW_PROP_STATISTICS_MARKETING_ALL";
	var PROP_DM_STATISTICS_DATE_LAST_GOOD = "CCTAFW_PROP_STATISTICS_MARKETING_DATE_LAST_GOOD";
	var PROP_DM_STATISTICS_FAILED = "CCTAFW_PROP_STATISTICS_MARKETING_FAILED";
	var PROP_DM_STATISTICS_DATE_LAST_FAILED = "CCTAFW_PROP_STATISTICS_MARKETING_DATE_LAST_FAILED";
	var PROP_DM_STATISTICS_COUPONS = "CCTAFW_PROP_STATISTICS_MARKETING_COUPON";
	var PROP_DM_STATISTICS_AVG_RESPONSE_TIME = "CCTAFW_PROP_STATISTICS_MARKETING_AVERAGE_RESPONSE_TIME";
	var PROP_DM_STATISTICS_MULTI_STEP_CAMPAIGNS = "CCTAFW_PROP_STATISTICS_MARKETING_MULTI_SESSION";
	var PROP_DM_STATISTICS_SINGLE_STEP_CAMPAIGNS = "CCTAFW_PROP_STATISTICS_SINGLE_SESSION";
	var PROP_DM_STATISTICS_INTERACTIVE_CAMPAIGNS = "CCTAFW_PROP_STATISTICS_MARKETING_WITH_CUSTOMER_INTERACTION";
	var PROP_ATM_LOCATION_STATE_INFOS = "RCC_RSP_LOCATEATM_ATM_LOCATION_STATE_INFOS";
	var PROP_RECEIPT_PREFERENCE_JSON_GROUPS = "CCTAFW_PROP_RECEIPT_PREFERENCE_JSON_GROUPS";
	var PROP_RETRACT_NO = "CCCAINTAFW_PROP_NUMBER_OF_RETRACTS";
	var PROP_TERMINAL_ID = "RCC_RSP_LOADMASTERDATA_WORKSTATION_NAME";
	var PROP_TERMINAL_MODEL = "RCC_RSP_LOADMASTERDATA_WORKSTATION_WKSTPROFILE";
	var PROP_BRANCH_NAME = "RCC_RSP_LOADMASTERDATA_WORKSTATION_ADRESSDATA_PLACEMENT";
	var PROP_BRANCH_LOCATION = "RCC_RSP_LOADMASTERDATA_WORKSTATION_ADRESSDATA_PLACEMENT";
	var PROP_CITY = "RCC_RSP_LOADMASTERDATA_WORKSTATION_ADRESSDATA_CITY";
	var PROP_OUT_OF_SERVICE_ADA_TEXT = "CCTAFW_PROP_OUT_OF_SERVICE_ADA_TEXT";
	var PROP_DISPLAY_TRANS_LOG = "CCTAFW_PROP_EMV_TRANS_LOG_LISE_DATA";
	var PROP_DISPLAY_TRANS_LOG_ECASH = "CCTAFW_PROP_EMV_TRANS_LOG_ECASH_LISE_DATA";
	var PROP_RCM_UI_IMAGE_QRCODE_FILEPATH = "CCHPFW_PROP_RCM_UI_IMAGE_QRCODE_FILEPATH";
	var PROP_RCC_RSP_QRCODE_TOKEN = "RCC_RSP_QRCODE_TOKEN";
	var PROP_FASTCASH_AMOUNT = "CCTAFW_PROP_COUTFAST_AMOUNT";
	var PROP_FASTCASH_CURRENCY = "CCTAFW_PROP_COUTFAST_CURRENCY";
	var BusinessPropertyKeyMap = {
		PROP_CURRENCY_ISO: PROP_CURRENCY_ISO,
		PROP_CURRENCY_ADA_TEXT: PROP_CURRENCY_ADA_TEXT,
		PROP_CURRENCY_EXP: PROP_CURRENCY_EXP,
		PROP_LISE_CONFIGURATION: PROP_LISE_CONFIGURATION,
		PROP_LISE_INDEX: PROP_LISE_INDEX,
		PROP_DISPLAY_VARIBALE: PROP_DISPLAY_VARIBALE,
		PROP_FORMATTED_VALUE: PROP_FORMATTED_VALUE,
		PROP_UNFORMATTED_VALUE: PROP_UNFORMATTED_VALUE,
		PROP_UI_VIEWSET_KEY: PROP_UI_VIEWSET_KEY,
		PROP_UI_STYLE_TYPE_KEY: PROP_UI_STYLE_TYPE_KEY,
		PROP_MIXTURE_DATA: PROP_MIXTURE_DATA,
		PROP_DEPOSIT_CURRENCY: PROP_DEPOSIT_CURRENCY,
		PROP_DEPOSIT_RESULT: PROP_DEPOSIT_RESULT,
		PROP_DEPOSIT_L2_BOX_VALUE: PROP_DEPOSIT_L2_BOX_VALUE,
		PROP_MAX_ITEMS_ON_STACKER: PROP_MAX_ITEMS_ON_STACKER,
		PROP_MEDIA_ON_STACKER: PROP_MEDIA_ON_STACKER,
		PROP_REMAINING_MEDIA_ON_STACKER: PROP_REMAINING_MEDIA_ON_STACKER,
		PROP_FRONT_IMAGE_PATH: PROP_FRONT_IMAGE_PATH,
		PROP_BACK_IMAGE_PATH: PROP_BACK_IMAGE_PATH,
		PROP_CHEQUE_AMOUNT: PROP_CHEQUE_AMOUNT,
		PROP_CHEQUE_ACCEPTED: PROP_CHEQUE_ACCEPTED,
		PROP_CHEQUE_TOTAL_AMOUNT: PROP_CHEQUE_TOTAL_AMOUNT,
		PROP_CHEQUE_CURRENT_CHEQUE_NO: PROP_CHEQUE_CURRENT_CHEQUE_NO,
		PROP_CHEQUE_SCORE_OCR: PROP_CHEQUE_SCORE_OCR,
		PROP_CHEQUE_SCORE_MICR: PROP_CHEQUE_SCORE_MICR,
		PROP_CHEQUE_DOCUMENT_TYPE: PROP_CHEQUE_DOCUMENT_TYPE,
		PROP_CHEQUE_START_INDEX: PROP_CHEQUE_START_INDEX,
		PROP_SCANNER_TYPE: PROP_SCANNER_TYPE,
		PROP_CHEQUE_HAS_SHOWN: PROP_CHEQUE_HAS_SHOWN,
		PROP_TRANSACTION_AMOUNT: PROP_TRANSACTION_AMOUNT,
		PROP_MIN_AMOUNT_ACT: PROP_MIN_AMOUNT_ACT,
		PROP_MAX_AMOUNT_ACT: PROP_MAX_AMOUNT_ACT,
		PROP_PIN_OPTIONS: PROP_PIN_OPTIONS,
		PROP_PIN_DIGITS: PROP_PIN_DIGITS,
		PROP_ROLLBACK_NOTES_DATA: PROP_ROLLBACK_NOTES_DATA,
		PROP_ROLLBACK_COINS_DATA: PROP_ROLLBACK_COINS_DATA,
		PROP_SELECTION_GROUPS: PROP_SELECTION_GROUPS,
		PROP_MENU_PREFERENCE: PROP_MENU_PREFERENCE,
		PROP_DISPLAY_CHIP_CHARGE: PROP_DISPLAY_CHIP_CHARGE,
		PROP_DISPENSE_AMOUNT: PROP_DISPENSE_AMOUNT,
		PROP_COIN_DISPENSE_AMOUNT: PROP_COIN_DISPENSE_AMOUNT,
		PROP_NOTE_DISPENSE_AMOUNT: PROP_NOTE_DISPENSE_AMOUNT,
		PROP_ETS_LAYOUT: PROP_ETS_LAYOUT,
		PROP_INTERNAL_FUNCTION_SELECTION: PROP_INTERNAL_FUNCTION_SELECTION,
		PROP_ADA_STATUS_VALUE: PROP_ADA_STATUS_VALUE,
		PROP_TRANSACTION_STATUS: PROP_TRANSACTION_STATUS,
		PROP_CARD_ACTIVE: PROP_CARD_ACTIVE,
		PROP_VALID_PIN_ENTERED: PROP_VALID_PIN_ENTERED,
		PROP_DOCUMENT_DATA: PROP_DOCUMENT_DATA,
		PROP_DOCUMENT_TYPE: PROP_DOCUMENT_TYPE,
		PROP_DOCUMENT_SIDE: PROP_DOCUMENT_SIDE,
		PROP_LANGUAGE_SET_MANUALLY: PROP_LANGUAGE_SET_MANUALLY,
		PROP_VIDEO_REQUEST_TELLERNAME: PROP_VIDEO_REQUEST_TELLERNAME,
		PROP_DEFAULT_LANGUAGE: PROP_DEFAULT_LANGUAGE,
		PROP_DM_STATISTICS_ALL: PROP_DM_STATISTICS_ALL,
		PROP_DM_STATISTICS_DATE_LAST_GOOD: PROP_DM_STATISTICS_DATE_LAST_GOOD,
		PROP_DM_STATISTICS_FAILED: PROP_DM_STATISTICS_FAILED,
		PROP_DM_STATISTICS_DATE_LAST_FAILED: PROP_DM_STATISTICS_DATE_LAST_FAILED,
		PROP_DM_STATISTICS_COUPONS: PROP_DM_STATISTICS_COUPONS,
		PROP_DM_STATISTICS_AVG_RESPONSE_TIME: PROP_DM_STATISTICS_AVG_RESPONSE_TIME,
		PROP_DM_STATISTICS_MULTI_STEP_CAMPAIGNS: PROP_DM_STATISTICS_MULTI_STEP_CAMPAIGNS,
		PROP_DM_STATISTICS_SINGLE_STEP_CAMPAIGNS: PROP_DM_STATISTICS_SINGLE_STEP_CAMPAIGNS,
		PROP_DM_STATISTICS_INTERACTIVE_CAMPAIGNS: PROP_DM_STATISTICS_INTERACTIVE_CAMPAIGNS,
		PROP_ATM_LOCATION_STATE_INFOS: PROP_ATM_LOCATION_STATE_INFOS,
		PROP_RECEIPT_PREFERENCE_JSON_GROUPS: PROP_RECEIPT_PREFERENCE_JSON_GROUPS,
		PROP_RETRACT_NO: PROP_RETRACT_NO,
		PROP_TERMINAL_ID: PROP_TERMINAL_ID,
		PROP_TERMINAL_MODEL: PROP_TERMINAL_MODEL,
		PROP_BRANCH_NAME: PROP_BRANCH_NAME,
		PROP_BRANCH_LOCATION: PROP_BRANCH_LOCATION,
		PROP_CITY: PROP_CITY,
		PROP_OUT_OF_SERVICE_ADA_TEXT: PROP_OUT_OF_SERVICE_ADA_TEXT,
		PROP_DISPLAY_TRANS_LOG: PROP_DISPLAY_TRANS_LOG,
		PROP_DISPLAY_TRANS_LOG_ECASH: PROP_DISPLAY_TRANS_LOG_ECASH,
		PROP_RCM_UI_IMAGE_QRCODE_FILEPATH: PROP_RCM_UI_IMAGE_QRCODE_FILEPATH,
		PROP_RCC_RSP_QRCODE_TOKEN: PROP_RCC_RSP_QRCODE_TOKEN,
		PROP_FASTCASH_AMOUNT: PROP_FASTCASH_AMOUNT,
		PROP_FASTCASH_CURRENCY: PROP_FASTCASH_CURRENCY
	};

	var BusinessPropertyCustomKeyMap = {
		"//": "Place your custom specific property keys here. They will be merged to the standard business property keys map during runtime."
	};

	var VOUCHER_IMAGE_PATH = "UtilityService.PATHS.VOUCHER";
	var RECEIPT_IMAGE_PATH = "UtilityService.PATHS.RECEIPT";
	var ACTIVE_VIEWSET = "ViewService.viewSetName";
	var ACTIVE_STYLE = "ViewService.currentStyleType";
	var ACTIVE_VENDOR = "ViewService.currentVendor";
	var ACTIVE_RESOLUTION = "ViewService.currentResolution";
	var WINDOW_SIZE_X = "ViewService.initialLocation.width";
	var WINDOW_SIZE_Y = "ViewService.initialLocation.height";
	var WINDOW_POS_X = "ViewService.initialLocation.left";
	var WINDOW_POS_Y = "ViewService.initialLocation.top";
	var CONTENT_RUNNING = "ViewService.contentRunning";
	var INSTRUCTION_TEXT = "flexHeader.cmdRepos.commands.INSTRUCTION.label";
	var HEADLINE_TEXT = "flexHeader.cmdRepos.commands.HEADLINE.label";
	var INIT_ERROR = "flexMain.errorDuringInitialize";
	var SPLIT_SCREEN_MODE = "flexHeader.splitScreenMode";
	var UIPropertyKeyMap = {
		VOUCHER_IMAGE_PATH: VOUCHER_IMAGE_PATH,
		RECEIPT_IMAGE_PATH: RECEIPT_IMAGE_PATH,
		ACTIVE_VIEWSET: ACTIVE_VIEWSET,
		ACTIVE_STYLE: ACTIVE_STYLE,
		ACTIVE_VENDOR: ACTIVE_VENDOR,
		ACTIVE_RESOLUTION: ACTIVE_RESOLUTION,
		WINDOW_SIZE_X: WINDOW_SIZE_X,
		WINDOW_SIZE_Y: WINDOW_SIZE_Y,
		WINDOW_POS_X: WINDOW_POS_X,
		WINDOW_POS_Y: WINDOW_POS_Y,
		CONTENT_RUNNING: CONTENT_RUNNING,
		INSTRUCTION_TEXT: INSTRUCTION_TEXT,
		HEADLINE_TEXT: HEADLINE_TEXT,
		INIT_ERROR: INIT_ERROR,
		SPLIT_SCREEN_MODE: SPLIT_SCREEN_MODE
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ DataServiceInterface.js 4.3.1-210212-21-06af7f4f-1a04bc7d
	*/

	const ServiceClass$6 = getServiceClass$9({
	    Wincor: Wincor$2,
	    ext: ext$2,
	    LogProvider,
	    PTService,
	    UIPropertyKeyMap,
	    BusinessPropertyKeyMap,
	    BusinessPropertyCustomKeyMap
	});

	const ServiceInterface$6 = {
	    DataProxy: {
	        interface: {
	            getValues: {
	                type: "function",
	                callbackArgumentIndex: 1
	            },
	            setValues: {
	                type: "function",
	                callbackArgumentIndex: 2
	            },
	            getPropertyKeyMap: {
	                type: "function"
	            },
	            getPropertyString: {
	                type: "function",
	                external: true,
	                internal: false
	            },
	            setPropertyHandler: {
	                type: "function"
	            }
	        }
	    }
	};

	var DataService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$6,
		ServiceClass: ServiceClass$6
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.



	$MOD$ wn.UI.Service.EppService.js 4.3.1-210420-21-c476740e-1a04bc7d
	 */

	/**
	 * @module
	 */
	const getServiceClass$a = ({ Wincor, jQuery, LogProvider, PTService }) => {

	    const _logger = LogProvider;

	    let _claimId = 0;

	    //"F1": [{
	    //    id: 23,
	    //    callback: function(){}
	    //}]

	    /**
	     * Map containing registered callbacks key-pressed events of claimed keys
	     * @type {Map}
	     * @private
	     */
	    const _eppKeyPressed2CallbackMap = new Map();

	    /**
	     * Map containing registered callbacks for status changes of claimed keys
	     * @type {Map}
	     * @private
	     */
	    const _eppKeyStatusChanged2CallbackMap = new Map();

	    return class EppService extends PTService {
	        // PRIVATE MEMBER

	        claimingData = {
	            F1: { status: "RELEASED", claims: 0 },
	            F2: { status: "RELEASED", claims: 0 },
	            F3: { status: "RELEASED", claims: 0 },
	            F4: { status: "RELEASED", claims: 0 },
	            F5: { status: "RELEASED", claims: 0 },
	            F6: { status: "RELEASED", claims: 0 },
	            F7: { status: "RELEASED", claims: 0 },
	            F8: { status: "RELEASED", claims: 0 },
	            1: { status: "RELEASED", claims: 0 },
	            2: { status: "RELEASED", claims: 0 },
	            3: { status: "RELEASED", claims: 0 },
	            4: { status: "RELEASED", claims: 0 },
	            5: { status: "RELEASED", claims: 0 },
	            6: { status: "RELEASED", claims: 0 },
	            7: { status: "RELEASED", claims: 0 },
	            8: { status: "RELEASED", claims: 0 },
	            9: { status: "RELEASED", claims: 0 },
	            0: { status: "RELEASED", claims: 0 },
	            "*": { status: "RELEASED", claims: 0 },
	            CANCEL: { status: "RELEASED", claims: 0 },
	            CONFIRM: { status: "RELEASED", claims: 0 },
	            CORRECT: { status: "RELEASED", claims: 0 },
	            CLEAR: { status: "RELEASED", claims: 0 },
	            BACKSPACE: { status: "RELEASED", claims: 0 },
	            HELP: { status: "RELEASED", claims: 0 },
	            EDIT: { status: "RELEASED", claims: 0 },
	            R: { status: "RELEASED", claims: 0 },
	            L: { status: "RELEASED", claims: 0 }
	        };

	        /**
	         * Epp button F1
	         * @const
	         * @type {string}
	         */
	        BUTTONEPP_F1 = "F1";
	        
	        /**
	         * Epp button F2
	         * @const
	         * @type {string}
	         */
	        BUTTONEPP_F2 = "F2";
	        
	        /**
	         * Epp button F3
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_F3 = "F3";
	        
	        /**
	         * Epp button F4
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_F4 = "F4";
	        
	        /**
	         * Epp button F5
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_F5 = "F5";
	        
	        /**
	         * Epp button F6
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_F6 = "F6";
	        
	        /**
	         * Epp button F7
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_F7 = "F7";
	        
	        /**
	         * Epp button F8
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_F8 = "F8";
	        
	        /**
	         * Epp button F9
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_F9 = "F9";
	        
	        /**
	         * Epp button 0
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_0 = "0";
	        
	        /**
	         * Epp button 1
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_1 = "1";
	        
	        /**
	         * Epp button 2
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_2 = "2";
	        
	        /**
	         * Epp button 3
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_3 = "3";
	        
	        /**
	         * Epp button 4
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_4 = "4";
	        
	        /**
	         * Epp button 5
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_5 = "5";
	        
	        /**
	         * Epp button 6
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_6 = "6";
	        
	        /**
	         * Epp button 7
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_7 = "7";
	        
	        /**
	         * Epp button 8
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_8 = "8";
	        
	        /**
	         * Epp button 9
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_9 = "9";
	        
	        /**
	         * Epp button CONFIRM
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_CONFIRM = "CONFIRM";
	        
	        /**
	         * Epp button CANCEL
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_CANCEL = "CANCEL";
	        
	        /**
	         * Epp button HELP
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_HELP = "HELP";
	        
	        /**
	         * Epp button CLEAR
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_CLEAR = "CLEAR";
	        
	        /**
	         * Epp button BACKSPACE
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_BACKSPACE = "BACKSPACE";
	        
	        /**
	         * Epp button *
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_STAR = "*";
	        
	        /**
	         * Epp button CORRECT
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_CORRECT = "CORRECT";
	        
	        /**
	         * Epp button EDIT
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_EDIT = "EDIT";
	        
	        /**
	         * Epp button R (right)
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_R = "R";
	        
	        /**
	         * Epp button L (left)
	         * @type {string}
	         * @const
	         */
	        BUTTONEPP_L = "L";

	        /**
	         * Define from the Gui.dll for the callback function id for pressed eppkey
	         * @type {number}
	         * @const
	         */
	        GUI_COMM_CALLBACK_EPPKEY_PRESSED = 98;
	        
	        /**
	         * Define from the Gui.dll for the callback function id for a status change of a claimed eppkey
	         * @type {number}
	         * @const
	         */
	        GUI_COMM_CALLBACK_EPPCLAIM_STATUS_CHANGE = 99;

	        /**
	         * @type {string}
	         * @default "DENIED"
	         * @const
	         */
	        CLAIMSTATUS_DENIED = "DENIED";
	        
	        /**
	         * @type {string}
	         * @default "ENABLED"
	         * @const
	         */
	        CLAIMSTATUS_ENABLED = "ENABLED";
	        
	        /**
	         * @type {string}
	         * @default "DISABLED"
	         * @const
	         */
	        CLAIMSTATUS_DISABLED = "DISABLED";
	        
	        /**
	         * @type {string}
	         * @default "DEDENIED_BUT_ENABLEDNIED"
	         * @const
	         */
	        CLAIMSTATUS_DENIED_BUT_ENABLED = "DENIED_BUT_ENABLED";
	        
	        /**
	         * @type {string}
	         * @default "DENIED_BUT_DISABLED"
	         * @const
	         */
	        CLAIMSTATUS_DENIED_BUT_DISABLED = "DENIED_BUT_DISABLED";

	        /**
	         * Priority.
	         * @default 4
	         * @type {number}
	         */
	        prio = 4;

	        /**
	         * Object containing the definitions of view-service events other services or view-models  may register for.
	         * @type {*}
	         */
	        SERVICE_EVENTS = {
	            /**
	             * Sent if the claim status of any key changed.
	             * @example
	             * {
	             *  "F1":{
	             *          status: "ENABLED",  // tells if the current claiming is ENABLED/DISABLED due to higher prioritized claims of other UI instance
	             *          claims: 3           // number of claims due to e.g. popUp
	             *      }
	             * }
	             * @event Wincor.UI.Service.EppService#SERVICE_EVENTS:CLAIM_STATUS_CHANGED
	             * @eventtype service
	             */
	            CLAIM_STATUS_CHANGED: "CLAIM_STATUS_CHANGED"
	        };

	        /**
	         * "EppService" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "EppService";

	        /**
	         * See {@link Wincor.UI.Service.PTService#constructor}.
	         * Initializes members
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> EppService::EppService");
	            this.FRM_RESOLVE_REQUEST.service = this.NAME;
	            this.FRM_RESOLVE_REQUEST.FWName = "CCEppFW";
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< EppService::EppService");
	        }
	        
	        /**
	         * EPPService needs to overwrite onResponse, to be able to handle the "special" delegates containing claimIds
	         * @param {object} message
	         */
	        onResponse(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> EppService::onResponse('${JSON.stringify(message)}')`);

	            if (message && this.responseMap.has(message.callbackIdx)) {
	                let delegate = this.responseMap.get(message.callbackIdx);
	                if (delegate) {
	                    if (message.FWFuncID === 4002 && message.RC === 0) {
	                        //no '==='
	                        /*
	                         message.param2 has the EPP keys,   e.g. ["4","5","F5","F4"]
	                         message.param3 has the values, i.e. ["ENABLED","ENABLED","ENABLED","ENABLED","ENABLED"]

	                         response will be an object:
	                         response["4"] = "ENABLED"
	                         response["F5"] = "DISABLED"
	                         ...
	                         */
	                        let updateData = {};
	                        let value;
	                        let response = {};
	                        response["claimId"] = delegate.claimId;
	                        _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `EppService::onResponse claimId: [${delegate.claimId}] -> response: ${JSON.stringify(response, null, " ")}`);
	                        if (message.param2) {
	                            message.param2.forEach(function(key, index) {
	                                value = _eppKeyPressed2CallbackMap.get(key);
	                                response[key] = message.param3[index];
	                                updateData[key] = {
	                                    status: message.param3[index],
	                                    claims: value ? value.length : 0
	                                };
	                            }, this);
	                        } else {
	                            _logger.error("EppService::onResponse argument 'message' is invalid: Property 'param2' expected !");
	                        }
	                        this.fireClaimStatusChanged(updateData);
	                        _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `EppService::onResponse -> response: ${JSON.stringify(response, null, " ")}`);
	                        try {
	                            delegate()(response);
	                        } catch (e) {
	                            // Provider writes error-log
	                            Wincor.UI.Service.Provider.propagateError(this.NAME, this.ERROR_TYPE.RESPONSE, e);
	                        }
	                    } else if (message.FWFuncID === 4002 || message.FWFuncID === 4003 || message.FWFuncID === 4004 || message.FWFuncID === 4005) {
	                        try {
	                            if (message.FWFuncID === 4002) {
	                                delegate()(message.RC);
	                            } else {
	                                delegate(message.RC);
	                            }
	                        } catch (e) {
	                            // Provider writes error-log
	                            Wincor.UI.Service.Provider.propagateError(this.NAME, this.ERROR_TYPE.RESPONSE, e);
	                        }
	                    } else if (message.FWFuncID === 8) {
	                        delegate(message);
	                    } else {
	                        _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `EppService::onResponse message with FWFuncID '${message.FWFuncID}' and RC = '${message.RC}' will not be evaluated.`);
	                    }
	                } else {
	                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `EppService::onResponse No callback found for idx '${message.callbackIdx}'.`);
	                }
	                this.responseMap.delete(message.callbackIdx); //remove processed callback
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< EppService::onResponse");
	        }

	        /**
	         * Merges optional updateData and fires event for current claim status
	         * @param updateData
	         * @fires Wincor.UI.Service.EppService#SERVICE_EVENTS:CLAIM_STATUS_CHANGED
	         */
	        fireClaimStatusChanged(updateData) {
	            if (!this.hasReceivers(this.SERVICE_EVENTS.CLAIM_STATUS_CHANGED)) {
	                return;
	            }

	            updateData = updateData || {};
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> EppService::fireClaimStatusChanged('${JSON.stringify(updateData)}')`);

	            /*
	             * Sample data:
	             * {
	             *  "F1":{
	             *          status: "ENABLED",  // tells if the current claiming is ENABLED/DISABLED due to higher prioritized claims of other UI instance
	             *          claims: 3           // number of claims due to e.g. popUp
	             *      }
	             * }
	             *
	             * */
	            let keys = Object.keys(this.claimingData);
	            keys.forEach(key => {
	                let data = updateData[key];
	                if (data) {
	                    // add unknown EPP keys to the map to be more flexible for enhanced/different EPP types
	                    if (!(key in this.claimingData)) {
	                        this.claimingData[key] = { status: "RELEASED", claims: 0 };
	                    }
	                    if ("status" in data) {
	                        this.claimingData[key].status = data.status;
	                    }
	                    if ("claims" in data) {
	                        this.claimingData[key].claims = data.claims;
	                    }
	                }
	            });
	            if (keys.length > 0) {
	                // Clone the claimingData object
	                this.fireServiceEvent(this.SERVICE_EVENTS.CLAIM_STATUS_CHANGED, jQuery.extend(true, {}, this.claimingData));
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< EppService::fireClaimStatusChanged");
	        }

	        /**
	         * Event will be triggered on incoming message for EppService
	         * @param {Object} message
	         */
	        onEvent(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> EppService::onEvent('${JSON.stringify(message)}')`);
	            if (message) {
	                let delegates;
	                let msgKey = message.key;
	                if (message.methodName === "KeyPressed") {
	                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. KeyPressed(), key: '${msgKey}'.`);
	                    //check for registered callbacks for this key
	                    if (_eppKeyPressed2CallbackMap.has(msgKey)) {
	                        delegates = _eppKeyPressed2CallbackMap.get(msgKey);
	                        if (delegates) {
	                            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, ". KeyPressed(): calling delegate!");
	                            // The new claim handling expects all handlers to be informed
	                            let activeFunctionCalled = false;
	                            let beepAllowedFromCallbacks = true;
	                            delegates.forEach(delegateObj => {
	                                try {
	                                    // delegates can return "true" if an action was done that requires us to beep
	                                    let ret = delegateObj.callback(msgKey);
	                                    if (ret === false) {
	                                        // callbacks can explicitly silence beeping by returning "false"
	                                        // no direct assignment to ret here, because of different meaning of false and undefined
	                                        beepAllowedFromCallbacks = false;
	                                    }
	                                    activeFunctionCalled |= ret;
	                                } catch (e) {
	                                    _logger.error(`Epp event ${msgKey} caught exception ${e.message} for ${delegateObj.callback}`);
	                                }
	                            });
	                            const beepService = this.serviceProvider.BeepService;
	                            const adaService = this.serviceProvider.AdaService;
	                            const eppInactiveKeyCode = beepService.beepInactiveKeyCode;
	                            // Beep warning if ADA not ON, basically the BeepService checks whether beeping is allowed!
	                            // Before we beep a warning we have to be aware of the fact whether this execution source was really an EPP key event and not any other,
	                            // e.g. programmatically calls of command execute!
	                            // We assume that a command which is claimed owns a valid claim id.
	                            if (beepAllowedFromCallbacks && adaService.state !== adaService.STATE_VALUES.SPEAK) {
	                                if (activeFunctionCalled) {
	                                    beepService.beep(); // warning beep
	                                } else {
	                                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. EppService::onEvent trigger warning beep for inactive EPP key '${message.key}' with beep code=${eppInactiveKeyCode}`);
	                                    beepService.beep(eppInactiveKeyCode); // warning beep
	                                }
	                            } else {
	                                _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. EppService::onEvent ada active, skipping beep`);
	                            }
	                        } else {
	                            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. KeyPressed(): delegate for key: '${msgKey}' is null.`);
	                        }
	                    } else {
	                        _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. KeyPressed(): No callback found for key: '${msgKey}'.`);
	                    }
	                    //sending acknowledge! Gui.dll is waiting for this, because pressed EPP keys must be handled synchronously to avoid mixing up the sequence in input fields if
	                    //the keys are pressed quickly.
	                    let acknowledgeMsg = {};
	                    acknowledgeMsg.service = this.NAME;
	                    acknowledgeMsg.eventName = "KeyPressedHandled";
	                    this.sendEvent(acknowledgeMsg);
	                } else if (message.methodName === "ClaimStatusChange") {
	                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. ClaimStatusChange(), key: '${msgKey}', status: '${message.status}'`);

	                    //check for registered callbacks for this key
	                    if (_eppKeyStatusChanged2CallbackMap.has(msgKey)) {
	                        delegates = _eppKeyStatusChanged2CallbackMap.get(msgKey);
	                        let updateData = {};
	                        updateData[msgKey] = {
	                            status: message.status,
	                            claims: _eppKeyPressed2CallbackMap.get(msgKey).length
	                        };
	                        this.fireClaimStatusChanged(updateData);
	                        if (delegates) {
	                            // The new claim handling expects all handlers to be informed
	                            delegates.forEach(claimObject => {
	                                try {
	                                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. ClaimStatusChange: calling delegate with claimId ${claimObject.id}`);
	                                    claimObject.callback(msgKey, message.status);
	                                } catch (e) {
	                                    _logger.error(`Epp event ${msgKey} caught exception ${e.message} for ${claimObject.callback}`);
	                                }
	                            });
	                        } else {
	                            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. ClaimStatusChange(): delegate for key: '${msgKey}' is null.`);
	                        }
	                    } else {
	                        _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. ClaimStatusChange(): No callback found for key: '${msgKey}'.`);
	                    }
	                }
	            } else {
	                _logger.error("Epp event message is undefined !");
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< EppService::onEvent");
	        }

	        /**
	         * Claim keys that should be able to use.
	         * @param {Array} keys "F1","F2","F3","F4","F5","F6","F7","F8","F9", "0","1","2","3","4","5","6","7","8","9","R","L", "CONFIRM","CANCEL","HELP","CLEAR","BACKSPACE", "*"
	         * @param {number} prio -1=configured prio
	         * @param {function} callbackClaim The callback will receive a claiming result object containing the claimId to be used for releasing and the status of claiming for the single keys.
	         * @param {function} callbackKeyPressedEvent Called for receiving the key pressed events
	         * @param {function} callbackClaimStatusChange Called for receiving claim status change events
	         */
	        claimKeys(keys, prio, callbackClaim, callbackKeyPressedEvent, callbackClaimStatusChange) {
	            _claimId++;
	            if (_claimId === Number.MAX_VALUE) {
	                _claimId = 1;
	            }
	            // add claim id as attribute to all available function objects
	            let markedCallback;
	            // callback might always be the same function of caller, so wrap and mark with id to be able to pass the id with result in onResponse for our claim request
	            if (callbackClaim) {
	                markedCallback = function(cb) {
	                    return cb;
	                }.bind(null, callbackClaim);
	                markedCallback.claimId = _claimId;
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> EppService::claimKeys(keys: ${keys} prio:${prio} id: ${_claimId}`);
	            if (!prio || prio === -1) {
	                prio = this.prio;
	            }

	            // save to key -> callback mapping!
	            for (let i = 0; i < keys.length; i++) {
	                if (!_eppKeyPressed2CallbackMap.has(keys[i])) {
	                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. claiming key: '${keys[i]}'. setting callback...`);
	                    _eppKeyPressed2CallbackMap.set(keys[i], [{ id: _claimId, callback: callbackKeyPressedEvent }]);
	                } else {
	                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. already claimed key: '${keys[i]}'. Adding callback...`);
	                    _eppKeyPressed2CallbackMap.get(keys[i]).push({ id: _claimId, callback: callbackKeyPressedEvent });
	                }

	                if (callbackClaimStatusChange) {
	                    if (!_eppKeyStatusChanged2CallbackMap.has(keys[i])) {
	                        _eppKeyStatusChanged2CallbackMap.set(keys[i], [{ id: _claimId, callback: callbackClaimStatusChange }]);
	                    } else {
	                        _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. already claimed key: '${keys[i]}'. Adding callback...`);
	                        _eppKeyStatusChanged2CallbackMap.get(keys[i]).push({ id: _claimId, callback: callbackClaimStatusChange });
	                    }
	                }
	            }

	            // multiple claims seem not to be a problem, so just route it through... otherwise result object would not be available
	            this.FRM_RESOLVE_REQUEST.FWFuncID = 4002; //pce::eppsync::FUNC_CLAIM_KEYS
	            this.FRM_RESOLVE_REQUEST.param1 = this.serviceProvider.ConfigService.configuration.instanceName;
	            this.FRM_RESOLVE_REQUEST.meta1 = ["CHAR_ANSI", -1];
	            this.FRM_RESOLVE_REQUEST.param2 = keys;
	            this.FRM_RESOLVE_REQUEST.meta2 = ["PARLIST_ANSI", -1];
	            this.FRM_RESOLVE_REQUEST.param3 = [];
	            this.FRM_RESOLVE_REQUEST.meta3 = ["PARLIST_ANSI", 2048];
	            this.FRM_RESOLVE_REQUEST.param4 = this.GUI_COMM_CALLBACK_EPPKEY_PRESSED;
	            this.FRM_RESOLVE_REQUEST.meta4 = ["SHORT", 0];
	            this.FRM_RESOLVE_REQUEST.param5 = this.GUI_COMM_CALLBACK_EPPCLAIM_STATUS_CHANGE;
	            this.FRM_RESOLVE_REQUEST.meta5 = ["SHORT", 0];
	            this.FRM_RESOLVE_REQUEST.paramUL = prio;

	            _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, markedCallback);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< EppService::claimKeys");
	        }

	        /**
	         * Release claimed keys after usage.
	         * @param {number} claimId The id returned by the claim result member result.claimId
	         * @param callback function pointer
	         */
	        releaseKeys(claimId, callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> EppService::releaseKeys(${claimId})`);
	            if (claimId < 0) {
	                _logger.error(`EPPService::releaseKeys invalid claimId ${claimId} given callback: \n ${callback}`);
	            }
	            let keysToRelease = [];
	            let doRelease = false;
	            // remove from key -> callback mapping!
	            let updateData = {};
	            // walk through map and find the entries with the claim id
	            let claims;
	            for (let [key, resultsArray] of _eppKeyPressed2CallbackMap.entries()) {
	                resultsArray = resultsArray.filter(entry => entry.id !== claimId);
	                claims = resultsArray.length;
	                if (claims > 0) {
	                    _eppKeyPressed2CallbackMap.set(key, resultsArray);
	                } else {
	                    _eppKeyPressed2CallbackMap.delete(key);
	                }

	                updateData[key] = {
	                    claims: claims
	                };
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. EppService::releaseKeys remaining callbacks for ${key}: ${claims}`);
	                if (claims === 0) {
	                    keysToRelease.push(key);
	                    doRelease = true;
	                    updateData[key].status = "RELEASED";
	                }

	                if (_eppKeyStatusChanged2CallbackMap.has(key)) {
	                    resultsArray = _eppKeyStatusChanged2CallbackMap.get(key).filter(entry => entry.id !== claimId);
	                    if (resultsArray.length > 0) {
	                        _eppKeyStatusChanged2CallbackMap.set(key, resultsArray);
	                    } else {
	                        _eppKeyStatusChanged2CallbackMap.delete(key);
	                    }
	                }
	            }

	            this.fireClaimStatusChanged(updateData);

	            if (doRelease) {
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. releasing keys -> ${keysToRelease}`);
	                this.FRM_RESOLVE_REQUEST.FWFuncID = 4003; //pce::eppsync::FUNC_RELEASE_KEY
	                this.FRM_RESOLVE_REQUEST.param1 = this.serviceProvider.ConfigService.configuration.instanceName;
	                this.FRM_RESOLVE_REQUEST.meta1 = ["CHAR_ANSI", -1];
	                this.FRM_RESOLVE_REQUEST.param2 = keysToRelease;
	                this.FRM_RESOLVE_REQUEST.meta2 = ["PARLIST_ANSI", -1];
	                this.FRM_RESOLVE_REQUEST.param3 = [];
	                this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];

	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	                this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	            } else {
	                window.setTimeout(callback, 1);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< EppService::releaseKeys");
	        }

	        /**
	         * Get number of FDKs available on this machine
	         * @returns {number}
	         * @async
	         */
	        async getNumberOfFDKs() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> EppService::getNumberOfFDKs()");
	            this.FRM_RESOLVE_REQUEST.FWFuncID = 8; //eppfw.InfCmdFuncKeyDetail
	            this.FRM_RESOLVE_REQUEST.param1 = 0;
	            this.FRM_RESOLVE_REQUEST.meta1 = ["ULONG", 0];
	            this.FRM_RESOLVE_REQUEST.param2 = 0;
	            this.FRM_RESOLVE_REQUEST.meta2 = ["HEX", 16000];
	            this.FRM_RESOLVE_REQUEST.param3 = [];
	            this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];

	            _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            return new Promise((resolve, reject) => {
	                let numberFDKs = 0;
	                this.FrmResolve(this.FRM_RESOLVE_REQUEST, message => {
	                    if (message.RC === 0) {
	                        /*
	                            typedef struct _pin_funckey_detail
	                            {
	                                ULONG       ulFuncMask;     -> byte 0-7
	                                USHORT      usNumberFDKs;   -> byte 8-12 <-   we want this USHORT
	                                PIN_FDK     aPinFDK[LNG_PINFDK_M+1]; -> rest
	                            } PIN_FUNCKEY_DETAIL, * LPPIN_FUNCKEY_DETAIL;
	                        */
	                        numberFDKs = parseInt(
	                            message.param2
	                                .slice(8, 12)
	                                .match(/.{1,2}/g)
	                                .reverse()
	                                .join(""),
	                            16
	                        );
	                        _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< EppService::getNumberOfFDKs returns <${numberFDKs}>`);
	                        resolve(numberFDKs);
	                    } else {
	                        _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< EppService::getNumberOfFDKs returned error <${message.RC}>`);
	                        reject();
	                    }
	                });
	            });
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseService#onServicesReady}
	         * Reads the configuration for "ClaimKeysPrio" during initialization
	         *
	         * @async
	         * @lifecycle service
	         */
	        async onServicesReady() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> EppService::onServicesReady()");
	            let viewService = this.serviceProvider.ViewService;
	            viewService.registerForServiceEvent(
	                viewService.SERVICE_EVENTS.SHUTDOWN,
	                () => {
	                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "* EppService::onServicesReady() content shutdown in progress - release all EPP keys");
	                    let tempEppKeyPressed2CallbackMap = new Map(_eppKeyPressed2CallbackMap);
	                    for(let [key, resultsArray] of tempEppKeyPressed2CallbackMap) {
	                        resultsArray.forEach(item => {
	                            this.releaseKeys(item.id);
	                        });
	                    }
	                    _eppKeyPressed2CallbackMap.clear();
	                    _eppKeyStatusChanged2CallbackMap.clear();
	                },
	                true
	            );

	            let generalSection = `${Wincor.UI.Service.Provider.ConfigService.configuration.instanceName}\\Services\\General`;
	            let key = "ClaimKeysPrio";
	            let result = await Wincor.UI.Service.Provider.ConfigService.getConfiguration(generalSection, [key]);
	            if(result) {
	                if(result[key] === "") {
	                    this.prio = 4;
	                } else {
	                    this.prio = result[key];
	                }
	            }
	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* EppService::onServicesReady(): prio=${this.prio}`);
	            await super.onServicesReady();

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< EppService::onServicesReady");
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ EppServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$7 = getServiceClass$a({
	    Wincor: Wincor$2,
	    jQuery: jQuery$2,
	    LogProvider,
	    PTService
	});

	const ServiceInterface$7 = {
	    EppProxy: {
	        service: "../service/wn.UI.Service.EppService.js",
	        interface: {
	            Expand_StringDefines: {
	                attributes: [
	                    "BUTTONEPP_F1",
	                    "BUTTONEPP_F2",
	                    "BUTTONEPP_F3",
	                    "BUTTONEPP_F4",
	                    "BUTTONEPP_F5",
	                    "BUTTONEPP_F6",
	                    "BUTTONEPP_F7",
	                    "BUTTONEPP_F8",
	                    "BUTTONEPP_F9",
	                    "BUTTONEPP_0",
	                    "BUTTONEPP_1",
	                    "BUTTONEPP_2",
	                    "BUTTONEPP_3",
	                    "BUTTONEPP_4",
	                    "BUTTONEPP_5",
	                    "BUTTONEPP_6",
	                    "BUTTONEPP_7",
	                    "BUTTONEPP_8",
	                    "BUTTONEPP_9",
	                    "BUTTONEPP_CONFIRM",
	                    "BUTTONEPP_CANCEL",
	                    "BUTTONEPP_HELP",
	                    "BUTTONEPP_CLEAR",
	                    "BUTTONEPP_BACKSPACE",
	                    "BUTTONEPP_STAR",
	                    "BUTTONEPP_CORRECT",
	                    "BUTTONEPP_EDIT",
	                    "BUTTONEPP_R",
	                    "BUTTONEPP_L",
	                    "CLAIMSTATUS_DENIED",
	                    "CLAIMSTATUS_ENABLED",
	                    "CLAIMSTATUS_DISABLED",
	                    "CLAIMSTATUS_DENIED_BUT_ENABLED",
	                    "CLAIMSTATUS_DENIED_BUT_DISABLED"
	                ],
	                type: "string",
	                writable: false
	            },
	            SERVICE_EVENTS: {
	                type: "object",
	                keys: ["CLAIM_STATUS_CHANGED"],
	                writable: false
	            },
	            claimKeys: {
	                type: "function",
	                callbackArgumentIndex: 2
	            },
	            releaseKeys: {
	                type: "function",
	                callbackArgumentIndex: 1
	            },
	            getNumberOfFDKs: {
	                type: "function"
	            }
	        }
	    }
	};

	var EppService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$7,
		ServiceClass: ServiceClass$7
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.



	$MOD$ wn.UI.Service.EventService.js 4.3.1-210203-21-1b8704b6-1a04bc7d
	 */

	/**
	 * @module
	 */
	const getServiceClass$b = ({ Wincor, ext, LogProvider, PTService, EventInfoList }) => {
	    /**
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;

	    return class EventService extends PTService {

	        /**
	         * Map containing the current event registrations
	         * An entry in this map consists of:
	         * @example
	         * key   = moduleName {string}
	         * value = [EventRegstration1, EventRegstration2, ...]  (Array of EventRegistration objects) {@link Wincor.UI.Service.EventService#EventRegistration}
	         * @type {Map}
	         */
	        registerMap = new Map();

	        /**
	         * The registration counter.
	         * @private
	         */
	        regIdxCounter = 0;

	        /**
	         * "EventService" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {String}
	         */
	        NAME = "EventService";
	        
	        /**
	         * Extended message literal providing Protopas specific data
	         */
	        FRM_REGISTER_FOR_EVENTS = null;
	        
	        /**
	         * Extended message literal providing Protopas specific data
	         */
	        FRM_DEREGISTER_FOR_EVENTS = null;
	        
	        /*
	         * Extended message literal providing Protopas specific data
	         */
	        
	        /**
	         * Method name for Protopas bus call, to register for events
	         * @const
	         */
	        METHOD_FRM_REGISTER_FOR_EVENTS = "RegisterForEvents";
	        
	        /**
	         * Method name for Protopas bus call, to deregister for events
	         * @const
	         */
	        METHOD_FRM_DEREGISTER_FOR_EVENTS = "DeregisterForEvents";

	        /**
	         * An object of EventRegistration is created every time, when s.o. registers for an event.
	         * @class
	         */
	        EventRegistration = function() {
	            /**
	             * The ID of the event
	             * @type {string}
	             */
	            this.eventId = null;    //the registered event

	            /**
	             * The registration index.
	             * An unique index for every registration, needed for deregistration (compare to setTimeout/clearTimeout)
	             * @type {number}
	             */
	            this.regIdx = null;     //an unique index for every registration, needed for deregistration (compare to setTimeout/clearTimeout)

	            /**
	             * A callback function that is called when the event is triggered.
	             * @type {function}
	             */
	            this.callback = null;   //this callback is called when the event is triggered

	            /**
	             * Specifies the type of data which is send via the event.
	             * @type {string}
	             */
	            this.dataType = null;   //specifies the type of data which is send via the event

	            /**
	             * If the registration is persistent (true), a content-page unload will not remove the registration, false otherwise.
	             * @type {boolean}
	             */
	            this.persistent = false; //if registration is persistent, a content-page unload will not remove the registration
	        };

	        /**
	         * See {@link Wincor.UI.Service.PTService#constructor}.
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> EventService::EventService");

	            //setup message / events

	            this.FRM_REGISTER_FOR_EVENTS = Object.assign(Object.assign({}, this.REQUEST), {
	                service: this.NAME,
	                methodName: this.METHOD_FRM_REGISTER_FOR_EVENTS,
	                RC: -1,
	                FWName: "",
	                FWEventID: -1,
	                DataType: "HEX"
	            });

	            this.FRM_DEREGISTER_FOR_EVENTS = Object.assign(Object.assign({}, this.REQUEST), {
	                service: this.NAME,
	                methodName: this.METHOD_FRM_DEREGISTER_FOR_EVENTS,
	                RC: -1
	            });
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< EventService::EventService");
	        }
	        
	        /**
	         * Gets the event info from the event owner list.
	         * The caller has to know the module name and the id definition name.
	         * <p>The event owners and IDs are configured in configuration file <a href="./EventInfoList.json">EventInfoList.json</a></p>
	         * @param {String} name Name of the owner as defined in EventInfoList.json
	         * @returns {Object} An object containing the name (NAME) of the owner and one or more event ids or an empty object in case of error
	         */
	        getEventInfo(name) {
	            if(name in EventInfoList) {
	                return EventInfoList[name];
	            } else {
	                _logger.log(_logger.LOG_ERROR, `Unknown event module name ${name} not in event owner list available.`);
	                return {};
	            }
	        }

	        /**
	         * This method will be triggered on message receive
	         * @param {Object} message
	         * @eventhandler native
	         */
	        onEvent(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> EventService::onEvent('${JSON.stringify(message)}')`);

	            if(message && message.methodName === this.EVENT_ON_FRM_EVENT && this.registerMap.has(message.FWName)) {
	                try {
	                    let delegate = null;
	                    for(let [module, regEventArray] of this.registerMap) {
	                        if(module === message.FWName) {
	                            for(let i = regEventArray.length - 1; i >= 0; i--) {
	                                if(regEventArray[i].eventId === null || regEventArray[i].eventId == message.FWEventID) { //Do not use '===' for FWEventID here !
	                                    delegate = regEventArray[i].callback;
	                                    if(typeof delegate === "function") {
	                                        delegate(message.FWEventParam, message.FWEventID, message.FWName);
	                                    } else {
	                                        _logger.log(_logger.LOG_ERROR, `. Error! Delegate is ${typeof delegate}`);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                    message.ack = "OK";
	                } catch(e) {
	                    // Provider writes error-log
	                    Wincor.UI.Service.Provider.propagateError(this.NAME, this.ERROR_TYPE.EVENT, e);
	                    message.ack = "ERROR";
	                }
	            } else {
	                _logger.log(_logger.LOG_ERROR, `. unknown event or framework message=${JSON.stringify(message)}`);
	                message.ack = "UNKNOWN";
	            }

	            this.sendEvent(message); //send acknowledge. message.ack will contain the details (OK / ERROR / UNKNOWN)
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< EventService::onEvent");
	        }

	        /**
	         * Used to de-register a specific or all non persistent business logic events
	         * @param {number} regIdx id previously returned by registerForEvent or -1 to de-register all non-persistent registrations
	         * @param {function=} callbackDeregister
	         */
	        deregisterEvent(regIdx, callbackDeregister) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> EventService::deregisterEvent(${regIdx})`);
	            let foundModule = null, message;
	            for(let [module, regEventArray] of this.registerMap) {
	                for(let i = regEventArray.length - 1; i >= 0; i--) {
	                    if(regIdx === -1) {
	                        if(!regEventArray[i].persistent) {
	                            regEventArray.splice(i, 1);
	                            if(regEventArray.length === 0) {
	                                this.registerMap.delete(module);
	                                message = Object.assign(Object.assign({}, this.FRM_DEREGISTER_FOR_EVENTS), { FWName: module });
	                                this.sendRequest(message, callbackDeregister);
	                            }
	                        }
	                    } else if(regEventArray[i].regIdx === regIdx) {
	                        foundModule = module;
	                        regEventArray.splice(i, 1);
	                        if(regEventArray.length === 0) {
	                            this.registerMap.delete(module);
	                            message = Object.assign(Object.assign({}, this.FRM_DEREGISTER_FOR_EVENTS), { FWName: foundModule });
	                            this.sendRequest(message, callbackDeregister);
	                        }
	                        break;
	                    }
	                }
	                if(foundModule) {
	                    break;
	                }
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< EventService::deregisterEvent");
	        }

	        /**
	         * Use this function to register for business logic events.
	         * The function returns an ID, that must be used when you call deregisterEvent()
	         * @param {Number} event The event ID, 'null' for ALL events of a moduleName
	         * @param {String} moduleName The moduleName that sends the event (normally ProTopas framework)
	         * @param {Function} callbackEvent Callback function receiving (FWEventParam, FWEventID, FWName) method that is called if the event is triggered
	         * @param {Function} callbackRegister Callback function receiving message object. Can be used to check whether registration was successful or not, check message.RC
	         * @param {String} dataType Type of event data which is expected: "HEX", "ASCII", "UTF-8"
	         * @param {Boolean=} persistent (default: false) If registered with persistent=true, the registration will not be automatically removed on page deactivation.
	         * @return {Number} registrationID Used for manual de-registration.
	         */
	        registerForEvent(event, moduleName, callbackEvent, callbackRegister, dataType, persistent) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> EventService::registerForEvent(${event}, ${moduleName}, ..., ..., ${dataType}, ${persistent})`);

	            this.regIdxCounter++;

	            //build the new EventRegistration object and add it to the map
	            let reg = new this.EventRegistration();
	            reg.regIdx = this.regIdxCounter;
	            reg.eventId = event;
	            reg.callback = callbackEvent;
	            reg.dataType = dataType;
	            reg.persistent = persistent || false;

	            let regArray = [];

	            if (this.registerMap.has(moduleName)) {
	                regArray = this.registerMap.get(moduleName);
	            }

	            regArray.push(reg);
	            this.registerMap.set(moduleName, regArray);


	            //build the ProTopas message and send it
	            const message = Object.assign({}, this.FRM_REGISTER_FOR_EVENTS);
	            message.FWName = moduleName;
	            message.FWEventID = event;  //actually we do not need this for event registration, because in
	                                        //ProTopas we always register for ALL events of a framework. However, we
	                                        //we send this data, so that the callbackRegister method may use this field.
	            message.DataType = dataType;

	            this.sendRequest(message, callbackRegister);

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< EventService::registerForEvent returns regId: ${this.regIdxCounter}`);
	            return this.regIdxCounter;
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseService#onSetup}
	         * <p>Used to read the configured event mappings from <a href="./EventInfoList.json">EventInfoList.json</a></p>
	         *
	         * @param {object} message
	         * @returns {Promise}
	         * @eventhandler native
	         * @lifecycle service
	         */
	        onSetup(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> EventService::onSetup('${JSON.stringify(message)}')`);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< EventService::onSetup");
	            return Promise.resolve();
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseService#onServicesReady}
	         * Registers for {@link Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_CLOSING} to deregister non-persistent event registrations when a view deactivates.
	         *
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onServicesReady() {
	            return ext.Promises.promise((resolve, reject) => {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> EventService::onServicesReady()");
	                // every time a content-page is closing, we have to de-register the non persistent registrations
	                const ds = this.serviceProvider.ViewService;
	                ds.registerForServiceEvent(ds.SERVICE_EVENTS.VIEW_CLOSING, this.deregisterEvent.bind(this, -1, null), true);
	                super.onServicesReady().then(resolve);
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< EventService::onServicesReady");
	            });
	        }
	    }
	};

	var TRANSACTION_MODULE = {
		NAME: "CCTransactionFW",
		ID_CARD: 10008,
		ID_CASH: 10012,
		ID_DEPOSIT: 10013,
		ID_ESCALATION: 10007,
		ID_CURRENCY_CHANGE: 10014,
		ID_SESSION_END: 10002
	};
	var EPP_MODULE = {
		NAME: "CCEppFW",
		ID_ENTER_DATA: 11,
		ID_ETS_LAYOUT_MOVED: 13
	};
	var GUIAPP_MODULE = {
		NAME: "GUIAPP",
		ID_STATUS_CHANGED: 4004,
		ID_POPUP_NOTIFICATION: 4021
	};
	var GUIDM_MODULE = {
		NAME: "GUIDM",
		ID_STATUS_CHANGED: 4004
	};
	var EventInfoList = {
		TRANSACTION_MODULE: TRANSACTION_MODULE,
		EPP_MODULE: EPP_MODULE,
		GUIAPP_MODULE: GUIAPP_MODULE,
		GUIDM_MODULE: GUIDM_MODULE
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ EventServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$8 = getServiceClass$b({
	    Wincor: Wincor$2,
	    ext: ext$2,
	    LogProvider,
	    PTService,
	    EventInfoList
	});

	const ServiceInterface$8 = {
	    EventProxy: {
	        service: '../service/wn.UI.Service.EventService.js',
	        interface: {
	            registerForEvent: {
	                type: 'function'
	            },
	            deregisterEvent: {
	                type: 'function',
	                callbackArgumentIndex: 1
	            },
	            getEventInfo: {
	                type: 'function'
	            }
	        }
	    }
	};

	var EventService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$8,
		ServiceClass: ServiceClass$8
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.



	$MOD$ wn.UI.Service.FormatService.js 4.3.1-210203-21-1b8704b6-1a04bc7d
	 */

	/**
	 * @module
	 */
	const getServiceClass$c = ({ jQuery, ext, LogProvider, PTService }) => {

	    /**
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;

	    let _localizeService;
	    let _configService;

	    function addGroupSeparator(nStr, decSep, separator) {
	        nStr += '';
	        let x = nStr.split(decSep);
	        let x1 = x[0];
	        let x2 = x.length > 1 ? decSep + x[1] : '';
	        let rgx = /(\d+)(\d{3})/;
	        while(rgx.test(x1)) {
	            x1 = x1.replace(rgx, `$1${separator}$2`);
	        }
	        return x1 + x2;
	    }

	    return class FormatService extends PTService {

	        /**
	         * "FormatService" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "FormatService";

	        /**
	         * Contains the current banking context data from the business logic.
	         * It is set by {@link module:ProFlex4Op}.
	         *
	         * The FormatSerive uses the -currencyData attribute, which can look like this:
	         * <br><code>
	         *     bankingContext.currencyData = { iso: "EUR", text: "Euro", ada: "Euro", symbol: "€", exponent: "-2" }
	         * </code>
	         */
	        bankingContext = {};

	        /**
	         * The configuration object contains language specific attributes which are necessary for general formatting.
	         * To each supported ISO code, there is specific set of assigned parameters, which match the formatting parameters of the Localization configuration in the registry.
	         * ```
	         * config: {
	         *   "de-DE": {
	         *       "CurrDecimalSep": ",",
	         *       "NumGroupSep": ".",
	         *       "CurrServerValueOffset": -2,
	         *       "NumDecimalSep": ",",
	         *       "NumGrouping": 3,
	         *       "CurrPositiveOrder": 1,
	         *       "CurrGroupSep": ".",
	         *       "CurrNegativeOrder": 8,
	         *       "CurrNumDigits": 2,
	         *       "NumNegativeOrder": 1,
	         *       "NumNumDigits": 2,
	         *       "CurrCurrencySymbol": "EUR",
	         *       "CurrGrouping": 3,
	         *       "NumLeadingZero": 1,
	         *       "CurrLeadingZero": 1
	         *   },
	         *   "en-US": {
	         *       "CurrDecimalSep": ".",
	         *       "NumGroupSep": ",",
	         *       "CurrServerValueOffset": -2,
	         *       "NumDecimalSep": ".",
	         *       "NumGrouping": 3,
	         *       "CurrPositiveOrder": 0,
	         *       "CurrGroupSep": ",",
	         *       "CurrNegativeOrder": 8,
	         *       "CurrNumDigits": 2,
	         *       "NumNegativeOrder": 1,
	         *       "NumNumDigits": 2,
	         *       "CurrCurrencySymbol": "$",
	         *       "NumLeadingZero": 1,
	         *       "CurrLeadingZero": 1,
	         *       "CurrGrouping": 3
	         * }
	         *   ```
	         * @type {Object}
	         */
	        config = {};

	        /**
	         * See {@link Wincor.UI.Service.PTService#constructor}.
	         * Inititializes the FormatService-specific FRM_RESOLVE_REQUEST parameters, so that the CCFormat module is used.
	         *
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> FormatService::FormatService");

	            this.FRM_RESOLVE_REQUEST.service = this.NAME;
	            this.FRM_RESOLVE_REQUEST.FWName = "CCFormat";
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< FormatService::FormatService");
	        }
	        
	        /**
	         * This method formats the given value string depending on the formatOption.
	         *
	         * At least the format options, which are invoked synchronously, must be implemented in "formatHelper()".
	         * But also for asynchronous requests we call "formatHelper()" if the format option is implemented there.
	         *
	         * @param {String | Object} value           The value to be formatted.<br>
	         *                                          In case of synchronous format handling (isSynchronous must be true) this argument must be an object
	         *                                          in the following format:    <br>
	         *                                          <code>{raw: 'unformatted value'}</code>
	         * @param {string} formatOption             The formatOption defines how to format the value.
	         * @param {function({Object})} callback     The callback will get the result as an object:<br>
	         *                                          <code> {raw: "unformatted value", result: "formatted value"} </code>
	         * @param {boolean=} isSynchronous          True, if the caller needs to handle the format call in a synchronous way.<br>
	         *                                          In this case the value argument must be a plain object where the result is turned back afterwards.
	         *                                          Please note which formatOption can handle a synchronous format invocation:<br>
	         * @example
	         *                                          value=1000  (1000cent)
	         *                                          <ul>
	         *                                              <li>'#C' ->      10.00</li>
	         *                                              <li>'#M' ->     € 10.00</li>
	         *                                              <li>'#ATRM0' -> € 10</li>
	         *                                              <li>'#aTRM0' -> 10</li>
	         *                                              <li>'#SSN' -> 123-45-6789</li>
	         *                                              <li>'#i' ->      10 -> deprecated, please use #aTRM0 instead</li>
	         *                                              <li>'#X*' ->     **</li>
	         *                                              <li>'#x+-4:4'->  xxxxxx1234 -> The char after the '#' is the char ('x') to mask with</li>
	         *                                              <li>'#X+-4:4'->  XXXXXX1234 -> The char after the '#' is the char ('X') to mask with</li>
	         *                                              <li>'#*+-4:4'->  ******1234 -> The char after the '#' is the char ('*') to mask with</li>
	         *                                              <li>'#conditional{'key1':'val1','key2':'val2',...}' -> val1 if value===key1, val2 if value===key2, otherwise unchanged value</li>
	         *                                          </ul>
	         *                                          All other format options must be handled asynchronous, no matter if "isSynchronous" is true, false or even undefined.
	         */
	        format(value, formatOption, callback, isSynchronous) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> FormatService::format(value=${value}, formatOption='${formatOption}', isSynchronous=${isSynchronous})`);

	            if (!isSynchronous && (!callback || typeof callback !== "function")) {
	                _logger.error(`FormatService::format received non-function type <${typeof callback}> as callback argument!`);
	                return;
	            }

	            function formatCallback(message) {
	                try {
	                    callback({result: message.param3, raw: typeof value === 'object' ? value.raw : value});
	                } catch(exception) {
	                    _logger.error(`format callback failed ${exception}`);
	                }
	            }

	            // for the following options we use our own formatter currently...
	            if(formatOption &&
	                (formatOption === "#C" ||
	                 formatOption === "#i" || // deprecated and thus will be removed later, behavior is now same as '#aTRM0'
	                 formatOption === "#M" ||
	                 formatOption === "#ATRM0" ||
	                 formatOption === "#aTRM0" ||
	                 formatOption === "#SSN" ||
	                 formatOption.indexOf("#X") === 0 ||
	                 formatOption.indexOf("+-") === 2) ||
	                 formatOption.indexOf("#conditional") === 0) {

	                if(!isSynchronous) {
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, ". FormatService::format callback call");
	                    //Issue 1746190: removed setTimeout (in previous revision), which called the callback. This was not needed and led high performance issues on some systems.
	                    callback({result: this.formatHelper(typeof value === 'object' ? value.raw : value, formatOption) });
	                } else if(typeof value === 'object' && value.raw !== void 0) {
	                    value.result = this.formatHelper(value.raw, formatOption);
	                } else {
	                    _logger.error("Wrong format arguments. Please check argument in order to handle format call in a synchronous way.");
	                }
	            } else if(!formatOption) { // case with no format option given
	                if(!isSynchronous) {
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, ". FormatService::format callback call (no format option)");
	                    callback({result: typeof value === 'object' ? value.raw : value});
	                } else if(typeof value === 'object' && value.raw !== void 0) {
	                    value.result = value.raw;
	                } else {
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, ". FormatService::format Warning: callback call (value is not an object or no 'raw' attribute given)");
	                    if (callback) {
	                        callback(value);
	                    }
	                }
	            } else {
	                if(isSynchronous) {
	                    _logger.LOG_ANALYSE && _logger.log( _logger.LOG_ANALYSE, `Warning: Argument formatOption contains pattern '${formatOption}' which can not be handled in a synchronous way.`);
	                    if(typeof value === 'object' && value.raw !== void 0) {
	                        value.result = value.raw;
	                    } else {
	                        _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, ". FormatService::format Warning: callback call (value is not an object or no 'raw' attribute given)");
	                        if (callback) {
	                            callback(value);
	                        }
	                    }
	                } else {
	                    let expectedLength = value.length < 1024 ? 1024 : value.length * 2;

	                    this.FRM_RESOLVE_REQUEST.FWFuncID = 3; //CCFORMAT_FUNC_FORMAT
	                    this.FRM_RESOLVE_REQUEST.param1 = formatOption;
	                    this.FRM_RESOLVE_REQUEST.meta1 = ["CHAR_ANSI", -1];
	                    this.FRM_RESOLVE_REQUEST.param2 = value;
	                    this.FRM_RESOLVE_REQUEST.meta2 = ["CHAR_ANSI", -1];
	                    this.FRM_RESOLVE_REQUEST.param3 = "";
	                    this.FRM_RESOLVE_REQUEST.meta3 = ["CHAR_ANSI", expectedLength];

	                    this.FrmResolve(this.FRM_RESOLVE_REQUEST, formatCallback.bind(this));
	                }
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< FormatService::format");
	        }

	        /**
	         * Implements various format options. Will be called by "format()" {@link Wincor.UI.Service.FormatService#format}
	         * to handle at least _all_ synchronous formatting, but also to handle implemented format options in an asynchronous way.
	         *
	         * Override this method in order to change the formatted output.
	         *
	         * @param {String} value The value to format.
	         * @param {String} pattern The format option.
	         * @returns {*}
	         */
	        formatHelper(value, pattern) {
	            const languageISO = _localizeService.currentLanguage;
	            const separator = this.config[languageISO].CurrDecimalSep;
	            const groupSep = this.config[languageISO].CurrGroupSep || "";
	            const order = this.config[languageISO].CurrPositiveOrder; //0: Prefix, 1: Suffix, 2+3 are not supported and treated as 0
	            const currencyExtension = this.bankingContext.currencyData.symbol || this.bankingContext.currencyData.iso;

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> FormatService::formatHelper(value=${value}, pattern='${pattern}), current languageISO=${languageISO}`);

	            let output = value;
	            let expAbs = Math.abs(this.bankingContext.currencyData.exponent); //Exponent
	    
	            if((pattern === "#C" || pattern === "#M") && jQuery.isNumeric(value)) { // 10.00 or 1,000.00 || € 10.00 or € 1,000.00
	                output = parseInt(value);
	                output /= Math.pow(10, expAbs);
	                output = parseFloat(output).toFixed(expAbs);
	                output = output.toString();
	                output = output.replace(".", separator);
	                output = addGroupSeparator(output, separator, groupSep); // 10.00 or 1,000.00
	                if(pattern === "#M") { // € 10.00 or € 1,000.00
	                    if(order === 1) {
	                        output = `${output} ${currencyExtension}`;
	                    } else { // 0 and others (2+3)
	                        output = `${currencyExtension} ${output}`;
	                    }
	                }
	            } else if((pattern === "#ATRM0" || pattern === "#aTRM0" || pattern === "#i") && jQuery.isNumeric(value)) { // € 0 or € 10 or € 1,000 (with group separator) or € 0.10 for a 10 cent coin instead of € 0.1
	                output = parseInt(value);
	                let fixIt = output && output < 100; // determine if its less than 1 EUR, but > 0
	                output /= Math.pow(10, expAbs);
	                if(fixIt) {
	                    output = parseFloat(output).toFixed(expAbs); // we want 0.10 for a 10 cent coin instead of 0.1
	                }
	                output = output.toString();
	                output = output.replace(".", separator);
	                output = addGroupSeparator(output, separator, groupSep); // 10 or 100 or 1.000 (with group separator)
	                if(pattern === "#ATRM0") { // € 0 or € 10 or € 1,000 (with group separator)
	                    if(order === 1) {
	                        output = `${output} ${currencyExtension}`;
	                    } else { // 0 and others (2+3)
	                        output = `${currencyExtension} ${output}`;
	                    }
	                } else if(pattern === "#i") {
	                    _logger.error(`FormatService::format Deprecated use of pattern '#i' found for viewkey=${this.serviceProvider.ViewService.viewContext.viewKey}, please use '#aTRM0' instead.`);
	                }
	            } else if(pattern ==="#SSN" && jQuery.isNumeric(value)) { // 123-45-6789
	                let outputSSNString = output.toString();
	                output = output.toString();
	                let len = outputSSNString.length;
	                switch (len) {
	                    case 1:
	                    case 2:
	                    case 3:
	                        break;
	                    case 4:
	                    case 5: outputSSNString = `${output.substr(0, 3)}-${output.substr(3, len - 3)}`;
	                        break;
	                    case 6:
	                    case 7:
	                    case 8:
	                    case 9:
	                        outputSSNString = `${output.substr(0, 3)}-${output.substr(3, 2)}-${output.substr(5, len - 5)}`;
	                        break;
	                }
	                output = outputSSNString;
	            } else if(pattern.indexOf("+-") === 2) { // #x+-4:4 xxxxxxx1234 or #*+-4:4 *******1234, the char after the '#' is the char to mask with
	                let len = value.length;
	                let res = "";
	                let maskChar = pattern.substr(1, 1);
	                let remainingLen = parseInt(pattern.substring(pattern.indexOf(":") + 1));
	                for(let i = 0; i < len - remainingLen; i++) {
	                    res += maskChar;
	                }
	                output = res + value.substring(len - remainingLen, len);
	            } else if(pattern.indexOf("#X") === 0) { // **********
	                output = output.toString().replace(/./g, pattern.substr(2)); // the part after the '#X' is the char to replace with
	            } else if(pattern.includes("#conditional")) {
	                try {
	                    let replacementObject = JSON.parse(pattern.replace("#conditional", ""));
	                    if(value in replacementObject) {
	                        output = replacementObject[value];
	                    } else if("*" in replacementObject){
	                        output = replacementObject["*"];
	                    } else {
	                        output = value;
	                    }
	                    if(typeof output === "string" && output.includes("$val")) {
	                        output = output.replace("$val", value);
	                    }
	                } catch(e) {
	                    _logger.error(`FormatService: Error formatting value=${value} with pattern=${pattern} exception: ${e.message}`);
	                    output = value;
	                }
	            } else {
	                if(value !== "" && pattern) { // in case of empty string we skip the log entry, since this could be the normal case in some circumstances
	                    if (!jQuery.isNumeric(value)) {
	                        _logger.error(`Can't format value='${value}' with pattern '${pattern}', because value is not a number`);
	                    } else {
	                        _logger.error(`Can't format value='${value}' with unknown pattern '${pattern}'`);
	                    }
	                }
	                output = value; // return original value
	            }

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< FormatService::formatHelper return '${output}'`);
	            return output;
	        }

	        /**
	         * Reads the configuration for formatting from the Registry section "Activex\\GraphicalService\\PCHtmlGen\\(language)" and stores it in {@link Wincor.UI.Service.FormatService#config}
	         * @param {Object} languageMapping the language mapping from the FormatService
	         * @returns {Promise}
	         */
	        readConfiguration(languageMapping) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> FormatService::readConfiguration(${JSON.stringify(languageMapping)})`);

	            const self = this;
	            const configPromises = [];

	            function confCallback(lang, formatConf) {
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. FormatService::readConfiguration confCallback(${lang}) - ${JSON.stringify(formatConf)}`);
	                for (const key in formatConf) {
	                    if (formatConf.hasOwnProperty(key) && (key.startsWith("Curr") || (key.startsWith("Num")))) { //only use keys starting with "Curr" and "Num", because all other keys are not relevant for formatting
	                        const langIso = languageMapping.nameToIso[lang] ;
	                        if (!self.config[langIso]) {
	                            self.config[langIso] = {}; //the first time we come here, "self.config.de-DE" or self.config.en-US" will not exist
	                        }
	                        self.config[languageMapping.nameToIso[lang]] [key] = formatConf[key];
	                        //_logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, ". FormatService::readConfiguration callback(" + langIso + ") - " + formatConf + ": " + JSON.stringify(self.config));
	                    }
	                }
	            }

	            for (const lang in languageMapping.nameToIso) { //GERMAN, ENGLISH
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. FormatService::readConfiguration for(${lang})`);
	                if (languageMapping.nameToIso.hasOwnProperty(lang)) {
	                    configPromises.push(_configService.getConfiguration(`Activex\\GraphicalService\\PCHtmlGen\\${lang}`, null).then(confCallback.bind(null, lang)));
	                }
	            }

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< FormatService::readConfiguration()");
	            return ext.Promises.Promise.all(configPromises);
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseService#onServicesReady}.
	         *
	         * Stores references to the LocalizeSerivce and the ConfigService.
	         * As soon as these services are ready, it stores the configuration,
	         * which is retrived from the LocalizeService, see {@link Wincor.UI.Service.LocalizeService#getLanguageMapping}.
	         *
	         * @returns {Promise}
	         * @eventhandler native
	         * @lifecycle service
	         */
	        onServicesReady() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> FormatService::onServicesReady()");
	            _localizeService = this.serviceProvider.LocalizeService;
	            _configService = this.serviceProvider.ConfigService;
	            const servicesReady = [_localizeService.whenReady, _configService.whenReady]; //LocalizeService must be ready, because we need the mapping. ConfigService is needed when we call readConfiguration

	            return ext.Promises.Promise.all(servicesReady).then(() => {
	                return this.readConfiguration(_localizeService.getLanguageMapping()).then(result => {
	                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `* FormatService:  ${JSON.stringify(this.config)}, result: ${JSON.stringify(result)}`);
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< FormatService::onServicesReady");
	                    return super.onServicesReady();
	                });
	            });
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ FormatServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$9 = getServiceClass$c({
	    jQuery: jQuery$2,
	    ext: ext$2,
	    LogProvider,
	    PTService
	});

	const ServiceInterface$9 = {
	    FormatProxy: {
	        service: "../service/wn.UI.Service.FormatService.js",
	        interface: {
	            format: {
	                type: "function",
	                callbackArgumentIndex: 2,
	            },
	            bankingContext: {
	                type: "object",
	            },
	        },
	    },
	};

	var FormatService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$9,
		ServiceClass: ServiceClass$9
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany
	 
	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.
	 
	 

	$MOD$ wn.UI.Service.JournalService.js 4.3.1-210203-21-1b8704b6-1a04bc7d
	 */

	/**
	 * @module
	 */
	const getServiceClass$d = ({ Wincor, jQuery, LogProvider, PTService }) => {
	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;

	    return class JournalService extends PTService {
	        /**
	         * "JournalService" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "JournalService";

	        /**
	         * Stores the configuration for the JournalService, currently only the journalOffset number, which depends on the current instance.
	         * @type {object}
	         * @example
	         * "config": {"journalOffset": 0}
	         */
	        config = {};

	        /**
	         * Message number defines.
	         * These defines are currently used by the ProFlex4 UI product. There is an offset of 50 to other UI instances, in which 20 messages of 4 UI instances are reserved.
	         * The offsets are added automatically regarding the appropriate instance.
	         * ```
	         * GUIAPP (520000-520019)
	         * GUIDM  (520050-520069)
	         * GUISOP (520100-520119)
	         * GUIxx  (520150-520169)
	         * ```
	         * For project specific journal messages please use 520000 with an offset of 30-49
	         * @enum {number}
	         */
	        MSG_NUMBERS = {
	            MSG_VIEW_DISPLAY: 520000,
	            MSG_AJAX_REQUEST: 520001,
	            MSG_BROWSER_VERSION: 520002,
	            MSG_VIEW_ACTIVATED: 520003,
	            MSG_VIEW_INTERACTION: 520010,
	            MSG_VIEW_RESULT: 520011
	        };

	        /**
	         * See {@link Wincor.UI.Service.PTService#constructor}.
	         *
	         * Initializes the config object, and the JournalService-specific FRM_RESOLVE_REQUEST parameters, so that the CCJournal module is used.
	         *
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);

	            /**
	             * The offset for the journal numbers, depending on the instance.
	             * @example {{GUIAPP: 0, GUIDM: 50, GUISOP: 100}}
	             * @type {{GUIAPP: number, GUIDM: number, GUISOP: number}}
	             */
	            this.journalOffsets = {
	                GUIAPP: 0,
	                GUIDM: 50,
	                GUISOP: 100
	            };

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> JournalService::JournalService");

	            this.FRM_RESOLVE_REQUEST.service = this.NAME;
	            this.FRM_RESOLVE_REQUEST.FWName = "CCJournal";

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< JournalService::JournalService");
	        }
	        
	        /**
	         * Called automatically as soon as there is an answer to an asynchronous ProTopas request. See {@link Wincor.UI.Service.BaseService#translateResponse}.
	         *
	         * For every request it returns only the return code as number.
	         *
	         * @param {object} message    Response object, see {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * @returns {Number}          The ProTopas return code of the request, typically 0 in case of success.
	         */
	        translateResponse(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> JournalService::translateResponse('${JSON.stringify(message)}')`);
	            let ret;
	            if (message.FWFuncID === 1) {
	                //CCJOURNAL_FW_FUNC_WRITE_MSG_BY_NUMBER
	                ret = message.RC;
	            } else if (message.FWFuncID === 9) {
	                //CCJOURNAL_FW_FUNC_WRITE_MSG_BY_NUMBER_WITH_ARGS
	                ret = message.RC;
	            } else {
	                _logger.error("Wincor.UI.Service.JournalService(onResponse): unknown function");
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< JournalService::translateResponse returns ${ret}`);
	            return ret;
	        }

	        /**
	         * Write a journal entry.
	         * @param {number} messageID number, ID of journal message
	         * @param {function} callback reference to a function receiving the return code as a parameter
	         * @param {*=} [arguments] optional arguments for journal message
	         * @example
	         * // use of CCJOURNAL_FW_FUNC_WRITE_MSG_BY_NUMBER method of CCJournal framework
	         * // uses ProFlex4/Op registry config:
	         * //   [HKEY_LOCAL_MACHINE\SOFTWARE\Wincor Nixdorf\ProTopas\CurrentVersion\JOURNAL\TOPMSG]
	         * //     "MSG1001"="=====================================================================================#NL#"
	         * // output in *.jrn file:
	         * //   =====================================================================================
	         * write(1001);
	         * @example
	         * // use of CCJOURNAL_FW_FUNC_WRITE_MSG_BY_NUMBER_WITH_ARGS method of CCJournal framework
	         * // uses ProFlex4/Op registry config:
	         * //   [HKEY_LOCAL_MACHINE\SOFTWARE\Wincor Nixdorf\ProTopas\CurrentVersion\JOURNAL\TOPMSG]
	         * //     "MSG1015"=" @005   @001 <Application> Application state is: #1# (#2#)  #3# #NL#"
	         * // output in *.jrn file:
	         * //    13:45:12   1015 <Application> Application state is: 111 (222)  333
	         * write(1015, null, 111, 222, "333");
	         */
	        write(messageID, callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> JournalService::write(messageID:${messageID}+offset(${this.config.journalOffset}), ...)`);

	            if (messageID) {
	                messageID += this.config.journalOffset;
	                // check for optional params
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. arguments.length: ${arguments.length}`);
	                if (arguments.length < 3) {
	                    this.FRM_RESOLVE_REQUEST.FWFuncID = 1; // CCJOURNAL_FW_FUNC_WRITE_MSG_BY_NUMBER
	                    this.FRM_RESOLVE_REQUEST.param1 = messageID;
	                    this.FRM_RESOLVE_REQUEST.meta1 = ["LONG", 0];
	                    this.FRM_RESOLVE_REQUEST.param2 = "";
	                    this.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	                    this.FRM_RESOLVE_REQUEST.param3 = "";
	                    this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	                    this.FRM_RESOLVE_REQUEST.paramUL = 0;

	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	                    this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	                } else {
	                    // put all additional params in one string, separator '\0', terminator '\00'
	                    let strMessage = "";
	                    for (let i = 2; i < arguments.length; i++) {
	                        strMessage += arguments[i];
	                        strMessage += String.fromCharCode(0);
	                    }
	                    let sMessageLen = strMessage.length * 2; // sizeof(WCHAR) = 2!
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. message strings length: ${sMessageLen}`);
	                    strMessage += String.fromCharCode(0);

	                    // this doesn't works ... TrcWritef() cut at first \u0000
	                    // output >>>. message strings: '111<<<
	                    //_logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, ". message strings: '" + strMessage + "'.");
	                    // put the string in an object and the stringify() does the job!
	                    // output example >>>. {"message strings":"111\u0000222\u0000333\u0000\u0000"}.<<<
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. ${JSON.stringify({ "message strings": strMessage })}.`);

	                    //send it
	                    this.FRM_RESOLVE_REQUEST.FWFuncID = 9; // CCJOURNAL_FW_FUNC_WRITE_MSG_BY_NUMBER_WITH_ARGS
	                    this.FRM_RESOLVE_REQUEST.param1 = messageID;
	                    this.FRM_RESOLVE_REQUEST.meta1 = ["LONG", 0];
	                    this.FRM_RESOLVE_REQUEST.param2 = sMessageLen;
	                    this.FRM_RESOLVE_REQUEST.meta2 = ["SHORT", 0];
	                    this.FRM_RESOLVE_REQUEST.param3 = strMessage;
	                    this.FRM_RESOLVE_REQUEST.meta3 = ["WCHAR", -1];
	                    this.FRM_RESOLVE_REQUEST.paramUL = 1;

	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	                    this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	                }
	            } else {
	                // if user wants callback ...
	                if (callback) {
	                    // emulate CCJournalFW return code for this case!
	                    callback(1); // CCJOURNAL_FW_ERROR
	                }
	            }

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< JournalService::write");
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseService#onServicesReady}.
	         *
	         * Reads the configuration from the registry section "\\Services\\JournalService".
	         * Registers to various service events (see {@link Wincor.UI.Service.ViewService#SERVICE_EVENTS} to be able to write journal message at the appropriate time.
	         *
	         * @async
	         * @lifecycle service
	         */
	        async onServicesReady() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> JournalService::onServicesReady()");

	            const configService = Wincor.UI.Service.Provider.ConfigService;
	            const instanceName = configService.configuration.instanceName;
	            let config = await configService.getConfiguration(instanceName + "\\Services\\JournalService", null);
	            _logger.LOG_DATA && _logger.log(_logger.LOG_DATA, `* JournalService::configCallback(${JSON.stringify(config)})`);

	            this.config.journalOffset = this.journalOffsets[instanceName];
	            this.config = jQuery.extend(true, this.config, config); //...and extend our config with missing default config parameters

	            _logger.LOG_DATA && _logger.log(_logger.LOG_DATA, `* JournalService::configCallback, config=${JSON.stringify(this.config)}`);

	            const viewService = this.serviceProvider.ViewService;

	            //persistantly register on NAVIGATE_SPA to write logs
	            viewService.registerForServiceEvent(
	                viewService.SERVICE_EVENTS.NAVIGATE_SPA,
	                data => {
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* JournalService::callback(), SPA data=${JSON.stringify(data)}`);
	                    let journalData = jQuery.extend(true, { viewId: viewService.viewContext.viewID }, data);
	                    this.write(this.MSG_NUMBERS.MSG_VIEW_DISPLAY, null, JSON.stringify(journalData), journalData.viewId, journalData.viewKey);
	                },
	                true
	            );

	            //persistantly register on VIEW_ACTIVATED to write logs (here customers can refer to UI properties within the journal messages)
	            viewService.registerForServiceEvent(
	                viewService.SERVICE_EVENTS.VIEW_ACTIVATED,
	                () => {
	                    // welcome fragment activates without viewkey
	                    if (viewService.viewContext.viewKey) {
	                        let journalData = {
	                            viewId: viewService.viewContext.viewID,
	                            viewKey: viewService.viewContext.viewKey,
	                            url: viewService.viewContext.viewURL
	                        };
	                        this.write(this.MSG_NUMBERS.MSG_VIEW_ACTIVATED, null, JSON.stringify(journalData), journalData.viewId, journalData.viewKey);
	                    }
	                },
	                true
	            );

	            //persistently register on VIEW_CLOSING to write logs
	            viewService.registerForServiceEvent(
	                viewService.SERVICE_EVENTS.VIEW_CLOSING,
	                d => {
	                    let privateInput = viewService.viewContext.viewConfig.privateInput;
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* JournalService::callback(), SPA data=${JSON.stringify(d)}`);
	                    let data = Object.assign({}, d);
	                    if (privateInput) {
	                        data.resultDetail = "*";
	                    }
	                    this.write(this.MSG_NUMBERS.MSG_VIEW_RESULT, null, JSON.stringify(data), data.viewId, data.viewKey, data.resultCode, data.resultDetail);
	                },
	                true
	            );

	            //register for the first(!) VIEW_ACTIVATED (i.e. DISPOSAL_TRIGGER_ONETIME) just to register for the ajaxComplete event.
	            //We can not directly register ajaxComplete here in onServicesReady, because that is too early and will not work, most likely because
	            //jQuery is not a member of the contentDocoument at that point in time, because contentDocument is not yet loaded.
	            let regId = viewService.registerForServiceEvent(
	                viewService.SERVICE_EVENTS.VIEW_ACTIVATED,
	                data => {
	                    let activeFrameName = window.localStorage.getItem("activeFrameName");
	                    if (activeFrameName) {
	                        let iframeDocument = document.getElementById(activeFrameName).contentDocument;
	                        let iframeWindow = document.getElementById(activeFrameName).contentWindow;
	                        _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* JournalService::callback2(), activeFrameName=${activeFrameName}, SPA data=${JSON.stringify(data)}`);
	                        // Note:
	                        // The content window's jQuery object is not the same as the required one, the required belongs to the services document whereas the
	                        // second one belongs to the window of the content frame and there we want to get informed on AJAX completions.
	                        if (typeof iframeWindow.jQuery === "function") {
	                            try {
	                                iframeWindow.jQuery(iframeDocument).ajaxComplete((event, jqXHR, ajaxOptions) => {
	                                    let journalMessage = {
	                                        url: ajaxOptions.url,
	                                        statusText: jqXHR.statusText
	                                    };
	                                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* JournalService::onAjaxComplete() ${JSON.stringify(journalMessage)}`);

	                                    this.write(this.MSG_NUMBERS.MSG_AJAX_REQUEST, null, JSON.stringify(journalMessage), viewService.viewContext.viewID, viewService.viewContext.viewKey);
	                                });
	                                viewService.deregisterFromServiceEvent(regId);
	                            } catch (e) {
	                                this.logger.log(this.logger.LOG_SRVC_DATA, `* JournalService::onAjaxComplete couldn't register ${e.message}`);
	                            }
	                        }
	                    }
	                },
	                true
	            ); // register persistent, deregister manually

	            await super.onServicesReady();

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< JournalService::onServicesReady");
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ JournalServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$a = getServiceClass$d({
	    Wincor: Wincor$2,
	    jQuery: jQuery$2,
	    LogProvider,
	    PTService
	});

	const ServiceInterface$a = {
	    JournalProxy: {
	        service: "../service/wn.UI.Service.JournalService.js",
	        interface: {
	            MSG_NUMBERS: {
	                type: "object",
	                keys: [
	                    "MSG_AJAX_REQUEST",
	                    "MSG_VIEW_DISPLAY",
	                    "MSG_VIEW_INTERACTION",
	                    "MSG_VIEW_RESULT",
	                    "MSG_BROWSER_VERSION",
	                ],
	                writable: false,
	            },
	            write: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	        },
	    },
	};

	var JournalService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$a,
		ServiceClass: ServiceClass$a
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.



	$MOD$ wn.UI.Service.LocalizeService.js 4.3.1-210203-21-1b8704b6-1a04bc7d
	 */

	/**
	 * @module
	 */
	const getServiceClass$e = ({ Wincor, ext, LogProvider, PTService }) => {

	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;

	    const META_UTF8 = "PARLIST_UTF8";
	    const META_ANSI = "PARLIST_ANSI";
	    const META_CHAR_ANSI = "CHAR_ANSI";
	    const BUFFER_LEN_UTF8 = 16000;
	    const BUFFER_LEN_ANSI = 4000;
	    const MAX_LEN_REQUESTED_KEYS = 262144; // 256KB
	    const MAX_COUNT_REQUESTED_KEYS = 2048;
	    
	    
	    return class LocalizeService extends PTService {

	        /**
	         * The logical name of this service as used in the {@link Wincor.UI.Service.Provider}.
	         * @default LocalizeService
	         * @const
	         * @type {string}
	         */
	        NAME = "LocalizeService";

	        /**
	         * Structure containing the registered translation keys
	         * @class
	         */
	        TranslateRegistration = function() {
	            /**
	             * The registered translation keys.
	             * @type {Array<string>}
	             */
	            this.keys = [];         //the registered translationKeys

	            /**
	             * A callback function which is called when a LANGUAGE_CHANGED event is triggered, see {@link Wincor.UI.Service.LocalizeService#SERVICE_EVENTS}.
	             * @type {function}
	             */
	            this.callback = null;   //this callback is called when the languageChanged event is triggered

	            /**
	             * Ordinary texts should be auto updated (true) on LANGUAGE_CHANGED
	             * events triggered by the business logic, see {@link Wincor.UI.Service.LocalizeService#SERVICE_EVENTS}.
	             * @type {boolean}
	             */
	            this.autoUpdate = true; // ordinary texts should be auto updated on LanguageChanged events from BL
	        };

	        /**
	         * Array containing elements of {@link Wincor.UI.Service.LocalizeService#TranslateRegistration}.
	         * @type {Array}
	         */
	        translationArray = []; // [TranslateRegistration1, TranslateRegistration2, ... ]

	        /**
	         * The service events for the LocalizeService
	         * @enum {string}
	         */
	        SERVICE_EVENTS = {
	            /**
	             * Fired when the language has been changed.
	             * @event  Wincor.UI.Service.LocalizeService#SERVICE_EVENTS:LANGUAGE_CHANGED
	             * @eventtype service
	             */
	            LANGUAGE_CHANGED: "LANGUAGE_CHANGED"
	        };

	        /**
	         * The current presented ISO language.
	         * @default en-US
	         * @type {string}
	         */
	        currentLanguage = "";

	        /**
	         * The language map.
	         * @example
	         * this.languages = {
	         *    isoToName: {},
	         *    nameToIso: {}
	         * };
	         * @type {*}
	         */
	        languages = {};

	        /**
	         * Initializes the member of this class.
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.PTService#constructor}.
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> LocalizeService::LocalizeService");
	            this.FRM_RESOLVE_REQUEST.service = this.NAME;
	            this.currentLanguage = "en-US"; // will become the ISO code
	            this.languages = {
	                isoToName: {},
	                nameToIso: {},
	                defaultLanguage: "" // will become the ISO code
	            };
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeService::LocalizeService");
	        }
	        
	        /**
	         * Called automatically as soon as there is an answer to an asynchronous ProTopas request. See {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * The response will be translated to the result expected by the requester.
	         *
	         * @param {object} message    Response object, see {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * @returns {*}               Depends on function
	         */
	        translateResponse(message) {
	            let ret;
	            try {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> LocalizeService::translateResponse('${JSON.stringify(message)}')`);

	                if (message.methodName === this.METHOD_FRM_RESOLVE) {
	                    if (message.FWName === "CCDialog" && message.FWFuncID === 550 && message.RC === 0) { //getText
	                        /*
	                        message.param1 has the keys,   i.e. [key1,   key2, ...]
	                        message.param2 has the values, i.e. [value1, value2, ...]
	                        message.param3 has the RCs, i.e. [RC1, RC2, ...]

	                        getKeysResponse will be an object:
	                        getKeysResponse[key1] = value1
	                        getKeysResponse[key2] = value2
	                        ...
	                        */
	                        let response = {}, key;
	                        for (let i in message.param1) {
	                            if (message.param1.hasOwnProperty(i)) {
	                                key = message.param1[i].toString();
	                                response[key] = null;
	                                //check if RC == OK then put value in map
	                                if (message.param3[i].toString() === "0") {
	                                    response[key] = message.param2[i];
	                                }
	                            }
	                        }
	                        ret = response;
	                    } else if (message.FWName === "CCDialog" && message.FWFuncID === 6 && message.RC === 0) { //setLanguage
	                        ret = message.RC;
	                    } else {
	                        _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. LocalizeService::onResponse message from '${message.FWName}' with FWFuncID '${message.FWFuncID}' and RC = '${message.RC}' will not be evaluated.`);
	                    }
	                }
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< LocalizeService::onResponse returns: ${JSON.stringify(ret)}`);
	            } catch (e) {
	                // Provider writes error-log
	                Wincor.UI.Service.Provider.propagateError(this.NAME, this.ERROR_TYPE.RESPONSE, e);
	            }
	            return ret;
	        }

	        /**
	         * This delegate is called when the language has been changed.
	         * The information will be received from the GatewayService.
	         * @param {string} languageHex
	         */
	        onLanguageChanged(languageHex) {
	            //toUpperCase, because the event of CCDialog will send the language exactly as it retrieved it in it's setting functionality
	            //This means, if someone calls BAS_SET_LANGUAGE("gerMan"), this will be routed (unchanged) to CCDialog, which will trigger the event with also with an unchanged 'gerMan'
	            const langName = Wincor.ConvHexToStr(languageHex).toUpperCase();
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> LocalizeService::onLanguageChanged(${langName})`);

	            let newLanguage = this.languages.nameToIso[langName];

	            if (newLanguage) {
	                this.currentLanguage = newLanguage;
	                _logger.LOG_DATA && _logger.log(_logger.LOG_DATA, `* LocalizeService::onLanguageChanged, mapped: ${this.currentLanguage}`);
	                // The updateTexts() call maybe unwanted, which is possible by configuring at a certain viewkey with {..., "config": {"autoUpdateOnLanguageChange": "false"}, ...}
	                // E.g. 'TransactionEnd' -> "Thank you and have a nice day." is not desired that the currently shown text changes back to the default language when its e.g. currently
	                // displayed in chinese while the view is presented.
	                // Usually the OP does switch to the default language at this point of end of transaction.
	                let config = this.serviceProvider.ViewService.viewContext.viewConfig.config;
	                if(!config || config.autoUpdateOnLanguageChange === void 0 || this.convertToBoolean(config.autoUpdateOnLanguageChange)) {
	                    this.updateTexts().then(() => {
	                        this.fireServiceEvent(this.SERVICE_EVENTS.LANGUAGE_CHANGED, this.currentLanguage);
	                    });
	                } else {
	                    this.fireServiceEvent(this.SERVICE_EVENTS.LANGUAGE_CHANGED, this.currentLanguage);
	                }
	            } else {
	                _logger.error(`LocalizeService::onLanguageChanged, Unknown language '${newLanguage}' received. SERVICE_EVENTS.LANGUAGE_CHANGED is not broadcasted, texts will not be updated.`);
	            }

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeService::onLanguageChanged");
	        }

	        /**
	         * Updates the text keys currently stored in the translation map.
	         * Gets resolved when the text callbacks have been called with the updated texts
	         * @async
	         */
	        async updateTexts() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> LocalizeService::updateTexts()");
	            const itemPromises = [];
	            // Install a ready callback all elements with -autoUpdate=true.
	            // We do this in order to signal readiness when really all texts have been updated, so that the caller can fire LANGUAGE_CHANGED
	            // event which is way too early otherwise.
	            for(let i = this.translationArray.length - 1; i >= 0; i--) {
	                let trans = this.translationArray[i];
	                if(trans.autoUpdate) {
	                    itemPromises.push(ext.Promises.promise(resolve => {
	                        const org = trans.callback;
	                        trans.callback = value => {
	                            org(value);
	                            trans.callback = org;
	                            resolve();
	                        };
	                    }));
	                }
	            }
	            for(let i = this.translationArray.length - 1; i >= 0; i--) {
	                let trans = this.translationArray[i];
	                if(trans.autoUpdate) {
	                    //do not call getText, because this is not a 'new' request from the outside where we would
	                    //have to add sth. to the translationArray -- instead it's just an update!
	                    this.sendProtopasTranslateMessage(trans.keys, trans.callback);
	                }
	            }
	            await ext.Promises.Promise.all(itemPromises);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeService::updateTexts()");
	        }

	        /**
	         * Get the values of the requested translation keys stored in the registry.
	         * @param {Array<String> | String} keys the text key(s)
	         * @param {function=} callback Callback(result)
	         * @param {boolean=} [autoUpdate=true] autoUpdate default is true, for texts that should not be updated automatically on languageChanged events, set this parameter to false
	         * @param {function=} [disposeFn=null] disposeFn dispose function to be called when {@link Wincor.UI.Service.LocalizeService#cleanTranslationTexts} is invoked with an false argument
	         */
	        getText(keys, callback, autoUpdate = true, disposeFn = null) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> LocalizeService::getText(${keys})`);
	            //BEGIN: check input parameters
	            keys = Array.isArray(keys) ? keys : [keys];
	            let uniqueKeys = [];
	            let errorMessage;
	            const len = keys.length;
	            let overallLen = 0;
	            for(let i = 0; i < len; ++i) { // must use forward loop, because of order of the keys (e.g. ProFlex4Op)
	                let key = keys[i];
	                if(key !== void 0 && key !== null) { //do NOT use '!keys[i]' because empty string is okay, 0 is okay
	                    if(!uniqueKeys.includes(key)) {
	                        uniqueKeys.push(key);
	                        overallLen += key.length;
	                    } else {
	                        _logger.error(`Warning: LocalizeService::getText() double key detected: ${key}`);
	                    }
	                } else {
	                    errorMessage = "LocalizeService::getText() keys contains null or undefined.";
	                    break;
	                }
	            }
	            // check for potential argument error
	            if(overallLen > MAX_LEN_REQUESTED_KEYS || uniqueKeys.length > MAX_COUNT_REQUESTED_KEYS) {
	                errorMessage = `LocalizeService::getText() too many or too long text keys argument requested. Please check your keys array argument. Number of keys requested: ${uniqueKeys.length}, string len: ${overallLen}`;
	            }
	    
	            keys = uniqueKeys;

	            if(errorMessage) {
	                _logger.error(errorMessage);
	                callback && callback({}); //call callback with empty object
	                Wincor.UI.Service.Provider.propagateError("LocalizeService::getText", this.ERROR_TYPE.REQUEST);
	                return;
	            }
	            //END: check input parameters

	            //build a new TranslateRegistration object and add it to our Array

	            let transReg = new this.TranslateRegistration();
	            if(disposeFn) {
	                transReg.disposeFn = disposeFn;
	            }
	            transReg.keys = keys;
	            transReg.callback = callback;
	            transReg.autoUpdate = autoUpdate;

	            this.translationArray.push(transReg);

	            //now do the ProTopas stuff
	            this.sendProtopasTranslateMessage(keys, callback);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeService::getText");
	        }

	        /**
	         * Send the requested translation keys to the PTService and get the translations back.
	         * @param {Array<string>} keyArray
	         * @param {function} callback Callback(result)
	         */
	        sendProtopasTranslateMessage(keyArray, callback) {
	            this.FRM_RESOLVE_REQUEST.FWName = "CCDialog";
	            this.FRM_RESOLVE_REQUEST.FWFuncID = 550;
	            this.FRM_RESOLVE_REQUEST.param1 = keyArray;
	            this.FRM_RESOLVE_REQUEST.meta1 = [META_ANSI, -1];
	            this.FRM_RESOLVE_REQUEST.param2 = [];
	            this.FRM_RESOLVE_REQUEST.meta2 = [META_UTF8, BUFFER_LEN_UTF8];
	            this.FRM_RESOLVE_REQUEST.param3 = [];
	            this.FRM_RESOLVE_REQUEST.meta3 = [META_ANSI, BUFFER_LEN_ANSI];
	            this.FRM_RESOLVE_REQUEST.ViewKey = this.serviceProvider.ViewService.viewContext.viewKey;

	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);
	        }

	        /**
	         * Get the currently set ISO language from the business logic
	         * @param callback Callback(result)
	         */
	        getLanguage(callback) {

	            function getLangCallback(response) {
	                _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `* LocalizeService::getLanguage::getLangCallback(${response["VAR_LANGUAGE_S"]})`);
	                const iso = this.languages.nameToIso[response["VAR_LANGUAGE_S"].toUpperCase()];
	                _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `* LocalizeService::getLanguage::getLangCallback, mapped to ${iso}`);
	                callback(iso);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> LocalizeService::getLanguage()");
	            this.serviceProvider.DataService.getValues(["VAR_LANGUAGE_S"], getLangCallback.bind(this), null);

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeService::getLanguage");
	        }

	        /**
	         * Set the language.
	         * @param {string} lang Language in ISO compatible "xx-YY" notation
	         * @param callback Callback(result), which tells that setting the language was executed in the business logic. It does not mean, that the language was really changed.
	         */
	        setLanguage(lang, callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> LocalizeService::setLanguage(${lang})`);
	            // TODO in a future major version of UI we don't need the lang name anymore, because TAFW processes ISO codes directly,
	            // but due to backward compatibility we have to set the lang name for the time being.
	            const langName = this.languages.isoToName[lang];
	            _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* LocalizeService::setLanguage, mapped: " + langName);
	            if (!langName) {
	                _logger.error(`LocalizeService::setLanguage called with unknown language '${lang}'`);
	                return;
	            }
	            const dataService = this.serviceProvider.DataService;
	            const key = "PROP_LANGUAGE_SET_MANUALLY";
	            dataService.setValues(key, "0") // set the property to 0 first, then call the BAS lang change, afterwards set property to 1 again.
	                .then(() => {
	                    this.FRM_RESOLVE_REQUEST.FWName = "CCTransactionFW";
	                    this.FRM_RESOLVE_REQUEST.FWFuncID = 8; //PROCESS_STEP
	                    this.FRM_RESOLVE_REQUEST.param1 = " ".repeat(32); //32 spaces due to some old downward-compatibility issues with CCScriptFW
	                    this.FRM_RESOLVE_REQUEST.meta1 = [META_CHAR_ANSI, -1];
	                    this.FRM_RESOLVE_REQUEST.param2 = "BAS_CHANGE_LANGUAGE";
	                    this.FRM_RESOLVE_REQUEST.meta2 = [META_CHAR_ANSI, -1];
	                    this.FRM_RESOLVE_REQUEST.param3 = langName;
	                    this.FRM_RESOLVE_REQUEST.meta3 = [META_CHAR_ANSI, -1];
	                    this.FrmResolve(this.FRM_RESOLVE_REQUEST, rc => {
	                        dataService.setValues(key, "1").then(() => {
	                            callback(rc);
	                            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeService::setLanguage");
	                        });
	                    });
	                });
	        }

	        /**
	         * Returns all installed languages as an array of ISO Codes
	         * @returns {Array<string>} an Array of ISO codes, e.g. [en-US, de-DE]
	         */
	        getInstalledLanguages() {
	            return Object.keys(this.languages.isoToName);
	        }

	        /**
	         * INTERNAL USE ONLY! Only used by FormatService, can be dropped at any time!
	         * @returns {Object}
	         */
	        getLanguageMapping() {
	            return this.languages;
	        }
	    
	        /**
	         * Clear values for all requested translation keys contained by the translationArray.
	         * @param {boolean=} [cleanAll=true] cleanAll true, all registrations will be cleaned, false means only registrations which contains a dispose function will be cleaned
	         */
	        cleanTranslationTexts(cleanAll = true) {
	            for(let i = this.translationArray.length - 1; i >= 0; i--) {
	                let reg = this.translationArray[i];
	                if(cleanAll || reg.disposeFn) {
	                    reg.keys = null;
	                    reg.callback = null;
	                    if(reg.disposeFn) {
	                        reg.disposeFn();
	                        reg.disposeFn = null;
	                    }
	                    this.translationArray.splice(i, 1);
	                }
	            }
	            if(cleanAll) {
	                this.translationArray.length = 0;
	            }
	        }
	    
	        /**
	         * Registers for a language change event from the business logic and reads the language specific parameters from the configuration of
	         * <i>Transaction\GENERAL\Language_Map"</i>.
	         * @returns {Promise}
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.BaseService#onServicesReady}
	         */
	        onServicesReady() {
	            return ext.Promises.promise(async resolve => {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> LocalizeService::onServicesReady()");

	                //register for the LanguageChanged event
	                function registerCallback(message) {
	                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* LocalizeService::onServicesReady::registerCallback(): RC: ${message.RC}`);
	                }

	                this.serviceProvider.EventService.registerForEvent(1, 'CCDialog', this.onLanguageChanged.bind(this), registerCallback.bind(this), "HEX", true);
	                this.serviceProvider.ViewService.registerForServiceEvent(this.serviceProvider.ViewService.SERVICE_EVENTS.VIEW_CLOSING, this.cleanTranslationTexts.bind(this), true);
	                this.serviceProvider.ViewService.registerForServiceEvent(this.serviceProvider.ViewService.SERVICE_EVENTS.SHUTDOWN, this.cleanTranslationTexts.bind(this), true);

	                //Get all currently installed languages and build a ISOCode- to LanguageName-Mapping
	                //Our interface will only work with ISO-Code, but the Step BAS_CHANGE_LANGUAGE and the CCDialog-Event only know 'names' like German or English.
	                //The properties CCTAFW_PROP_INSTALLED_LANGUAGES (Iso Codes) and CCTAFW_PROP_INSTALLED_LANGUAGES_NAMES (names) will not work to retrieve the installed
	                //languages, because at this point in time (onServicesReady) the TransactionFW has not yet initialized its properties, so we have to scan the registry
	    
	                function convertRegistryMappingToInternalMapping(registryMapping) {
	                    let internalMapping = {nameToIso: {}, isoToName: {}};

	                    try {
	                        let installedISOs = 0;
	                        for (let langName in registryMapping) {
	                            if (registryMapping.hasOwnProperty(langName)) {
	                                if (langName === "InstalledLanguages") {
	                                    installedISOs = registryMapping[langName].split(";").length; //TODO determine the count of configured ISOs and compared with the count of languages afterwards. This should match!
	                                } else {
	                                    langName = langName.toUpperCase();
	                                    let isoCode = registryMapping[langName].split(";")[1];
	                                    internalMapping.nameToIso[langName] = isoCode; //e.g. "GERMAN" = "de-DE"
	                                    internalMapping.isoToName[isoCode] = langName;
	                                }
	                            }
	                        }
	                    } catch (e) {
	                        internalMapping = null;
	                        _logger.error(e);
	                    }
	                    return internalMapping;
	                }

	                try {
	                    //langConf={
	                    //    "InstalledLanguages":"de-DE;en-US",
	                    //    "GERMAN":"01;de-DE",
	                    //    "ENGLISH":"06;en-US"
	                    //}
	                    let langConf = await Wincor.UI.Service.Provider.ConfigService.getConfiguration("Transaction\\GENERAL\\Language_Map", null);
	                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* LocalizeService::onServicesReady, langConf=${JSON.stringify(langConf)}`);
	                    this.languages = convertRegistryMappingToInternalMapping(langConf);
	                    let defaultLangConf = await Wincor.UI.Service.Provider.ConfigService.getConfiguration("Activex\\GraphicalService\\PCView", null);
	                    //if there is no 'DefaultLanguage' entry (or e.g. Tooling will not send anything), we will get an empty object {}
	                    let defLang = defaultLangConf.DefaultLanguage ? defaultLangConf.DefaultLanguage : this.languages.isoToName[this.getInstalledLanguages()[0]]; // e.g. 'ENGLISH'
	                    this.languages.defaultLanguage = this.languages.nameToIso[defLang.toUpperCase()];
	                } catch(e) {
	                    this.languages = {};
	                }
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* LocalizeService::onServicesReady languages: ${JSON.stringify(this.languages)}`);

	                this.getLanguage(language => {
	                    this.currentLanguage = language;
	                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* LocalizeService::onServicesReady getLanguageCallback: ${language}`);
	                    super.onServicesReady().then(resolve);
	                });
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeService::onServicesReady");
	            });
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ LocalizeServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$b = getServiceClass$e({
	    Wincor: Wincor$2,
	    ext: ext$2,
	    LogProvider,
	    PTService
	});

	const ServiceInterface$b = {
	    LocalizeProxy: {
	        service: "../service/wn.UI.Service.LocalizeService.js",
	        interface: {
	            SERVICE_EVENTS: {
	                type: "object",
	                keys: ["LANGUAGE_CHANGED"],
	                writable: false,
	            },
	            currentLanguage: {
	                type: "string",
	                writable: false,
	            },
	            getText: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            setLanguage: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            updateTexts: {
	                type: "function",
	            },
	            getInstalledLanguages: {
	                type: "function",
	            },
	            getLanguageMapping: {
	                type: "function",
	            },
	            cleanTranslationTexts: {
	                type: "function",
	            },
	        },
	    },
	};

	var LocalizeService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$b,
		ServiceClass: ServiceClass$b
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.



	$MOD$ wn.UI.Service.ValidateService.js 4.3.1-210203-21-1b8704b6-1a04bc7d
	 */

	/**
	 * @module
	 */
	const getServiceClass$f = ({ Wincor, LogProvider, PTService }) => {

	    let _viewService;

	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;

	    return class ValidateService extends PTService {

	        /**
	         * "ValidateService" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "ValidateService";

	        /**
	         * See {@link Wincor.UI.Service.PTService#constructor}.
	         * Initialize some private members.
	         *
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ValidateService::ValidateService`);

	            this.FRM_RESOLVE_REQUEST.service = this.NAME;

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< ValidateService::ValidateService`);
	        }
	        
	        /**
	         * Checks if a given value is a number. Will returns true, if it is a number, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @return {Boolean}
	         */
	        isNumbers(value) {
	            //Problem: isNaN(5-2) = false
	            //var isNum = value !== "" && !isNaN(value);
	            let isNum = false;

	            try {
	                let array = value.split("");

	                if(value === "") {
	                    isNum = false;
	                }
	                else {
	                    // Start with the last value of the array
	                    for(let i = array.length - 1; i >= 0; i--) {
	                        if(!isNaN(array[i])) {
	                            isNum = true;
	                        }
	                        else {
	                            isNum = false;
	                            break;
	                        }
	                    }
	                }
	            } catch(e) {
	                //pass
	                _logger.error(`ValidateService(isNumbers): exception for value ${value} ${e}`);
	            }
	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService(isNumbers): ${isNum} for ${value}`);
	            return isNum;
	        }

	        /**
	         * Checks if a given value is a char sequence. Will return true, if it is a char sequence, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @return {Boolean}
	         */
	        isChars(value) {
	            const re = /[0-9]/;
	            const isChar = value !== "" && !re.test(value);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService(isChars): ${isChar} for ${value}`);
	            return isChar;
	        }

	        /**
	         * Checks if a given value is a mail address. Will return true, if it is a mail address, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @return {Boolean}
	         */
	        isEmail(value) {
	            // http://stackoverflow.com/questions/46155/validate-email-address-in-javascript
	            const re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
	            const isEMail = re.test(value);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService(isEmail): ${isEMail} for ${value}`);
	            return isEMail;
	        }

	        /**
	         * Checks if a given value has a valid date format. Will return true, if it has a valid date format, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {string} [pattern=""] - Valid date format e.g. yyyy/mm/dd Currently not used. Browser-known patterns only.
	         * @return {Boolean}
	         */
	        isDateFormat(value, pattern="") {     /*TODO: date pattern must be known, to check if a date is valid*/
	            const date = new Date(value);

	            const isDate = date.toString() !== "Invalid Date";

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService(isDateFormat): ${isDate} for ${value}`);
	            return isDate;
	        }

	        /**
	         * Checks if a given value is within a valid period. Will return true, if it is within the period, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {string} from - Earliest date
	         * @param {string} to - Latest date
	         * @param {string=} pattern - Valid date format e.g. yyyy/mm/dd
	         * @return {Boolean}
	         */
	        isDateInRange(value, from, to, pattern) {
	            let isDateInRange = false;

	            if(this.isDateFormat(value) && this.isDateFormat(from) && this.isDateFormat(to)) {
	                isDateInRange = (value !== "") && (value >= from) && (value <= to);
	            }

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService(isDateInRange): ${isDateInRange} for ${value}`);
	            return isDateInRange;
	        }

	        /**
	         * Checks if a given value is in range. Will return true, if it is in range, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {number} min - Minimum value
	         * @param {number} max - Maximum value
	         * @param {number=} stepLen - Value for modulo function e.g. '100' for full amounts, default = 1
	         * @return {Boolean}
	         */
	        isInRange(value, min, max, stepLen) {
	            if (stepLen === void 0) {
	                stepLen = 1;
	            }

	            let inRange = (value !== "") && (value >= min) && (value <= max) && ((value % stepLen) === 0);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService(isInRange): ${inRange} for ${value}`);
	            return inRange;
	        }

	        /**
	         * Checks if a given value is higher than the minimum. <BR>
	         * Will return true, if it is higher than or equal to the minimum, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {number} min - Minimum value
	         * @return {Boolean}
	         */
	        isMin(value, min) {
	            const resultMin = (value !== "") && (value >= min);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService(isMin): ${resultMin} for ${value}`);
	            return resultMin;
	        }

	        /**
	         * Checks if a given value is lower than the maximum. <BR>
	         * Will return true, if it is lower than or equal to the maximum, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {number} max - Maximum value
	         * @return {Boolean}
	         */
	        isMax(value, max) {
	            const resultMax = (value !== "") && (value <= max);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService(isMax): ${resultMax} for ${value}`);
	            return resultMax;
	        }

	        /**
	         * Checks if a given value is in step length. Will return true, if it is in step length, otherwise false.
	         * @param {string} value - Parameter to check
	         * @param {number} stepLen - Value for modulo function e.g. '100' for full amounts || '60' for number of minutes
	         * @return {Boolean}
	         */
	        isStepLen(value, stepLen) {
	            const stepLength = (value !== "") && (value % stepLen === 0);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService(isStepLen): ${stepLength} for ${value}`);
	            return stepLength;
	        }

	        /**
	         * Checks if the length of a given value is greater than or equal to a minimum length. <BR>
	         * Will return true, if it is greater than / equal to the minLen, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {number} [minLen=0] - minimum length
	         * @return {Boolean}
	         */
	        isWithinMinLength(value, minLen=0) {

	            if (value === void 0) {
	                _logger.error(`ValidateService::isWithinMinLength - value is undefined`);
	                return false;
	            }
	            if (value === null ) {
	                _logger.error(`ValidateService::isWithinMinLength - value is null`);
	                return false;
	            }

	            let isWithin = true;
	            if (minLen >= 0) {
	                isWithin = value.length >= minLen;
	            }
	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService::isWithinMinLength (input=${value}, minLen=${minLen}, isWithin=${isWithin})`);
	            return isWithin;
	        }

	        /**
	         * Checks if the length of a given value is smaller than or equal to a maximum length. <BR>
	         * Will return true, if it is smaller than / equal to the maxLen, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {number} [maxLen=Infinity] - maximum length
	         * @return {Boolean}
	         */
	        isWithinMaxLength(value, maxLen=Infinity) {

	            if (value === void 0 ) {
	                _logger.error(`ValidateService::isWithinMaxLength - value is undefined`);
	                return false;
	            }
	            if (value === null ) {
	                _logger.error(`ValidateService::isWithinMaxLength - value is null`);
	                return false;
	            }

	            let isWithin = true;
	            if (maxLen >= 0) {
	                isWithin = value.length <= maxLen;
	            }
	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL,`ValidateService::isWithinMaxLength (input=${value}, maxLen=${maxLen}, isWithin=${isWithin})`);
	            return isWithin;
	        }

	        /**
	         * Checks if the length of a given value is smaller than or equal to a maximum length <BR>
	         * and greater than / equal to a minimum length. <BR>
	         * Will return true, if it is smaller than / equal to the maxLen and greater than / equal to the minLen, <BR>
	         * otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {number} [minLen=0] - minimum length
	         * @param {number} [maxLen=Infinity] - maximum length
	         * @return {Boolean}
	         */
	        isWithinLength(value, minLen=0, maxLen=Infinity) {

	            if (value === void 0 ) {
	                _logger.error(`ValidateService::isWithinLength - value is undefined`);
	                return false;
	            }
	            if (value === null ) {
	                _logger.error(`ValidateService::isWithinLength - value is null`);
	                return false;
	            }

	            const isWithin = this.isWithinMinLength(value, minLen) && this.isWithinMaxLength(value, maxLen);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL,`ValidateService::isWithinLength (input=${value}, minLen=${minLen}, maxLen=${maxLen}, isWithin=${isWithin})`);
	            return isWithin;
	        }


	        /**
	         * Checks if a given value starts with a '0'. <BR>
	         * Will return false, if the first digit is '0' and it is not allowed to be '0', otherwise it will return true.
	         * @param {string} value - Parameter to be checked
	         * @param {Boolean} allowLeadingZero - Flag that determines whether a leading zero is allowed (true) or not (false)
	         * @return {Boolean}
	         */
	        checkLeadingZero(value, allowLeadingZero) {
	            let zeroCheck = true;

	            if ( ( allowLeadingZero === false ) && ( value.length >= 1 ) && ( value[0] === "0" )  ) {
	                zeroCheck = false;
	            }

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService::checkLeadingZero (input=${value}, allowLeadingZero=${allowLeadingZero}, zeroCheck=${zeroCheck})`);
	            return zeroCheck;
	        }

	        /**
	         * Checks whether the given value is in line with a regular expression.
	         * @param {string} value - Parameter to be checked
	         * @param {string} forbiddenPattern - reg. expression
	         * @return {Boolean}
	         */
	        matchesForbiddenPattern(value, forbiddenPattern) {
	            let isForbidden = false;

	            if (!(forbiddenPattern === "" || forbiddenPattern === undefined || forbiddenPattern === null)) {

	                // Examples:
	                // forbiddenPattern = "^\\s+$" --> will not accept string only consisting of blanks
	                // forbiddenPattern = "gr[" --> will throw exception

	                try {
	                    const pattern = new RegExp(forbiddenPattern);
	                    isForbidden = pattern.test(value);
	                    !_viewService.viewContext.viewConfig.privateInput &&
	                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService::matchesForbiddenPattern - after test() call: (input=${value}, forbiddenPattern=${forbiddenPattern}, isForbidden=${isForbidden})`);
	                } catch(e){
	                    isForbidden = false;
	                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService::matchesForbiddenPattern: exception: forbiddenPattern=${forbiddenPattern} is invalid`);
	                }
	            }

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `ValidateService::matchesForbiddenPattern (input=${value}, forbiddenPattern=${forbiddenPattern}, isForbidden=${isForbidden}`);
	            return isForbidden;
	        }


	        /**
	         * See {@link Wincor.UI.Service.BaseService#onServicesReady}.
	         *
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onServicesReady() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ValidateService::onServicesReady()`);

	            _viewService = this.serviceProvider.ViewService;

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< ValidateService::onServicesReady`);
	            return super.onServicesReady();
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ ValidateServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$c = getServiceClass$f({
	    Wincor: Wincor$2,
	    LogProvider,
	    PTService
	});

	const ServiceInterface$c = {
	    ValidateProxy: {
	        service: "../service/wn.UI.Service.ValidateService.js",
	        interface: {
	            Expand_StandardFunctions: {
	                attributes: [
	                    "isNumbers",
	                    "isChars",
	                    "isEmail",
	                    "isDateFormat",
	                    "isDateInRange",
	                    "isInRange",
	                    "isMin",
	                    "isMax",
	                    "isStepLen",
	                    "isWithinMinLength",
	                    "isWithinMaxLength",
	                    "isWithinLength",
	                    "checkLeadingZero",
	                    "matchesForbiddenPattern",
	                ],
	                type: "function",
	            },
	        },
	    },
	};

	var ValidateService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$c,
		ServiceClass: ServiceClass$c
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.VideoService.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$g = ({ Wincor, ext, LogProvider, PTService }) => {
	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;

	    return class VideoService extends PTService {
	        /**
	         * The logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         * @default "VideoService"
	         */
	        NAME = "VideoService";

	        /**
	         * See {@link Wincor.UI.Service.PTService#constructor}.
	         * Initialize some private members.
	         *
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> VideoService::VideoService");

	            this.FRM_RESOLVE_REQUEST.service = this.NAME;
	            this.FRM_RESOLVE_REQUEST.FWName = "VIDEO";
	            this.initialLocation = {
	                top: 0,
	                left: 0,
	                width: 1024,
	                height: 768,
	            };
	            this.baseLocation = Object.assign({}, this.initialLocation);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< VideoService::VideoService");
	        }
	        
	        /**
	         * Called automatically as soon as there is an answer to an asynchronous ProTopas request. See {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * This method retruns return code (RC) of supported function ID's, else (-1)
	         *
	         * @param {object} message    Response object, see {@link Wincor.UI.Service.BaseService#translateResponse}.
	         * @returns {number} ret      Return code (RC) of supported function ID's, else (-1).
	         */
	        translateResponse(message) {
	            _logger.LOG_SRVC_INOUT &&
	                _logger.log(_logger.LOG_SRVC_INOUT, `> VideoService::translateResponse('${JSON.stringify(message)}')`);
	            let ret;

	            if (message.FWFuncID === 4032) {
	                //FUNC_VOLUME_INC
	                ret = message.RC;
	            } else if (message.FWFuncID === 4033) {
	                //FUNC_VOLUME_DEC
	                ret = message.RC;
	            } else if (message.FWFuncID === 4035) {
	                //FUNC_VOLUME_MUTE
	                ret = message.RC;
	            } else if (message.FWFuncID === 4036) {
	                //FUNC_VOLUME_UNMUTE
	                ret = message.RC;
	            } else if (message.FWFuncID === 4022) {
	                //FUNC_MOVE
	                ret = message.RC;
	            } else {
	                _logger.error("Wincor.UI.Service.VideoService(onResponse): unknown function");
	                ret = -1;
	            }
	            _logger.LOG_SRVC_INOUT &&
	                _logger.log(_logger.LOG_SRVC_INOUT, `< VideoService::translateResponse returns ${ret}`);
	            return ret;
	        }

	        /**
	         * This method resize/reposition the video window.
	         *
	         * @param {object} posObject        containing attributes top, left, width and height with values of type number
	         */
	        resizeWindow(posObject) {
	            return ext.Promises.promise((resolve, reject) => {
	                _logger.LOG_SRVC_INOUT &&
	                    _logger.log(_logger.LOG_SRVC_INOUT, `> VideoService::resizeWindow(${JSON.stringify(posObject)})`);
	                const REQUEST = Object.assign({}, this.FRM_RESOLVE_REQUEST);
	                REQUEST.FWFuncID = 4022; // Video method contMove
	                REQUEST.param1 = posObject.left;
	                REQUEST.meta1 = ["LONG", 0];
	                REQUEST.param2 = posObject.top;
	                REQUEST.meta2 = ["LONG", 0];
	                REQUEST.param3 = posObject.width;
	                REQUEST.meta3 = ["LONG", 0];
	                REQUEST.param4 = posObject.height;
	                REQUEST.meta4 = ["LONG", 0];
	                REQUEST.paramUL = 0;
	                _logger.LOG_ANALYSE &&
	                    _logger.log(
	                        _logger.LOG_ANALYSE,
	                        `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`
	                    );
	                this.FrmResolve(REQUEST, (message) => {
	                    const success = message.RC === 0;
	                    _logger.LOG_DETAIL &&
	                        _logger.log(_logger.LOG_DETAIL, `* VideoService::resizeWindow callback success: ${success}`);
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< VideoService::resizeWindow");
	                    if (success) {
	                        this.baseLocation = Object.assign({}, posObject);
	                    }
	                    success ? resolve() : reject();
	                });
	            });
	        }

	        /**
	         * This method increase Volume by %.
	         *
	         * @param {number=} step            Increase step in %, Range: [1-100], Default: 10 (10%)
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        increaseVolume(step, callback) {
	            _logger.LOG_SRVC_INOUT &&
	                _logger.log(_logger.LOG_SRVC_INOUT, `> VideoService::increaseVolume(step:${step}, ...)`);

	            let usStep = 10; // VOLUME_INC_STEP_DEF
	            if (step) {
	                usStep = step;
	            }

	            this.FRM_RESOLVE_REQUEST.FWFuncID = 4032; // FUNC_VOLUME_INC
	            this.FRM_RESOLVE_REQUEST.param1 = usStep;
	            this.FRM_RESOLVE_REQUEST.meta1 = ["USHORT", 0];
	            this.FRM_RESOLVE_REQUEST.param2 = "";
	            this.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param3 = "";
	            this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param4 = "";
	            this.FRM_RESOLVE_REQUEST.meta4 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param5 = "";
	            this.FRM_RESOLVE_REQUEST.meta5 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.paramUL = 0;

	            _logger.LOG_SRVC_DATA &&
	                _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< VideoService::increaseVolume");
	        }

	        /**
	         * This method decrease Volume by %.
	         *
	         * @param {number=} step            Decrease step in %, Range: [1-100], Default: 10 (10%)
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        decreaseVolume(step, callback) {
	            _logger.LOG_SRVC_INOUT &&
	                _logger.log(_logger.LOG_SRVC_INOUT, `> VideoService::decreaseVolume(step:${step}, ...)`);

	            let usStep = 10; // VOLUME_DEC_STEP_DEF
	            if (step) {
	                usStep = step;
	            }

	            this.FRM_RESOLVE_REQUEST.FWFuncID = 4033; // FUNC_VOLUME_DEC
	            this.FRM_RESOLVE_REQUEST.param1 = usStep;
	            this.FRM_RESOLVE_REQUEST.meta1 = ["USHORT", 0];
	            this.FRM_RESOLVE_REQUEST.param2 = "";
	            this.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param3 = "";
	            this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param4 = "";
	            this.FRM_RESOLVE_REQUEST.meta4 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param5 = "";
	            this.FRM_RESOLVE_REQUEST.meta5 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.paramUL = 0;

	            _logger.LOG_SRVC_DATA &&
	                _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< VideoService::decreaseVolume");
	        }

	        /**
	         * This method mute Volume.
	         *
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        mute(callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> VideoService::mute(...)");

	            this.FRM_RESOLVE_REQUEST.FWFuncID = 4035; // FUNC_VOLUME_MUTE
	            this.FRM_RESOLVE_REQUEST.param1 = "";
	            this.FRM_RESOLVE_REQUEST.meta1 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param2 = "";
	            this.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param3 = "";
	            this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param4 = "";
	            this.FRM_RESOLVE_REQUEST.meta4 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param5 = "";
	            this.FRM_RESOLVE_REQUEST.meta5 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.paramUL = 0;

	            _logger.LOG_SRVC_DATA &&
	                _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< VideoService::mute");
	        }

	        /**
	         * This method unmute Volume.
	         *
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        unmute(callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> VideoService::unmute(...)");

	            this.FRM_RESOLVE_REQUEST.FWFuncID = 4036; // FUNC_VOLUME_UNMUTE
	            this.FRM_RESOLVE_REQUEST.param1 = "";
	            this.FRM_RESOLVE_REQUEST.meta1 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param2 = "";
	            this.FRM_RESOLVE_REQUEST.meta2 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param3 = "";
	            this.FRM_RESOLVE_REQUEST.meta3 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param4 = "";
	            this.FRM_RESOLVE_REQUEST.meta4 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.param5 = "";
	            this.FRM_RESOLVE_REQUEST.meta5 = ["NULL", 0];
	            this.FRM_RESOLVE_REQUEST.paramUL = 0;

	            _logger.LOG_SRVC_DATA &&
	                _logger.log(_logger.LOG_SRVC_DATA, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(this.FRM_RESOLVE_REQUEST, callback);

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< VideoService::unmute");
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseService#onServicesReady}
	         *
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onServicesReady() {
	            return ext.Promises.promise((resolve, reject) => {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> VideoService::onServicesReady()");
	                // we only want to register and reposition if we are loaded from GUIAPP
	                const sp = this.serviceProvider;
	                const configService = sp.ConfigService;
	                const viewService = sp.ViewService;
	                const eventSvc = sp.EventService;
	                if (sp.getInstanceName() === "GUIAPP") {
	                    ext.Promises.Promise.all([configService.whenReady, viewService.whenReady, eventSvc.whenReady])
	                        .then(() => {
	                            // read the VIDEO positioning
	                            return configService.getConfiguration("CCOPEN\\VIDEO", null);
	                        })
	                        .then((config) => {
	                            // check if config is available, if not just skip this registration and processing
	                            _logger.LOG_SRVC_DATA &&
	                                _logger.log(
	                                    _logger.LOG_SRVC_DATA,
	                                    `* onServicesReady CCOPEN\\VIDEO :\n'${JSON.stringify(config)}'.`
	                                );
	                            let keys = Object.keys(config);
	                            if (keys.length === 0 || !keys.includes("WINDOW_SIZEX")) {
	                                _logger.LOG_SRVC_DATA &&
	                                    _logger.log(
	                                        _logger.LOG_SRVC_DATA,
	                                        `* onServicesReady CCOPEN\\VIDEO not available, skipping registrations`
	                                    );
	                                return;
	                            }
	                            this.initialLocation = {
	                                top: config["WINDOW_POSY"] || 0,
	                                left: config["WINDOW_POSX"] || 0,
	                                width: config["WINDOW_SIZEX"] || 1024,
	                                height: config["WINDOW_SIZEY"] || 768,
	                            };
	                            _logger.LOG_SRVC_DATA &&
	                                _logger.log(
	                                    _logger.LOG_SRVC_DATA,
	                                    `* onServicesReady read initialLocation of VIDEO :\n'${JSON.stringify(
                                        this.initialLocation
                                    )}'.`
	                                );
	                            // we register for ViewService LOCATION_CHANGED and reposition ourself accordingly
	                            const GUIAPP_WIDTH = viewService.initialLocation.width;
	                            const GUIAPP_HEIGHT = viewService.initialLocation.height;
	                            const X_FACTOR = this.initialLocation.width / GUIAPP_WIDTH;
	                            const Y_FACTOR = this.initialLocation.height / GUIAPP_HEIGHT;

	                            viewService.registerForServiceEvent(
	                                viewService.SERVICE_EVENTS.LOCATION_CHANGED,
	                                (locationData) => {
	                                    let resize = false;
	                                    let loc;
	                                    if (locationData.source.instanceName === "GUIAPP") {
	                                        resize = true;
	                                        loc = locationData.source.location;
	                                    } else if (locationData.target.instanceName === "GUIAPP") {
	                                        resize = true;
	                                        loc = locationData.target.location;
	                                    }

	                                    if (resize) {
	                                        _logger.LOG_SRVC_DATA &&
	                                            _logger.log(
	                                                _logger.LOG_SRVC_DATA,
	                                                `* onServicesReady received LOCATION_CHANGED: \n ${JSON.stringify(
                                                    locationData,
                                                    null,
                                                    " "
                                                )}`
	                                            );
	                                        if (
	                                            loc.left !== viewService.initialLocation.left ||
	                                            loc.top !== viewService.initialLocation.top
	                                        ) {
	                                            _logger.LOG_SRVC_DATA &&
	                                                _logger.log(
	                                                    _logger.LOG_SRVC_DATA,
	                                                    `* onServicesReady received LOCATION_CHANGED with different top/left!`
	                                                );
	                                            this.resizeWindow({
	                                                top: Math.round(loc.top + this.initialLocation.top * Y_FACTOR),
	                                                left: Math.round(loc.left + this.initialLocation.left * X_FACTOR),
	                                                width: Math.round(this.initialLocation.width * X_FACTOR),
	                                                height: Math.round(this.initialLocation.height * Y_FACTOR),
	                                            });
	                                        } else {
	                                            _logger.LOG_SRVC_DATA &&
	                                                _logger.log(
	                                                    _logger.LOG_SRVC_DATA,
	                                                    `* onServicesReady received LOCATION_CHANGED with same top/left!`
	                                                );
	                                            this.resizeWindow({
	                                                top: this.initialLocation.top,
	                                                left: this.initialLocation.left,
	                                                width: this.initialLocation.width,
	                                                height: this.initialLocation.height,
	                                            });
	                                        }
	                                    }
	                                },
	                                true
	                            );
	                            // reset on session end
	                            const TXN_EVENTS = eventSvc.getEventInfo("TRANSACTION_MODULE");
	                            eventSvc.registerForEvent(
	                                TXN_EVENTS.ID_SESSION_END,
	                                TXN_EVENTS.NAME,
	                                () => {
	                                    _logger.LOG_ANALYSE &&
	                                        _logger.log(
	                                            _logger.LOG_ANALYSE,
	                                            `* VideoService::onServicesReady() received ID_SESSION_END initialLocation:
                                    \n${JSON.stringify(
                                        this.initialLocation,
                                        null,
                                        " "
                                    )}\nbaseLocation:\n${JSON.stringify(this.baseLocation, null, " ")}`
	                                        );
	                                    if (
	                                        this.baseLocation.top !== this.initialLocation.top ||
	                                        this.baseLocation.left !== this.initialLocation.left ||
	                                        this.baseLocation.width !== this.initialLocation.width ||
	                                        this.baseLocation.height !== this.initialLocation.height
	                                    ) {
	                                        window.setTimeout(() => {
	                                            this.resizeWindow({
	                                                top: this.initialLocation.top,
	                                                left: this.initialLocation.left,
	                                                width: this.initialLocation.width,
	                                                height: this.initialLocation.height,
	                                            });
	                                        }, 1);
	                                    }
	                                },
	                                void 0,
	                                "ASCII",
	                                true
	                            );
	                            return super.onServicesReady();
	                        })
	                        .then(resolve)
	                        .catch((e) => {
	                            sp.propagateError(this.NAME, "onServicesReady", e);
	                        });
	                } else {
	                    super.onServicesReady().then(resolve);
	                }
	            });
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ VideoServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$d = getServiceClass$g({
	    Wincor: Wincor$2,
	    ext: ext$2,
	    LogProvider,
	    PTService
	});

	const ServiceInterface$d = {
	    VideoProxy: {
	        service: "../service/wn.UI.Service.VideoService.js",
	        interface: {
	            increaseVolume: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            decreaseVolume: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            mute: {
	                type: "function",
	                callbackArgumentIndex: 0,
	            },
	            unmute: {
	                type: "function",
	                callbackArgumentIndex: 0,
	            },
	        },
	    },
	};

	var VideoService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$d,
		ServiceClass: ServiceClass$d
	});

	/**
	 @preserve
	 Copyright (c) 2001-2021 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.ViewService.js 4.3.1-210702-21-a51e474c-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$h = ({ Wincor, jQuery, ext, LogProvider, PTService }) => {
	    /**
	     * The logger.
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider}
	     * @const
	     */
	    const _logger = LogProvider;

	    /**
	     * Marks the start of a property inside another string.
	     * @type {String}
	     * @const
	     */
	    const PROP_MARKER = "[&";

	    /**
	     * Marks the end of a property inside another string.
	     * @type {String}
	     * @const
	     */
	    const PROP_END_MARKER = "&]";

	    /**
	     * Marks the start of a replace-string inside another string.
	     * @type {String}
	     * @const
	     */
	    const VAR_REPLACE_MARKER = "(#";

	    /**
	     * Marks the end of a replace-string inside another string.
	     * @type {String}
	     * @const
	     */
	    const VAR_REPLACE_END_MARKER = "#)";

	    let STYLE_ID = 0;

	    /**
	     * The states of the GUI impl.
	     * @type {{DISPLAY_SYNC: number, WAIT_FOR_CANCELLATION: number, INIT: number, DISPLAY: number, PREPARE: number, ERROR: number, WAIT: number, WAIT_FOR_PREPARATION: number, UN_INIT: number, WAIT_FOR_ACTIVATION_SYNC: number, WAIT_FOR_ACTIVATION: number}}
	     */
	    const GUI_STATUS = {
	        UN_INIT: 0,
	        INIT: 1,
	        WAIT: 2,
	        DISPLAY: 3,
	        PREPARE: 6,
	        ERROR: 8,
	        WAIT_FOR_PREPARATION: 9,
	        WAIT_FOR_ACTIVATION: 10,
	        DISPLAY_SYNC: 11,
	        WAIT_FOR_ACTIVATION_SYNC: 12,
	        WAIT_FOR_CANCELLATION: 13
	    };

	    return class ViewService extends PTService {
	        /**
	         * The logical name of this service as used in the service-provider.
	         * @const
	         * @type {string}
	         * @default ViewService
	         */
	        NAME = "ViewService";

	        /**
	         * Holds the `viewKey` and the `viewID`, which are sent from the business logic.
	         *
	         * The `viewURL` is retrieved from the viewkey-configuration and the same as `viewConfig.url`.
	         *
	         * The `viewID` is a continuous number, which helps the business logic to match requests, return codes and events to the appropriate Display() requests.
	         * Because the communication is asynchronouse (events can overtake each other, can arrive before a apprpriate response etc.) it is important to know, to which viewID an event belongs.
	         *
	         * Holds the viewKey-specific `viewConfig`, which is read from the configuration.
	         *
	         * @example
	         * viewContext = {
	         *   viewKey = "PrepaidChargingNumberReceiptQuestion",
	         *   viewURL = "question.html",
	         *   viewID = 562,
	         *   viewConfig = {"commandconfig":{"CANCEL":"3","YES":"0"},"timeout":20000,"url":"question.html"}
	         * }
	         * @type {Object}
	         */
	        viewContext = null;

	        /**
	         * ID for the interactionTimeout supplied by the call to {@link Wincor.UI.Service.ViewService#display}.
	         * @type {Number}
	         * @default 0
	         */
	        interactionTimerId = 0;

	        /**
	         * Interaction-timeout supplied by the call to {@link Wincor.UI.Service.ViewService#display}.
	         * @type {Number}
	         * @default -1
	         */
	        interactionTimeoutValue = -1;

	        /**
	         * This flag is true if content is currently interactive, false otherwise.
	         * @type {Boolean}
	         * @default false
	         */
	        contentRunning = false;

	        /**
	         * This flag is true if a popup is currently active, false otherwise.
	         * Actually the flag is set/reset when {@link Wincor.UI.Service.ViewService#firePopupNotification} is called.
	         * @type {Boolean}
	         * @default false
	         */
	        popupActive = false;

	        /**
	         * Flag gets set when you call {@link Wincor.UI.Service.ViewService#display}. It means the view will
	         * automatically get activated when it is initialized successfully.
	         * It is set to false, if you call {@link Wincor.UI.Service.ViewService#prepare}. In this case
	         * {@link Wincor.UI.Service.ViewService#activate} has to be called after the event
	         * {@link Wincor.UI.Service.ViewService#EVENT_PREPARED} has been received.
	         * @type {Boolean}
	         * @default true
	         */
	        autoActivate = true;

	        /**
	         * Defines the default page that is displayed if a call to {@link Wincor.UI.Service.ViewService#display} did not contain a viewKey.
	         * @type {string}
	         * @default ../../content_xy/views/outofservice.html
	         */
	        errorURL = "../../content_*/views/outofservice.html";

	        /**
	         * The first URL that gets loaded by {@link Wincor.UI.Service.ViewService#startSPA}.
	         * @type {string}
	         * @default "../../content_softkey/views/index.html"
	         */
	        startURL = "../../content_softkey/views/index.html";

	        /**
	         * The previous URL which was displayed.
	         * @type {string}
	         * @default ""
	         */
	        previousViewUrl = "";

	        /**
	         * Flag that tells if the next view will change the viewset. The new viewset has already been loaded!
	         * @type {boolean}
	         * @default false
	         */
	        isRestartOnNextDisplay = false;

	        /**
	         * This object contains all view-service events, for which other services or view-models can register itself.
	         * @enum {string}
	         */
	        SERVICE_EVENTS = {
	            /**
	             * Sent if 'navigation' should be started. Used by shell.js to operate durandal router sends data as object.
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:NAVIGATE_SPA
	             * @eventtype service
	             */
	            NAVIGATE_SPA: "NAVIGATE_SPA",

	            /**
	             * Sent if a view is about to get inactive.
	             * This event can be used to clean up before the current view-context is destroyed.
	             * @type {string}
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_CLOSING
	             * @eventtype service
	             */
	            VIEW_CLOSING: "VIEW_CLOSING",

	            /**
	             * Sent if a new view is about to be initialized.
	             * @type {string}
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_BEFORE_CHANGE
	             * @eventtype service
	             */
	            VIEW_BEFORE_CHANGE: "VIEW_BEFORE_CHANGE",

	            /**
	             * Sent if a view (all included view-models) has retrieved all initial text and data values.
	             * At this stage also the DOM has been scanned and prepared for commanding.
	             * When receiving this event the view is neither active nor visible to the customer.
	             * @type {string}
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_PREPARED
	             * @eventtype service
	             */
	            VIEW_PREPARED: "VIEW_PREPARED",

	            /**
	             * Sent if a view has to turn interactive and visible.
	             * @type {string}
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:TURN_ACTIVE
	             * @eventtype service
	             */
	            TURN_ACTIVE: "TURN_ACTIVE",

	            /**
	             * Triggered if a viewModel updates its content and has notified the baseViewModel.
	             * Empty string or a new prefix for localization.
	             * @type {string}
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:CONTENT_UPDATE
	             * @eventtype service
	             */
	            CONTENT_UPDATE: "CONTENT_UPDATE",

	            /**
	             * Sent if a view is ready to receive customer input.
	             * data: {Object} viewContext
	             * @type {string}
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_ACTIVATED
	             * @eventtype service
	             */
	            VIEW_ACTIVATED: "VIEW_ACTIVATED",

	            /**
	             * Sent if a view-timeout occurred.
	             * @type {string}
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_USERINTERACTION_TIMEOUT
	             * @eventtype service
	             */
	            VIEW_USERINTERACTION_TIMEOUT: "VIEW_USERINTERACTION_TIMEOUT",

	            /**
	             * Sent if the appropriated business logic property has changed.
	             * @type {string}
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:STYLE_TYPE_CHANGED
	             * @eventtype service
	             */
	            STYLE_TYPE_CHANGED: "STYLE_TYPE_CHANGED",

	            /**
	             * Sent if a popup has been activated
	             * @type {string}
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:POPUP_ACTIVATED
	             * @eventtype service
	             * @example
	             * eventData: {String} popupType
	             */
	            POPUP_ACTIVATED: "POPUP_ACTIVATED",

	            /**
	             * Sent if a popup has been deactivated
	             * @type {string}
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:POPUP_DEACTIVATED
	             * @eventtype service
	             * @example
	             * eventData: {String} popupType
	             */
	            POPUP_DEACTIVATED: "POPUP_DEACTIVATED",

	            /**
	             * Sent when the timeout is about to be refreshed, the timeout is sent as data
	             * type {string}
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:REFRESH_TIMEOUT
	             * @eventtype service
	             */
	            REFRESH_TIMEOUT: "REFRESH_TIMEOUT",

	            /**
	             * Sent if the viewset is about to change (the complete application-host page is reloaded)
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:SHUTDOWN
	             * @eventtype service
	             */
	            SHUTDOWN: "SHUTDOWN",

	            /**
	             * The view service fires this event when the current view should get suspended
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:SUSPEND
	             * @eventtype service
	             */
	            SUSPEND: "SUSPEND",

	            /**
	             * This event tells to resume a currently suspended view
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:RESUME
	             * @eventtype service
	             */
	            RESUME: "RESUME",

	            /**
	             * Sent when the baseLocation changes due to active monitor
	             * event data: object with new basLocation data
	             * @event Wincor.UI.Service.ViewService#SERVICE_EVENTS:LOCATION_CHANGED
	             * @eventtype service
	             * @example
	             * {
	             *   source: {
	             *      instanceName: "nnn",
	             *      location: {
	             *        top: y,
	             *        left: x,
	             *        width: w,
	             *        height: h
	             *      }
	             *   },
	             *   target: {
	             *      instanceName: "mmm",
	             *      location: {
	             *        top: y,
	             *        left: x,
	             *        width: w,
	             *        height: h
	             *      }
	             *   }
	             * }
	             */
	            LOCATION_CHANGED: "LOCATION_CHANGED"
	        };

	        /**
	         * Name of the event being sent to the business-logic if a view ends.
	         * @const
	         * @type {String}
	         * @private
	         */
	        EVENT_NAME_UIRESULT = "UIResult";

	        /**
	         * This event is sent if a view ends.
	         * The EVENT_UIRESULT object extends {@link Wincor.UI.Service.BaseService#EVENT} with the following elements:<br>
	         * <code>EVENT_UIRESULT.UIResult: {string}</code><br>
	         * <code>EVENT_UIRESULT.UIDetailedResult: {string}</code><br>
	         * @eventtype native
	         * @event  Wincor.UI.Service.ViewService#EVENT_UIRESULT
	         * @type {object}
	         */
	        EVENT_UIRESULT = null;

	        /**
	         * This event is sent if a view is interactive and ready to receive input from the customer.
	         * When a view gets active, the interactive-timeout is started, which will fire the event:
	         * {@link Wincor.UI.Service.ViewService.SERVICE_EVENTS#VIEW_USERINTERACTION_TIMEOUT} to registered callbacks and
	         * the appropriate timeout-event to the business-logic.
	         * @type {Object}
	         * @eventtype native
	         * @event  Wincor.UI.Service.ViewService#EVENT_ACTIVATED
	         */
	        EVENT_ACTIVATED = null;

	        /**
	         * This event is sent if a view is activating / deactivating a popup.
	         * @type {Object}
	         * @eventtype native
	         * @event  Wincor.UI.Service.ViewService#EVENT_POPUP
	         */
	        EVENT_POPUP = null;

	        /**
	         * This event is sent when the current view has gathered initial text and data, but before a data-binding has
	         * been established. The view is not yet visible at that moment.
	         * @type {Object}
	         * @eventtype native
	         * @event  Wincor.UI.Service.ViewService#EVENT_PREPARED
	         */
	        EVENT_PREPARED = null;

	        /**
	         * This event is sent to the business logic if a view gets updated (event number 4022 of PceGui.h)
	         * @type {Object}
	         * @eventtype native
	         * @event  Wincor.UI.Service.ViewService#EVENT_CONTENT_UPDATED
	         */
	        EVENT_CONTENT_UPDATED = null;

	        /**
	         * Value to be used in {@link Wincor.UI.Service.ViewService#endView} for a successful view-lifecycle
	         * @type {string}
	         * @const
	         */
	        UIRESULT_OK = "0";

	        /**
	         * Value used in {@link Wincor.UI.Service.ViewService#endView} automatically if an interactionTimeout occurs.
	         * @type {string}
	         * @const
	         */
	        UIRESULT_TIMEOUT_USER = "2";

	        /**
	         * Value used in {@link Wincor.UI.Service.ViewService#endView} if the user canceled the view.
	         * @type {string}
	         * @const
	         */
	        UIRESULT_CANCEL_USER = "3";

	        /**
	         * Value used in {@link Wincor.UI.Service.ViewService#endView} if the ViewService receives a cancel-request
	         * during an active view.
	         * @type {string}
	         * @const
	         */
	        UIRESULT_CANCEL_SW = "4";

	        /**
	         * Value used in {@link Wincor.UI.Service.ViewService#endView} if an error occurred during processing the view.
	         * @type {string}
	         * @const
	         */
	        UIRESULT_ERROR_VIEW = "5";

	        /**
	         * Value used in {@link Wincor.UI.Service.ViewService#endView} if the ViewService receives a cancel-request
	         * but there is no active view.
	         * @type {string}
	         * @const
	         */
	        UIRESULT_CANCEL_SW_ERROR = "8";

	        /**
	         * Value used in {@link Wincor.UI.Service.ViewService#endView} if the ViewService receives a cancel- of display request
	         * but there is no active view.
	         * @example
	         * UI_DETAILED_RESULT: {
	         *      CANCEL: "CANCEL";
	         *      DISPLAY: "DISPLAY"
	         * }
	         * @type {Object}
	         * @const
	         */
	        UI_DETAILED_RESULT = {
	            CANCEL: "CANCEL",
	            DISPLAY: "DISPLAY"
	        };

	        /**
	         * Defines the default 'interactionTimeout' if a view is called without a timeout given.
	         * @type {Number}
	         * @default -1
	         */
	        pageTimeout = -1;

	        /**
	         * Defines the value that represents 'ImmediateTimeout'.
	         * @type {Number}
	         * @default 0
	         */
	        immediateTimeout = 0;

	        /**
	         * Defines the value that represents 'EndlessTimeout'.
	         * @type {Number}
	         * @default -1
	         */
	        endlessTimeout = -1;

	        /**
	         * Defines the value that represents 'MessageTimeout'. Deleted as soon as the config is outside of ViewService.
	         * @type {Number}
	         * @default 5000
	         */
	        messageTimeout = 5000;

	        /**
	         * Defines the value that represents 'ConfirmationTimeout'. Deleted as soon as the config is outside of ViewService.
	         * @type {Number}
	         * @default 30000
	         */
	        confirmationTimeout = 30000;

	        /**
	         * Defines the value that represents 'InputTimeout'. Deleted as soon as the config is outside of ViewService.
	         * @type {Number}
	         * @default 120000
	         */
	        inputTimeout = 120000;

	        /**
	         * Defines the value that represents 'PinEntryTimeout'. Deleted as soon as the config is outside of ViewService.
	         * @type {Number}
	         * @default 30000
	         */
	        pinentryTimeout = 30000;

	        /**
	         * The viewkey configuration, i.e. a mapping from the viewkey name to its configuration object.
	         *
	         * @type {Object}
	         * @default null
	         */
	        urlMapping = null;

	        /**
	         * Contains mappings read from the configuration to apply for UIResult of the current view.
	         * The JSON string looks like follows:
	         * @example
	         * "resultMapping": {
	         *     "2": "0",
	         *     "3": "0"
	         * }
	         *
	         * With this configuration a timeout or user-cancel of this view would be mapped both to UIResultOK -> "0"
	         * with interactionResult set to "mappedFrom:ORIGINALRESULT:ORIGINALINTERACTIONRESULT"
	         *
	         * @type {Object}
	         * @default null
	         */
	        resultMapping = null;

	        /**
	         * Defines a default view key object, onto which the configured viewkey values are merged.
	         * @type {Object}
	         * @default {}
	         */
	        DEFAULT_VIEWKEY_VALUES = {};

	        /**
	         * Contains alls the configured timeout values.
	         * @example
	         * {
	         *   ImmediateTimeout = 0,
	         *   EndlessTimeout = -1,
	         *   MessageTimeout = 5000,
	         *   ConfirmationTimeout = 30000
	         * }
	         * @type {Object}
	         * @default {}
	         */
	        DEFAULT_TIMEOUT_VALUES = {};

	        /**
	         * Objects which contains all the template viewkeys and their configuration.
	         * @example
	         * {
	         *   //...
	         *   "Question": {"timeout":"(#InputTimeout#)","url":"question.html"},
	         *   "QuestionOther": {"commandconfig":{"OTHER":"0"},"timeout":"(#InputTimeout#)","url":"question.html"}
	         *   //..
	         * }
	         * @type {Object}
	         * @default {}
	         */
	        TEMPLATE_VIEWKEYS = {};

	        /**
	         * Object which contains the configuration of the keyword mapping.
	         * @type {Object}
	         * @default {}
	         */
	        KEYWORD_MAPPING = {};

	        /**
	         * The name of the content frame.
	         * @default '#applicationContent'
	         * @type {String}
	         */
	        CONTENT_FRAME_NAME = "#applicationContent";

	        /**
	         * List for the soft key (Y) positions of the view.
	         * The values will retrieved by the configuration during initialization and are in percentage
	         * relative to the upper/left corner of the window.
	         * Furthermore the list contains 4 position only, because we assume that left Y positions is equal to the right Y positions.
	         * @type {Array.<number>}
	         * @default []
	         */
	        softkeyPositionsY = [];

	        /**
	         * This flag is set during the time, a new viewset is loaded. Calls to 'display' or 'prepare' will be postponed while restarting.
	         * @type {boolean}
	         * @default false
	         */
	        restarting = false;

	        /**
	         * This flag represents the value of the same named key read from "general" configuration section and tells, if HTML fragments should be cached by require.js (text-plugin).
	         * @type {boolean}
	         * @default false
	         */
	        cacheHTML = false;

	        /**
	         * The current viewset
	         * @type {string}
	         * @default softkey
	         */
	        viewSetName = "softkey";

	        /**
	         * The default viewset name for ada transactions
	         */
	        adaViewSet = "softkey";

	        /**
	         * The default initial view set
	         * @type {string}
	         * @default softkey
	         */
	        initialViewSet = "softkey";

	        /**
	         * Initial location of the window will be read on first display call.
	         * @example
	         *  {
	         *    top: 0,
	         *    left: 0,
	         *    width: 0,
	         *    height: 0
	         *  }
	         * @type {null | Object}
	         * @default null
	         */
	        initialLocation = null;

	        /**
	         * Base location of the window initially matches initialLocation but changes when swapped.
	         * @example
	         *{
	         *   top: 0,
	         *   left: 0,
	         *   width: 0,
	         *   height: 0
	         *}
	         * @type {null | Object}
	         * @default null
	         */
	        baseLocation = null;

	        /**
	         * Tells if a new viewset is about to be loaded
	         * @type {boolean}
	         * @default false
	         */
	        loadingViewSet = false;

	        /**
	         * The current default style type (without an ending slash).
	         * Is set by <i>StyleResourceResolver</i>, then
	         * this property is up to date.
	         * @default 'MercuryDark'
	         * @type {string}
	         */
	        currentStyleType = "MercuryDark"; // this property does not include the ending slash '/', because its gonna ask by getProperty and a slash would disturb

	        /**
	         * The current default style type set by the key value of "CCTAFW_PROP_UI_STYLESHEET_KEY"(with an ending slash).
	         * Is set when the property "CCTAFW_PROP_UI_STYLESHEET_KEY" changes.
	         * This member becomes important if the view set has been switched in order to run the currently desired style rather than the initial style from config.
	         * Usually the OP switches back the property to a default when going into idle loop - then the initial style is used again.
	         * @default ""
	         * @type {string}
	         */
	        currentStyleTypeByStylesheetKey = "";

	        /**
	         * The current default vendor (without an ending slash).
	         * When someone changes the vendor, e.g. <i>StyleResourceResolver</i>, then
	         * this property must be up to date.
	         * @default 'default'
	         * @type {string}
	         */
	        currentVendor = "default"; // this property does not include the ending slash '/', because its gonna ask by getProperty and a slash would disturb

	        /**
	         * The current default resolution (without an ending slash).
	         * When someone changes the resolution, e.g. <i>StyleResourceResolver</i>, then
	         * this property must be up to date.
	         * @default 'default'
	         * @type {string}
	         */
	        currentResolution = "default"; // this property does not include the ending slash '/', because its gonna ask by getProperty and a slash would disturb

	        /**
	         * Contains the name of the instance that has been swapped location with.
	         * If location has been swapped back, or has never been swapped, the value will be empty.
	         * @type {string}
	         * @default ""
	         */
	        currentSwapTarget = "";

	        /**
	         * Contains the current suspendIds.
	         * @type {Array<number>}
	         * @default []
	         */
	        suspendList = [];

	        /**
	         * Tells whether we are suspended or not
	         * @type {boolean}
	         * @default false
	         */
	        isSuspended = false;

	        /**
	         * The suspendId counter.
	         * @type {number}
	         * @default 0
	         */
	        suspendId = 0;

	        /**
	         * Sets ViewService-specific FRM_RESOLVE_REQUEST parameters, so that the name of this service is sent in every request.
	         * See {@link Wincor.UI.Service.PTService#constructor}.
	         * Initializes objects for every event, which are sent to the application, like `EVENT_UIRESULT` etc.
	         * Prepare `DEFAULT_VIEWKEY_VALUES`, which contains the required parameters for every viewkey configuration.
	         * Initialize `requestMap`, which stores the delegates for the requests.
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.PTService#constructor}.
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::VideoService");
	            const frameName = window.localStorage.getItem("activeFrameName");
	            this.CONTENT_FRAME_NAME = frameName ? `#${window.localStorage.getItem("activeFrameName")}` : "";
	            this.contentRunning = false;

	            //setup message / events
	            this.EVENT_UIRESULT = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                eventName: this.EVENT_NAME_UIRESULT,
	                viewID: -1,
	                UIResult: null
	            });

	            this.EVENT_ACTIVATED = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                viewID: -1,
	                eventName: "UIStateActivated"
	            });

	            this.EVENT_PREPARED = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                viewID: -1,
	                eventName: "UIStatePrepared"
	            });

	            this.EVENT_POPUP = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                eventName: "4021", //pce::gui::EVENT_POPUP_NOTIFICATION
	                eventData: "" //must contain defines from PceGui.h
	            });

	            this.EVENT_CONTENT_UPDATED = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                eventName: "4022", //pce::gui::EVENT_POPUP_NOTIFICATION
	                eventData: "" //must contain defines from PceGui.h
	            });

	            this.DEFAULT_VIEWKEY_VALUES = {
	                url: "",
	                timeout: this.messageTimeout,
	                popup: {
	                    oncancel: true,
	                    ontimeout: true,
	                    beepontimeout: false,
	                    beepontimeoutperiod: 0
	                }
	            };

	            //fill up request delegate
	            this.requestMap.set("display", this.display.bind(this));
	            this.requestMap.set("cancel", this.cancel.bind(this));
	            this.requestMap.set("prepare", this.prepare.bind(this));
	            this.requestMap.set("activate", this.activate.bind(this));
	            this.requestMap.set("readConfiguration", this.readConfiguration.bind(this));
	            this.requestMap.set("resetUserInteractionTimeout", this.resetUserInteractionTimeout.bind(this));

	            this.viewContext = {
	                viewKey: null,
	                viewURL: null,
	                viewConfig: null,
	                viewID: -1
	            };
	            this.FRM_RESOLVE_REQUEST.service = this.NAME;
	            this.resultMapping = {};
	            this.errorURL = "../../content_*/views/outofservice.html";
	            this.startURL = "../../content_softkey/views/index.html";
	            this.previousViewUrl = "";
	            this.isRestartOnNextDisplay = false;
	            // keeps style element references set from outside
	            this.addedStyles = new Map();

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::VideoService");
	        }

	        /**
	         * Gets the content document.
	         * @param {string} frmName      The name of the content frame to load
	         * @returns {Document}          The content document
	         */
	        getContentWindowDocument(frmName) {
	            const frame = jQuery(frmName);
	            return frame.length > 0 ? frame.contents()[0] : window.document; // due to unit test compatibility, because there is no iframe
	        }

	        /**
	         * Loads the given URL into the content frame.
	         *
	         * @param {string} url      The URL for the content frame.
	         * @param {string} frmName  The name of the content frame to load.
	         */
	        loadContentUrl(url, frmName) {
	            Wincor.UI.Content = null; // clear old content before load new -url
	            const frame = jQuery(frmName);
	            frame[0].contentWindow.Wincor = Wincor;
	            frame.attr("src", url);
	            frame.css("display", "block");
	        }

	        /**
	         * This method has to be called when a view ends due to an offline situation.
	         * @param {string} resultDetail     The additional error data for the offline situation.
	         */
	        offlineHandling(resultDetail) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::offlineHandling(" + resultDetail + ")");
	            if(typeof resultDetail === "undefined" || resultDetail === null) {
	                resultDetail = "ERROR_VIEW_SERVER_OFFLINE";
	            } else {
	                resultDetail = "ERROR_VIEW_SERVER_OFFLINE" + resultDetail;
	            }
	            this.endView(this.UIRESULT_ERROR_VIEW, resultDetail);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::offlineHandling");
	        }

	        /**
	         * This method has to be called when a view ends (due to a timeout, user-interaction, ...).
	         * The resultCode will be propagated to the business-logic which previously started the view.
	         * This method triggers the {@link Wincor.UI.Service.ViewService#SERVICE_EVENTS.VIEW_CLOSING} event
	         * and sends {@link Wincor.UI.Service.ViewService#EVENT_UIRESULT} to the business-logic.
	         *
	         * @param {string} resultCode       The resultCode to be evaluated by business-logic.
	         * @param {string=} resultDetail    The detailed result (e.g. a user interaction like a button press) leading to this resultCode.
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:REFRESH_TIMEOUT
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_CLOSING
	         * @fires Wincor.UI.Service.ViewService#EVENT_UIRESULT
	         */
	        endView(resultCode, resultDetail) {
	            const href = this.getContentWindowDocument(this.CONTENT_FRAME_NAME).location.href;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::endView(${resultCode}, ${resultDetail}) received for page: ${href}`);
	            //After this _logger function we are interruptable. If then Cancel() is called and calls endView (because contentRunning is still true), then
	            //it sends the message in the if-clause below. If the initial thread, which was interrupted here, starts to work again, contentRunning is false
	            //and no message will be send. That's okay, because it is important that the Cancel() produces a GUIResult event with resultCode UIRESULT_CANCEL_SW,
	            //and that will happen.
	            this.clearTimeout();
	            this.fireServiceEvent(this.SERVICE_EVENTS.REFRESH_TIMEOUT, -1);

	            if(this.contentRunning) {
	                this.contentRunning = false;
	                // Do not set contentRunning later (even not after _logger.log) because when using the send-event methods of the gateway the main thread is interruptable.
	                // Then, Cancel() might be called, which also uses contentRunning. That must then aleady be false.
	                // See also comment in processDisplay() method

	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* | VIEW ------ endView ------ ${resultCode}/${resultDetail}`);

	                if(resultDetail === void 0 || resultDetail === null) {
	                    if(resultCode === this.UIRESULT_CANCEL_USER ||
	                       resultCode === this.UIRESULT_ERROR_VIEW ||
	                       resultCode === this.UIRESULT_CANCEL_SW ||
	                       resultCode === this.UIRESULT_CANCEL_SW_ERROR ||
	                       resultCode === this.UIRESULT_TIMEOUT_USER
	                    ) {
	                        this.EVENT_UIRESULT.UIResult = resultCode;
	                        this.EVENT_UIRESULT.UIDetailedResult = "";
	                        // resultMapping

	                        if(this.resultMapping && this.resultMapping[resultCode] !== void 0) {
	                            resultDetail = `mappedFrom:${resultCode}:`;
	                            resultCode = this.resultMapping[resultCode];
	                            this.EVENT_UIRESULT.UIResult = resultCode;
	                            this.EVENT_UIRESULT.UIDetailedResult = resultDetail;
	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. ViewService::endView resultMapping (no result detail) configured! Mapping to '${resultCode}'/'${resultDetail}'`);
	                        }
	                    } else {
	                        // Do not let this one pass! It's an error!
	                        _logger.error("ViewService::endView no resultDetail (interactionResult) argument given! Returning UIRESULT_ERROR_VIEW!");
	                        this.EVENT_UIRESULT.UIResult = this.UIRESULT_ERROR_VIEW;
	                        this.EVENT_UIRESULT.UIDetailedResult = "MISSING_INTERACTION_RESULT"; // just to be traceable
	                    }
	                } else {
	                    // resultMapping
	                    this.EVENT_UIRESULT.UIResult = resultCode;
	                    this.EVENT_UIRESULT.UIDetailedResult = resultDetail;
	                    if(this.resultMapping && this.resultMapping[resultCode] !== void 0) {
	                        resultDetail = `mappedFrom:${resultCode}:`;
	                        resultCode = this.resultMapping[resultCode];
	                        this.EVENT_UIRESULT.UIResult = resultCode;
	                        this.EVENT_UIRESULT.UIDetailedResult = resultDetail;
	                        _logger.LOG_SRVC_DATA &&
	                            _logger.log(_logger.LOG_SRVC_DATA, `. ViewService::endView resultMapping (result detail given) configured! Mapping to '${resultCode}'/'${resultDetail}'`);
	                    }
	                }
	                this.EVENT_UIRESULT.viewID = this.viewContext.viewID;
	                this.fireServiceEvent(this.SERVICE_EVENTS.VIEW_CLOSING, {
	                    viewId: this.viewContext.viewID,
	                    viewKey: this.viewContext.viewKey,
	                    resultCode: resultCode,
	                    resultDetail: resultDetail
	                });
	                this.sendEvent(this.EVENT_UIRESULT);
	            } else {
	                _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, "ViewService::endView no content running.");
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::endView");
	        }

	        /**
	         * Triggers the {@link Wincor.UI.Service.ViewService#SERVICE_EVENTS.VIEW_BEFORE_CHANGE} event.
	         *
	         * This method is intended to be called by the content-base and should not be called directly by a concrete view-model.
	         *
	         * @param {Object} msg The message, which will be sent with the event.
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_BEFORE_CHANGE
	         */
	        fireBeforePageChange(msg) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::fireBeforePageChange(" + JSON.stringify(msg) + ")");
	            this.fireServiceEvent(this.SERVICE_EVENTS.VIEW_BEFORE_CHANGE, msg);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::fireBeforePageChange");
	        }

	        /**
	         * Triggers the {@link Wincor.UI.Service.ViewService#SERVICE_EVENTS.VIEW_ACTIVATED} event.
	         * Additionally the event {@link Wincor.UI.Service.ViewService#EVENT_ACTIVATED} is sent to the business-logic.
	         *
	         * This method is intended to be called by the content-base and should not be called directly by a concrete view-model.
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_ACTIVATED
	         * @fires Wincor.UI.Service.ViewService#EVENT_ACTIVATED
	         */
	        fireActivated() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::fireActivated()");
	            const handled = this.fireServiceEvent(this.SERVICE_EVENTS.VIEW_ACTIVATED, {
	                href: this.getContentWindowDocument(this.CONTENT_FRAME_NAME).location.href,
	                viewContext: jQuery.extend(true, {}, this.viewContext)
	            });
	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, ". | VIEW ViewService::fireActivated returns handled=" + handled);
	            // TODO: how can we assure that "this.EVENT_ACTIVATED" has been received by all subscribers before
	            // a UIResult Timeout is sent due to a minimal timing config for this view?

	            if(!this.restarting && this.contentRunning) {
	                //by requesting contentRunning here, we can not fully avoid that an ACTIVATED event is sent for an old view, but we
	                //can make it less possible.
	                this.EVENT_ACTIVATED.viewID = this.viewContext.viewID;
	                this.sendEvent(this.EVENT_ACTIVATED);
	            } else {
	                // if 'restartin' is true, this is the activated event of index.html
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. | VIEW ViewService::fireActivated skipping event (restarting =${this.restarting}, contentRunning=${this.contentRunning}.`);
	            }

	            if(!handled) {
	                // ada f.e will handle the timeouts by itself
	                this.refreshTimeout();
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::fireActivated");
	        }

	        /**
	         * Automatically called when it comes to popups.
	         * @param {boolean} active  Tells if popup currently is activated or destroyed
	         * @param {String} type     The popup type (std values: "CANCEL_POPUP", "TIMEOUT_POPUP", "HELP_POPUP", "AMOUNT_ENTRY_POPUP", "WAIT_POPUP")
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:POPUP_ACTIVATED
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:POPUP_DEACTIVATED
	         * @fires Wincor.UI.Service.ViewService#EVENT_POPUP
	         */
	        firePopupNotification(active, type) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::firePopupNotification(${type} active: ${active})`);
	            this.popupActive = active;
	            this.fireServiceEvent(active ? this.SERVICE_EVENTS.POPUP_ACTIVATED : this.SERVICE_EVENTS.POPUP_DEACTIVATED, type ? type : void 0);
	            this.EVENT_POPUP.eventData = active ? "ACTIVATED" : "DEACTIVATED";
	            if(type) {
	                this.EVENT_POPUP.eventData += `,${type}`;
	            }
	            this.sendEvent(this.EVENT_POPUP);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::firePopupNotification");
	        }

	        /**
	         * Triggers the {@link Wincor.UI.Service.ViewService#SERVICE_EVENTS.CONTENT_UPDATE} and
	         * {@link Wincor.UI.Service.ViewService#SERVICE_EVENTS.POPUP_DEACTIVATED} events.
	         *
	         * Additionally the event {@link Wincor.UI.Service.ViewService#EVENT_CONTENT_UPDATED} is sent to the business-logic.
	         *
	         * @param {String} data     Arbitrary data string for `eventData`.
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:CONTENT_UPDATE
	         * @fires Wincor.UI.Service.ViewService#EVENT_CONTENT_UPDATED
	         */
	        fireContentUpdated(data) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::fireContentUpdated(${data})`);
	            this.fireServiceEvent(this.SERVICE_EVENTS.CONTENT_UPDATE, data);
	            this.EVENT_CONTENT_UPDATED.eventData = data ? data.toString() : "";
	            this.sendEvent(this.EVENT_CONTENT_UPDATED);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< ViewService::fireContentUpdated`);
	        }

	        /**
	         * Triggers the {@link Wincor.UI.Service.ViewService#SERVICE_EVENTS.VIEW_PREPARED} event.
	         *
	         * Additionally the event {@link Wincor.UI.Service.ViewService#EVENT_PREPARED} is sent to the business-logic.
	         *
	         * This method is intended to be called by the BaseViewModel if all initial data is captured
	         * and the view is ready for data-binding and activation.
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_PREPARED
	         * @fires Wincor.UI.Service.ViewService#EVENT_PREPARED
	         */
	        firePrepared() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::firePrepared()");

	            this.fireServiceEvent(this.SERVICE_EVENTS.VIEW_PREPARED, jQuery.extend(true, {}, this.viewContext));
	            if(!this.restarting) {
	                this.EVENT_PREPARED.viewID = this.viewContext.viewID;
	                this.sendEvent(this.EVENT_PREPARED);
	            } else {
	                // if 'restarting' is true, this is the prepared event of index.html
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, ". | VIEW ViewService::firePrepared skipping event to bl, due to restart");
	            }

	            // If 'restarting' is true, this means that index.html was reloaded (viewset was switched) -- in this case we have to send the activated event,
	            // regardless of 'autoactivate' variable: AutoActivate is set by the new view that shall be displayed or prepared. If prepare() was called
	            // then autoactivate is false, but this autoActive applies to the new view AND NOT (if restarting is true) to index.html
	            if(this.autoActivate || this.restarting) {
	                //this informs the subscribers that they  have to activate themselves
	                window.setTimeout(() => this.fireServiceEvent(this.SERVICE_EVENTS.TURN_ACTIVE), 1);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::firePrepared");
	        }

	        /**
	         * Whenever a view was displayed using display() with a timeout, this event-handler is called when
	         * the timer for this view expires.
	         * The event handler will fire a service-event {@link Wincor.UI.Service.ViewService#SERVICE_EVENTS.VIEW_USERINTERACTION_TIMEOUT}.
	         * If one of the registered functions returns true (which means it already handled this situation) nothing will be done.
	         * Otherwise this handler calls {@link Wincor.UI.Service.ViewService#endView} which will send the
	         * UIResult {@link Wincor.UI.Service.ViewService#UIRESULT_TIMEOUT_USER}.
	         * @async
	         * @eventhandler
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_USERINTERACTION_TIMEOUT
	         */
	        async onTimeout() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::onTimeout()");
	            if(this.serviceProvider.getInstanceName() === "GUIAPP") {
	                try {
	                    await this.serviceProvider.AdaService.switchToApp();
	                } catch(e) {
	                    // pass
	                }
	            }

	            this.interactionTimerId = null;
	            if(!this.fireServiceEvent(this.SERVICE_EVENTS.VIEW_USERINTERACTION_TIMEOUT)) {
	                this.endView(this.UIRESULT_TIMEOUT_USER);
	            } else {
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, ". timeout was handled by one of the subscribers");
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::onTimeout");
	        }

	        /**
	         * To avoid the expiration of the view timer during an user-interaction, this method is used to initialize the timeout to the value provided by the previous display-call.
	         * It can also refresh this timer during an user-interaction.
	         *
	         * Before this happens, the event {@link Wincor.UI.Service.ViewService#SERVICE_EVENTS.VIEW_USERINTERACTION_TIMEOUT} is sent.
	         * Subscribers of the event can handle the timeout situation by themselves (e.g. "Would you like more time?" popup).
	         * The return value of the subscribed callbacks tell this function if the timeout situation was completely handled ('true')
	         * or if this function shall proceed with the standard handling ('false').
	         *
	         * @param {Number=} newHigherTimeoutValue   The new timeout value, which must be higher then the configured one.
	         * @param {boolean=} force                  Enforces also a refresh to a new, but lower timeout value.
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:REFRESH_TIMEOUT
	         */
	        refreshTimeout(newHigherTimeoutValue, force) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::refreshTimeout()");
	            const orgInteractionTimeoutValue = this.interactionTimeoutValue; // for the case there is a foreign timeout handler (-isHandled=true)
	            if(newHigherTimeoutValue && (force || newHigherTimeoutValue > this.interactionTimeoutValue)) {
	                _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. updating timeout from ${this.interactionTimeoutValue}ms to ${newHigherTimeoutValue}ms`);
	                this.interactionTimeoutValue = newHigherTimeoutValue;
	            }
	            const isHandled = this.fireServiceEvent(this.SERVICE_EVENTS.REFRESH_TIMEOUT, this.interactionTimeoutValue);
	            if(!isHandled) {
	                this.clearTimeout();
	                if(this.interactionTimeoutValue === this.immediateTimeout) {
	                    this.interactionTimerId = window.setTimeout(this.onTimeout.bind(this), 1); //1ms so that this method can return
	                } else if(this.interactionTimeoutValue > this.immediateTimeout && this.contentRunning) {
	                    this.interactionTimerId = window.setTimeout(this.onTimeout.bind(this), this.interactionTimeoutValue);
	                }
	            } else {
	                this.interactionTimeoutValue = orgInteractionTimeoutValue; // restore
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, ". ViewService::refreshTimeout not processed - event handled by subscriber: ");
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< ViewService::refreshTimeout - value: ${this.interactionTimeoutValue}`);
	        }

	        /**
	         * Called from the business logic if pce::gui::ResetWatchdog() is called. Calls immediately {@link Wincor.UI.Service.ViewService#refreshTimeout}.
	         *
	         * {@link Wincor.UI.Service.ViewService#refreshTimeout} can not be used as callback for pce::gui::ResetWatchdog(), because every callback get an object
	         * as parameter, but this fits not to the signature of {@link Wincor.UI.Service.ViewService#refreshTimeout}.
	         */
	        resetUserInteractionTimeout() {
	            this.refreshTimeout();
	        }

	        /**
	         * Returns {@link Wincor.UI.Service.ViewService#interactionTimeoutValue}.
	         *
	         * @return {Number}
	         */
	        getTimeoutValue() {
	            return this.interactionTimeoutValue;
	        }

	        /**
	         * Clears the timeout for the current view.
	         */
	        clearTimeout() {
	            let done = false;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::clearTimeout()");
	            if(this.interactionTimerId !== 0) {
	                window.clearTimeout(this.interactionTimerId);
	                done = true;
	                this.interactionTimerId = 0;
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< ViewService::clearTimeout returns done=${done}`);
	        }

	        /**
	         * Sets {@link Wincor.UI.Service.ViewService#viewContext}.
	         *
	         * @param {Object} message       The message object from the business logic, contains at least the view key.
	         * @param {Object} viewKeyValue  The configuration of the viewkey.
	         */
	        setViewContext(message, viewKeyValue) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::setViewContext()");
	            this.viewContext.viewKey = message.viewKey !== "" ? message.viewKey : "*";
	            this.viewContext.viewURL = message.viewURL;
	            // this.viewContext.viewConfig = this.urlMapping[message.viewKey];
	            // TODO: 2016-03-30-workaround: view models expecting attr "placeHolder" instead of "placeholder". Remove this workaround, if tooling metadata corrected to "placeHolder"
	            if(viewKeyValue.config && viewKeyValue.config.placeholder) {
	                viewKeyValue.config.placeHolder = viewKeyValue.config.placeholder;
	            }
	            this.viewContext.viewConfig = viewKeyValue;
	            _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. viewContext: \n ${JSON.stringify(this.viewContext, null, " ")}`);
	            if(!this.viewContext.viewConfig) {
	                _logger.error(`Couldn't get configuration for viewKey=${message.viewKey} <-- seems to be invalid. This may lead into subsequent errors !`);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::setViewContext");
	        }

	        /**
	         * This method can be called by the business logic to activate a prepared view.
	         * The view will become visible and interactive to the customer
	         * if {@link Wincor.UI.Service.ViewService#prepare} was previously called.
	         * @param {Object} message
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:TURN_ACTIVE
	         */
	        activate(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::activate()");
	            this.fireServiceEvent(this.SERVICE_EVENTS.TURN_ACTIVE);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::activate");
	        }

	        /**
	         * Forces SPA navigation using durandal to navigate within SPA.
	         *
	         * It also checks if a SPA restart is necessary due a view set switch. 
	         * If so, it calls {@link Wincor.UI.Service.ViewService#reStartSPA}, otherwise it does a normal navigation.
	         *
	         * @param {string} url      The URL which mus be loaded into the content frame.
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:NAVIGATE_SPA
	         */
	        navigate(url) {
	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `> ViewService::navigate(${url})`);
	    
	            if (!url) {
	                _logger.error(`ViewService::navigate, Navigation canceled due to mandatory 'url' argument is invalid -
                               please check registry section 'UIMapping' for viewkey=${this.viewContext.viewKey}`);
	                return;
	            }
	            if(this.isRestartOnNextDisplay) {
	                this.reStartSPA(url);
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `< ViewService::navigate restart of SPA necessary for destination=${url}`);
	                return;
	            }

	            // determine next SPA URL
	            // manipulate url to short version for durandal
	            //TODO simplify this if the URL mapping uses short fragment names instead of the redundant URL path's
	            const queryStringObj = Wincor.QueryString.get(url);
	            const queryString = Wincor.QueryString.stringify(queryStringObj);
	            let newUrl, routeName, destination;
	            newUrl = Wincor.QueryString.getBaseUrl(url);
	            routeName = newUrl.replace(".html", "").replace(".htm", ""); // only the name of the html file without extension
	            destination = {
	                url: newUrl,
	                routeName: routeName,
	                lastViewUrl: this.previousViewUrl,
	                queryString: queryString,
	                viewKey: this.viewContext.viewKey
	            };
	            this.previousViewUrl = newUrl;
	            window.localStorage.setItem("currentViewId", routeName);
	            this.fireServiceEvent(this.SERVICE_EVENTS.NAVIGATE_SPA, destination);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< ViewService::navigate destination=${JSON.stringify(destination)}`);
	        }

	        /**
	         * Starts the SPA by loading the initially given URL into the `iframe` of the the application content.
	         *
	         * @param {string} url      The url to start with, usually <i>_index.html_</i>.
	         */
	        startSPA(url) {
	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `> ViewService::startSPA url=${url}, viewSetName=${this.viewSetName}`);
	            if(this.CONTENT_FRAME_NAME) {
	                this.loadContentUrl(url, this.CONTENT_FRAME_NAME);
	                jQuery(".spinner").css("display", "none");
	                jQuery("#applicationMode").fadeIn({ duration: 600, easing: "easeInQuart" });
	            } else {
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, ` ViewService::startSPA no content configured...`);
	                this.registerForServiceEvent(
	                    this.SERVICE_EVENTS.TURN_ACTIVE,
	                    () => {
	                        this.fireActivated();
	                    },
	                    this.DISPOSAL_TRIGGER_ONETIME
	                );
	                this.firePrepared();
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::startSPA");
	        }

	        /**
	         * Restarts the SPA, usually during a view set switch.
	         * The method invokes {@link Wincor.UI.Service.ViewService.startSPA} to load the new <i>index.html</i>.
	         *
	         * @param {string} url The URL for SPA navigation after SPA has been restarted
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:SHUTDOWN
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_CLOSING
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_BEFORE_CHANGE
	         */
	        reStartSPA(url) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::reStartSPA(${url})`);
	            this.isRestartOnNextDisplay = false;
	            localStorage.setItem("restartSPA", "true");
	            jQuery("body").attr("data-restart-spa", "true");
	            this.fireServiceEvent(this.SERVICE_EVENTS.SHUTDOWN);
	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, ". | VIEW ViewService::reStartSPA restarting!");
	            this.registerForServiceEvent(
	                this.SERVICE_EVENTS.VIEW_ACTIVATED,
	                () => {
	                    // this is the activated event of index.html
	                    // decouple from service event (do not fire service event from within handler directly!)
	                    setTimeout(() => {
	                        //SPA is restarted, now load the initial url:
	                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. | VIEW ViewService::reStartSPA navigating to ${url}`);
	                        this.fireServiceEvent(this.SERVICE_EVENTS.VIEW_CLOSING, {
	                            viewId: this.viewContext.viewID,
	                            viewKey: this.viewContext.viewKey,
	                            resultCode: this.UIRESULT_CANCEL_SW,
	                            resultDetail: "restartSPA"
	                        });
	                        this.fireBeforePageChange({});
	                        this.restarting = false;
	                        this.navigate(url);
	                        localStorage.setItem("restartSPA", "false");
	                    }, 250);
	                },
	                this.DISPOSAL_TRIGGER_ONETIME
	            );
	            this.restarting = true;
	            jQuery("#applicationMode").fadeOut({
	                duration: 600,
	                easing: "easeOutQuart",
	                complete: () => this.startSPA(this.startURL) //load the new index.html of the new viewset
	            });
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::reStartSPA");
	        }

	        /**
	         * Check if the content frame exists.
	         *
	         * @returns {boolean}   True if the content frame exists.
	         */
	        contentWindowExists() {
	            return jQuery(this.CONTENT_FRAME_NAME).attr("src") !== "";
	        }

	        /**
	         * Handles an error in case of a wrong viewkey configuration.
	         */
	        handleError() {
	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "> ViewService::handleError()");

	            //Do not navigate to an error URL, this breaks the durandal lifecycle and later on every navigation will fail.
	            //The flow will do an error navigation anyway and almost immediately call a new Display().
	            this.endView(this.UIRESULT_ERROR_VIEW, "ERROR_VIEW_UNKNOWN_VIEWKEY");

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::handleError()");
	        }

	        /**
	         * This function is called by {@link Wincor.UI.Service.ViewService#prepare} and
	         * {@link Wincor.UI.Service.ViewService#display}.
	         * It navigates to the given view of the message object.
	         *
	         * If the method is called by {@link Wincor.UI.Service.ViewService#display} the `activate` parameter is true.
	         * This means, that the view is also switched visible and becomes interactive -- this shall be omitted if the view shall only be "prepared".
	         *
	         * @param {Object} message      See {@link Wincor.UI.Service.ViewService#display}.
	         * @param {boolean} activate    True if the view shall be activated, too.
	         */
	        processDisplay(message, activate) {
	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `> ViewService::processDisplay('${JSON.stringify(message)}')`);
	            if(this.contentWindowExists()) {
	                this.endView(this.UIRESULT_CANCEL_SW, this.UI_DETAILED_RESULT.DISPLAY); //send a GUIResult for the currently running view. endView() checks if content is running
	            }
	            // IMPORTANT: JavaScript is singlethreaded, but the main thread can be interrupted as soon as we use the send-methods
	            //            of the Gateway!!
	            //Set contentRunning at the beginning of processDisplay, before ANY method might use one of the send-methods or starts other
	            //asynchronous requests. Do not set contentRunning later: it can happen
	            //that the cancel() method is called, before processDisplay() or it's callback methods are finished.
	            //Then cancel() sends an Result (with SW_CANCEL_ERROR), but afterwards the processDisplay method
	            //would proceed and set contentRunning=true. But then Gui.dll is in state 'Wait', but ViewService.contentRunning is
	            //true.
	            // The next time a processDisplay() is called for a new view, an Result SW_CANCEL for the assumed(!) running
	            // old view is immediately sent by the ViewService. But Gui.dll thinks this is for the new view and goes back to
	            // state 'Wait'. And so on and so on....an endless loop with UIResult=SW_CANCEL for every view.
	            this.contentRunning = true;
	            this.EVENT_UIRESULT.UILastButtonPressedEPPKey = [];
	            this.viewContext.viewID = message.viewID;

	            const self = this;
	            const urlMappingTmp = Object.assign({}, this.urlMapping);
	            const msg = Object.assign(
	                {
	                    viewKey: null,
	                    viewURL: null
	                },
	                message || {}
	            );

	            function processDisplayCallback(value, viewKeyValue) {
	                _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `* ViewService::processDisplay::processDisplayCallback(${value})`);

	                if(value === true) {
	                    // var viewConf = self.urlMapping[msg.viewKey];
	                    msg.viewURL = viewKeyValue.url;
	                    self.interactionTimeoutValue = viewKeyValue.timeout;
	                } else {
	                    //viewURL is in the message, no change necessary
	                    self.interactionTimeoutValue = self.pageTimeout;
	                }

	                self.fireBeforePageChange(msg);
	                self.setViewContext(msg, viewKeyValue);
	                window.localStorage.setItem("currentViewKey", viewKeyValue);
	                const viewConfig = self.viewContext.viewConfig;
	                if(viewConfig) {
	                    self.resultMapping = viewConfig.resultMapping;
	                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `* ViewService::processDisplay::processDisplayCallback resultMapping(${JSON.stringify(self.resultMapping)})`);
	                } else {
	                    _logger.error("View config is invalid - can't set cancel/timeout question config !");
	                }
	                // force a normal SPA navigation
	                self.navigate(msg.viewURL);
	                //window.setTimeout(self.fireBeforePageChange.bind(self, msg), 1); //TODO: pageBeforeChange und after -> onInteractive ...
	            }

	            try {
	                this.autoActivate = activate;

	                if(!msg.viewKey && !msg.viewURL) {
	                    _logger.error("ViewService::processDisplay() has been called without a viewKey and without a viewURL!");
	                    this.handleError();
	                    return;
	                }

	                // viewkey convention check
	                if(!msg.viewKey || msg.viewKey.includes("_")) {
	                    _logger.error(`ViewService::processDisplay() has been called with a viewKey '${msg.viewKey}' which doesn't meet the conventions for viewkeys. Please check for illegal char '_' !`);
	                    this.handleError();
	                    return;
	                }

	                if(msg.viewKey in urlMappingTmp) {
	                    const jsonString = JSON.stringify(urlMappingTmp[msg.viewKey]);
	                    if(jsonString.indexOf(PROP_MARKER) !== -1 && jsonString.indexOf(PROP_END_MARKER) !== -1) {
	                        this.getProperties(urlMappingTmp[msg.viewKey], function getPropertiesCallback(response) {
	                            urlMappingTmp[msg.viewKey] = self.correctJSONObject(response, msg.viewKey);
	                            if(typeof urlMappingTmp[msg.viewKey] === "string") {
	                                _logger.error(`View config is invalid - viewKey value is no json object: ${msg.viewKey}`);
	                                self.handleError();
	                            } else {
	                                processDisplayCallback.bind(self)(true, urlMappingTmp[msg.viewKey]);
	                            }
	                        });
	                    } else if(typeof urlMappingTmp[msg.viewKey] === "string") {
	                        _logger.error(`View config is invalid - viewKey value is no json object: ${msg.viewKey}`);
	                        self.handleError();
	                    } else {
	                        processDisplayCallback.bind(self)(true, urlMappingTmp[msg.viewKey]);
	                    }
	                } else {
	                    _logger.error(`Unknown viewKey '${msg.viewKey}'.`);
	                    self.handleError();
	                }
	            } catch(e) {
	                self.contentRunning = false;
	                _logger.error(e.message);
	            } finally {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::processDisplay");
	            }
	        }

	        /**
	         * This function is called by the business logic to prepare a new view.
	         * The view will become visible and interactive to the customer as soon as
	         * {@link Wincor.UI.Service.ViewService#activate} is called.
	         *
	         * @param {Object} message See {@link Wincor.UI.Service.ViewService#display}.
	         */
	        prepare(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::prepare()");
	            const self = this;
	            let postponeMessageWritten = false;
	            const isLoadingViewSet = function() {
	                if(self.loadingViewSet === true) {
	                    if(!postponeMessageWritten) {
	                        _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "* ViewService::prepare - queuing request! A viewset is currently loading...");
	                        postponeMessageWritten = true;
	                    }
	                    window.setTimeout(isLoadingViewSet, 20);
	                } else {
	                    self.processDisplay(message, false);
	                }
	            };
	            isLoadingViewSet();
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::prepare");
	        }

	        /**
	         * This function is called by the business logic to display a specific view.
	         * The result will be send as event, see {@link Wincor.UI.Service.ViewService#EVENT_UIRESULT}.
	         *
	         * @param {Object} message The message contains must contain the `viewKey` and can contain a `viewURL`.
	         */
	        display(message) {
	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "> ViewService::display()");
	            const self = this;
	            let postponeMessageWritten = false;
	            // clear suspensions, reset flag
	            this.suspendList = [];
	            this.isSuspended = false;

	            const isLoadingViewSet = function() {
	                if(self.loadingViewSet === true) {
	                    if(!postponeMessageWritten) {
	                        _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "* ViewService::display - queuing request! A viewset is currently loading...");
	                        postponeMessageWritten = true;
	                    }
	                    window.setTimeout(isLoadingViewSet, 20);
	                } else {
	                    self.processDisplay(message, true);
	                }
	            };

	            isLoadingViewSet();
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::display");
	        }

	        /**
	         * This function is called by the business-logic to cancel a running view.
	         *
	         * @param {Object=} message      Not used.
	         */
	        cancel(message) {
	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `> ViewService::cancel('${JSON.stringify(message)}')`);
	            // clear suspensions, reset flag
	            this.suspendList = [];
	            this.isSuspended = false;
	            let p = ext.Promises.Promise.resolve();
	            // if a popup is active, we have to close it when it comes to a cancel from outside... Otherwise the popup would be visible until next view.
	            if(this.popupActive) {
	                p = Wincor.UI.Content.ViewModelHelper.hidePopupMessage();
	            }
	            p.then(() => {
	                if(this.contentRunning) {
	                    this.endView(this.UIRESULT_CANCEL_SW, this.UI_DETAILED_RESULT.CANCEL);
	                } else {
	                    this.EVENT_UIRESULT.UIResult = this.UIRESULT_CANCEL_SW_ERROR;
	                    this.EVENT_UIRESULT.UIDetailedResult = "";
	                    this.EVENT_UIRESULT.viewID = this.viewContext.viewID;
	                    this.sendEvent(this.EVENT_UIRESULT);
	                }
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::cancel");
	            });
	        }

	        /**
	         * Updates the ViewService.
	         * The method reloads the configuration, based on message.configuration. Currently only "VIEWKEYS" as value
	         * for message.configuration is supported. Currently an empty string is treated in the same way, but this may change in the future.
	         *
	         * @param {Object} message      `message.configuration` tells the function, which parts of the configuration shall be reloaded.
	         */
	        readConfiguration(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::readConfiguration('${message.configuration}')`);
	            //Do not check for contentRunning:
	            // re-reading the viewkeys must also be possible during an active view, but it will just be available for the next viewkey
	            //The Gui.dll must take care, that readConfiguration() is not called during a viewkey switch.
	            if(message.configuration === "VIEWKEYS" || message.configuration === "") {
	                this.readViewKeys(this.viewSetName)
	                    .then(() => {
	                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. ViewService::readConfiguration succeeded re-reading view keys, message=${JSON.stringify(message)}`);
	                        this.sendResponse(message, this.REQUEST_RESPONSE_OK);
	                    })
	                    .catch(cause => {
	                        _logger.error(`View config is invalid - re-reading the UIMapping failed ${cause}`);
	                        this.sendResponse(message, this.REQUEST_RESPONSE_ERROR);
	                    });
	            } else {
	                _logger.error(`ViewService::readConfiguration, unsupported parameters: ${JSON.stringify(message)}`);
	                this.sendResponse(message, this.REQUEST_RESPONSE_ERROR);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::readConfiguration");
	        }

	        /**
	         * Resizes/repositions the browser window.
	         * @param {Object} posObject        Contains attributes `top`, `left`, `width` and `height` of type number.
	         * @param {function=} callback      The callback function, which is called as soon as there is a response. Gets a number a boolean as argument -- `true` is for success.
	         */
	        resizeWindow(posObject, callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::resizeWindow(${JSON.stringify(posObject)}) baseLocation: ${JSON.stringify(this.baseLocation)}`);
	            const REQUEST = Object.assign({}, this.FRM_RESOLVE_REQUEST);
	            REQUEST.FWName = Wincor.UI.Service.Provider.ConfigService.configuration.instanceName;
	            REQUEST.FWFuncID = 4026; // UI method contMove
	            REQUEST.param1 = posObject.left !== void 0 ? posObject.left + (!posObject.absolute ? this.baseLocation.left : 0) : void 0;
	            REQUEST.meta1 = posObject.left !== void 0 ? ["LONG", 0] : void 0;
	            REQUEST.param2 = posObject.top !== void 0 ? posObject.top + (!posObject.absolute ? this.baseLocation.top : 0) : void 0;
	            REQUEST.meta2 = posObject.top !== void 0 ? ["LONG", 0] : void 0;
	            REQUEST.param3 = posObject.width !== void 0 ? posObject.width : void 0;
	            REQUEST.meta3 = posObject.width !== void 0 ? ["LONG", 0] : void 0;
	            REQUEST.param4 = posObject.height !== void 0 ? posObject.height : void 0;
	            REQUEST.meta4 = posObject.height !== void 0 ? ["LONG", 0] : void 0;
	            REQUEST.paramUL = 0;
	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	            this.FrmResolve(REQUEST, function(message) {
	                const success = message.RC === 0;
	                _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `* ViewService::resizeWindow callback success: ${success}`);
	                if(callback) {
	                    callback(success);
	                }
	            });
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::resizeWindow");
	        }

	        /**
	         * Resets the size and location of the window to its `initialLocation`.
	         * This function is used by the swapping functionality.
	         * @returns {Object}
	         */
	        resetLocation() {
	            this.logger.log(this.logger.LOG_INOUT, `> wn.UI.Service.ViewService::resetLocation()`);
	            this.currentSwapTarget = "";
	            this.baseLocation = Object.assign(this.initialLocation);
	            const ret = this.resizeWindow(Object.assign({ absolute: true }, this.initialLocation));
	            this.logger.log(this.logger.LOG_INOUT, `< wn.UI.Service.ViewService::resetLocation returns ${ret}`);
	            return ret;
	        }

	        /**
	         * Swaps the location and size of this UI-instance with the instance of the targetInstance string.
	         *
	         * @param {string} [targetInstance=""]           The UI-instance name to swap location with.
	         * @returns {Promise} resolving to RC
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:LOCATION_CHANGED
	         */
	        swapLocation(targetInstance = "") {
	            const MIN_SIZE = 25;
	            return ext.Promises.promise((resolve, reject) => {
	                // check if target is at feasible size
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::swapLocation(${targetInstance})`);
	                if(targetInstance === Wincor.UI.Service.Provider.ConfigService.configuration.instanceName) {
	                    reject("ViewService::swapLocation targetInstance mut be different to self...");
	                    return;
	                }
	                ext.Promises.Promise.all([this.getLocation(targetInstance), this.getLocation()])
	                    .then(positions => {
	                        const pos = positions[0];
	                        const ourPos = positions[1];
	                        if(pos.width < MIN_SIZE || pos.height < MIN_SIZE) {
	                            reject(`Target ${this.currentSwapTarget} size is width: ${pos.width}/height :${pos.height}! Minimum is ${MIN_SIZE}!`);
	                            return;
	                        }

	                        // we do not swapping with another than the currently swapped instance,
	                        if(this.currentSwapTarget && targetInstance && targetInstance !== this.currentSwapTarget) {
	                            reject(`Instance is currently swapped with: ${this.currentSwapTarget}! Please swap back first.`);
	                            return;
	                        }

	                        const REQUEST = Object.assign({}, this.FRM_RESOLVE_REQUEST);
	                        REQUEST.FWName = Wincor.UI.Service.Provider.ConfigService.configuration.instanceName;
	                        REQUEST.FWFuncID = 4035; //pce::gui::FUNC_CONTAINER_SWAP_LOCATION
	                        REQUEST.param1 = targetInstance;
	                        REQUEST.meta1 = [this.META_TYPE.CHAR_ANSI, -1];
	                        REQUEST.param2 = "";
	                        REQUEST.meta2 = ["NULL", 0];
	                        REQUEST.param3 = "";
	                        REQUEST.meta3 = ["NULL", 0];
	                        REQUEST.param4 = "";
	                        REQUEST.meta4 = ["NULL", 0];
	                        REQUEST.param5 = "";
	                        REQUEST.meta5 = ["NULL", 0];
	                        REQUEST.paramUL = 0;
	                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. request to send: '${JSON.stringify(REQUEST)}'.`);
	                        this.fireServiceEvent(this.SERVICE_EVENTS.LOCATION_CHANGED, {
	                            source: {
	                                instanceName: this.serviceProvider.getInstanceName(),
	                                location: pos
	                            },
	                            target: {
	                                instanceName: targetInstance,
	                                location: ourPos
	                            }
	                        });
	                        this.FrmResolve(REQUEST, message => {
	                            this.currentSwapTarget = targetInstance;
	                            const success = message.RC === 0;
	                            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `* ViewService::swapLocation callback success: ${success}`);
	                            success ? resolve() : reject();
	                        });
	                        _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::swapLocation");
	                    })
	                    .catch(reason => {
	                        _logger.error(`ViewService::swapLocation failed due to ${reason}`);
	                    });
	            });
	        }

	        /**
	         * This function gets the location and size of this UI-instance.
	         * @param {string=} [targetInstance=""]          The UI-instance name to get location for.
	         * If not given, the position of this instance is retrieved
	         * @returns {Promise}                       resolving to  `{top:x, left:y, width:w, height:h}`
	         */
	        getLocation(targetInstance = "") {
	            return ext.Promises.promise((resolve, reject) => {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::getLocation()`);

	                const REQUEST = Object.assign({}, this.FRM_RESOLVE_REQUEST);
	                REQUEST.FWName = targetInstance || Wincor.UI.Service.Provider.ConfigService.configuration.instanceName;
	                REQUEST.FWFuncID = 4034; //pce::gui::FUNC_CONTAINER_GET_LOCATION
	                REQUEST.param1 = -1;
	                REQUEST.meta1 = [this.META_TYPE.LONG, 0];
	                REQUEST.param2 = -1;
	                REQUEST.meta2 = [this.META_TYPE.LONG, 0];
	                REQUEST.param3 = -1;
	                REQUEST.meta3 = [this.META_TYPE.LONG, 0];
	                REQUEST.param4 = -1;
	                REQUEST.meta4 = [this.META_TYPE.LONG, 0];
	                REQUEST.param5 = -1;
	                REQUEST.meta5 = [this.META_TYPE.NULL, 0];
	                REQUEST.paramUL = 0;
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. request to send: '${JSON.stringify(this.FRM_RESOLVE_REQUEST)}'.`);
	                this.FrmResolve(REQUEST, message => {
	                    const success = message.RC === 0;
	                    _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `* ViewService::getLocation callback returned: ${JSON.stringify(message, null, " ")}`);
	                    success
	                        ? resolve({
	                            top: message.param2,
	                            left: message.param1,
	                            width: message.param3,
	                            height: message.param4
	                        })
	                        : reject(`*Error! ViewService::getLocation callback returned: ${JSON.stringify(message, null, " ")}`);
	                });
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::getLocation");
	            });
	        }

	        /**
	         * Tells the current view to suspend and clears a running timer by calling {@link Wincor.UI.Service.ViewService#clearTimeout}.
	         *
	         * @returns {Number}   In case of success it returns a `suspendId`, otherwise `-1`.
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:SUSPEND
	         */
	        suspend() {
	            this.logger.LOG_SRVC_INOUT && this.logger.log(this.logger.LOG_SRVC_INOUT, `> ViewService::suspend() isSuspended=${this.isSuspended}`);
	            let ret;
	            if(this.contentRunning) {
	                this.suspendId++;
	                this.suspendList.push(this.suspendId);
	                // Event is only sent on first call to suspend! When already suspended we just return suspendId
	                if(!this.isSuspended) {
	                    this.fireServiceEvent(this.SERVICE_EVENTS.SUSPEND);
	                    this.isSuspended = true;
	                    this.clearTimeout();
	                }
	                ret = this.suspendId;
	            } else {
	                ret = -1;
	            }
	            this.logger.LOG_SRVC_INOUT && this.logger.log(this.logger.LOG_SRVC_INOUT, `< ViewService::suspend returns suspendId ${this.suspendId}`);
	            return ret;
	        }

	        /**
	         * Resume the view, which was suspended with {@link Wincor.UI.Service.ViewService#suspend}.
	         *
	         * @returns {Boolean}   True, if the view could be resumed.
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:RESUME
	         */
	        resume(suspendId) {
	            this.logger.LOG_SRVC_INOUT && this.logger.log(this.logger.LOG_SRVC_INOUT, `> ViewService::resume(${suspendId}) of ${JSON.stringify(this.suspendList)}`);
	            const index = this.suspendList.indexOf(suspendId);
	            if(index > -1) {
	                this.suspendList.splice(index, 1);
	            }
	            if(this.suspendList.length === 0) {
	                this.isSuspended = false;
	                this.fireServiceEvent(this.SERVICE_EVENTS.RESUME);
	                this.refreshTimeout();
	            }
	            this.logger.LOG_SRVC_INOUT && this.logger.log(this.logger.LOG_SRVC_INOUT, `< ViewService::resume - remaining:${JSON.stringify(this.suspendList)}`);
	            return !this.isSuspended;
	        }

	        /**
	         * Adds a style or link element given as string to the content's header
	         * @param {string} htmlString The text representation of the element. Either a complete <style>...</style> or <link> string.
	         * @returns {number} An id to be used for removeStyle function
	         */
	        addStyle(htmlString) {
	            STYLE_ID++;
	            this.logger.LOG_SRVC_INOUT && this.logger.log(this.logger.LOG_SRVC_INOUT, `> ViewService::addStyle(${htmlString})`);
	            try {
	                const doc = this.getContentWindowDocument(this.CONTENT_FRAME_NAME);
	                let el = doc.createElement("a");
	                el.innerHTML = htmlString;
	                const nodeNames = ["LINK", "STYLE"];
	                if(nodeNames.includes(el.lastChild.nodeName)) {
	                    el = el.lastChild;
	                    this.addedStyles.set(STYLE_ID, el);
	                    doc.head.appendChild(el);
	                } else {
	                    _logger.error(`ViewService::addStyle - unsupported node <${el.lastChild.nodeName}> !`);
	                }
	            } catch(e) {
	                _logger.error(`ViewService::addStyle ${e.message}\n${e.stack}`);
	            }
	            this.logger.LOG_SRVC_INOUT && this.logger.log(this.logger.LOG_SRVC_INOUT, `< ViewService::addStyle returns id ${STYLE_ID}`);
	            return STYLE_ID;
	        }

	        /**
	         * Removes a style element previously added with ViewService#addStyle.
	         * @param {number} [styleId=null]      The id returned by ViewService#addStyle.
	         * @returns {boolean}           Success flag.
	         */
	        removeStyle(styleId = null) {
	            let success = false;
	            this.logger.LOG_SRVC_INOUT && this.logger.log(this.logger.LOG_SRVC_INOUT, `> ViewService::removeStyle(${styleId})`);
	            const doc = this.getContentWindowDocument(this.CONTENT_FRAME_NAME);
	            if(styleId !== null) {
	                let el;
	                if(this.addedStyles.has(styleId)) {
	                    el = this.addedStyles.get(styleId);
	                    doc.head.removeChild(el);
	                    this.addedStyles.delete(styleId);
	                    success = true;
	                } else {
	                    _logger.error(`ViewService::removeStyle could not find styleId <${styleId}>`);
	                }
	            } else {
	                // remove all if no styleId is given
	                this.addedStyles.forEach(el => {
	                    doc.head.removeChild(el);
	                });
	            }
	            this.logger.LOG_SRVC_INOUT && this.logger.log(this.logger.LOG_SRVC_INOUT, `< ViewService::removeStyle success=${success}`);
	            return success;
	        }

	        /**
	         * This function will execute Gui.ContainerBringToTop() via the ProTopas bus. Need not be supported by Tooling.
	         * @param {function=} callback  Callback will be called in application mode only.
	         */
	        bringToFront(callback) {
	            if(Wincor.UI.Content.applicationMode) {
	                const req = Object.assign({}, Wincor.UI.Gateway.prototype.REQUEST);

	                req.service = "ViewService";
	                req.methodName = "FrmResolve"; // this.METHOD_FRM_RESOLVE
	                req.FWName = Wincor.UI.Service.Provider.ConfigService.configuration.instanceName; //GUIAPP or GUIDM
	                req.FWFuncID = 4027; //FUNC_CONTAINER_BRINGTOTOP
	                req.param1 = "";
	                req.meta1 = ["NULL", 0];
	                req.param2 = "";
	                req.meta2 = ["NULL", 0];
	                req.param3 = "";
	                req.meta3 = ["NULL", 0];
	                req.param4 = "";
	                req.meta4 = ["NULL", 0];
	                req.param5 = "";
	                req.meta5 = ["NULL", 0];
	                req.paramUL = 0;
	                req.RC = -1;

	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* ViewService::bringToTop with ${JSON.stringify(req)}`);

	                this.FrmResolve(req, callback);
	            }
	        }

	        /**
	         * This function can be called to do the correction of the result.
	         *
	         * @param {Object} result The json object for the specified viewKey.
	         * @param {function} processDisplayCallback Callback method.
	         */
	        getProperties(result, processDisplayCallback) {
	            const resStringified = JSON.stringify(result); // something like "{ "url": "../../content/views/pleasewait.html", "timeout": "[&CCTAFW_PROP_TIMEOUT;#C;100000&]", "commandconfig": { "DEPOSIT_CONFIRM": 0, "DEPOSIT_CANCEL": 0 } }"
	            let valueString = resStringified,
	                replaceCount = 0,
	                returnValueString = "";
	            let propertyCount = 0,
	                propertiesToFormatCount = 0;
	            const propArray = [],
	                  keyArray = []; // keyArray contains only the keys for the call to the data service
	            // propArray example:
	            // propArray[0][0] = "CCTAFW_PROP_TIMEOUT" --> the key
	            // propArray[0][1] = "#C"                  --> the formatOption
	            // propArray[0][2] = "100000"              --> the default
	            // propArray[0][3] = "1000"                --> formatted value
	            // propArray[1][0] = "CCTAFW_PROP_AMOUNT"  --> the key
	            // propArray[1][1] = "#C"                  --> the formatOption
	            // propArray[1][2] = "1234"                --> the default
	            // propArray[1][3] = "12.34"               --> formatted value

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::getProperties('${resStringified}')`);

	            // get first index values
	            let index = valueString.indexOf(PROP_MARKER);
	            let endIndex = valueString.indexOf(PROP_END_MARKER);
	            let property;
	            // run through the string and count the properties
	            // add the properties to the keyArray
	            while(index !== -1 && endIndex !== -1) {
	                // extract property
	                property = valueString.substring(index + 2, endIndex); // property = "CCTAFW_PROP_TIMEOUT;#C;100000"

	                // remove first part of the string up to the end of the property
	                valueString = valueString.substr(endIndex + 2);

	                // add property to property array
	                propArray[propertyCount] = property.split(";");

	                // add key from property to key array (for call to data service)
	                keyArray[propertyCount] = propArray[propertyCount][0]; // this may cause double keys adding - we must filter out later for a proper DataService call
	                // count properties which must be formatted
	                if(propArray[propertyCount][1] !== "") {
	                    propertiesToFormatCount++;
	                }

	                // raise property count
	                propertyCount++;

	                // check if another property is in the string
	                index = valueString.indexOf(PROP_MARKER);
	                endIndex = valueString.indexOf(PROP_END_MARKER);
	            }

	            // renew valueString with the result
	            valueString = resStringified;

	            // replace all properties with the values from propArray
	            const replace = function() {
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* ViewService::getProperties::replace()");

	                // get first index values
	                index = valueString.indexOf(PROP_MARKER);
	                endIndex = valueString.indexOf(PROP_END_MARKER);

	                // run again through the string and replace the properties with the values
	                while(index !== -1 && endIndex !== -1) {
	                    // add part before the property to the new string
	                    returnValueString += valueString.substring(0, index);

	                    // replace property with the value
	                    returnValueString += propArray[replaceCount][3];

	                    // raise replaceCount
	                    replaceCount++;

	                    // remove first part of the string up to the end of the property
	                    valueString = valueString.substr(endIndex + 2);

	                    // get index values for the next property
	                    index = valueString.indexOf(PROP_MARKER);
	                    endIndex = valueString.indexOf(PROP_END_MARKER);
	                }
	                // add rest of the string after the last property
	                returnValueString += valueString;

	                // parse new string to a JSON object
	                result = JSON.parse(returnValueString);

	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `< ViewService::getProperties returns: ${JSON.stringify(result)}`);
	                processDisplayCallback(result);
	            };

	            // function for formatting the properties
	            const doFormat = function(i) {
	                // check if property at position i in propArray must be formatted
	                if(propArray[i][1] !== "") {
	                    Wincor.UI.Service.Provider.FormatService.format(propArray[i][3], propArray[i][1], function(formattedValue) {
	                        // set value in propArray
	                        propArray[i][3] = formattedValue.result;
	                        i++;
	                        if(i < propertyCount) {
	                            // recursive call of this method
	                            doFormat(i);
	                        } else {
	                            replace();
	                        }
	                    });
	                } else {
	                    i++;
	                    if(i < propertyCount) {
	                        // recursive call of this method
	                        doFormat(i);
	                    } else {
	                        replace();
	                    }
	                }
	            };

	            // call the getValues method to get the values for the properties
	            // filter out double keys, e.g. "CardlessIdEntry" can cause
	            const uniqueKeyArray = keyArray.filter((item, i, a) => a.indexOf(item) === i);
	            Wincor.UI.Service.Provider.DataService.getValues(
	                uniqueKeyArray,
	                function getValuesCallback(response) {
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* ConfigService::getProperties::getValuesCallback)${JSON.stringify(response)}')`);

	                    // add value to property array
	                    for(let i = 0; i < propertyCount; i++) {
	                        if(response[keyArray[i]] === "") {
	                            // no value for property - use default value
	                            propArray[i][3] = propArray[i][2];
	                        } else {
	                            // add value from result array for the property array
	                            propArray[i][3] = response[keyArray[i]];
	                        }
	                    }

	                    // no values which must be formatted - direct jump to replace
	                    if(propertiesToFormatCount === 0) {
	                        replace();
	                    } else {
	                        // format values
	                        doFormat(0);
	                    }
	                },
	                null
	            );
	        }

	        /**
	         * Returns the configuration of the given template viewkey.
	         *
	         * @param {string} defaultString The default viewkey on which the viewkey is based, e.g. "(#IdInput#)".
	         * @returns {string} The value for the key or `_ERROR_` in case of an error.
	         */
	        mapToViewKey(defaultString) {
	            const index = defaultString.indexOf(VAR_REPLACE_MARKER);
	            const endIndex = defaultString.indexOf(VAR_REPLACE_END_MARKER);

	            if(index === 0 && endIndex !== -1) {
	                const template = defaultString.substring(index + 2, endIndex);
	                return this.getTemplateValue(template);
	            }
	            _logger.error(`ViewService::invalid viewkey value '${defaultString}'!`);
	            return "_ERROR_";
	        }

	        /**
	         * Returns the configuration of the given template viewkey, which is stored in {@link Wincor.UI.Service.ViewService#TEMPLATE_VIEWKEYS}.
	         *
	         * @param {string} template    The template viewkey, e.g. "IdInput".
	         * @returns {string}           The value  or _ERROR_ in case of an error.
	         */
	        getTemplateValue(template) {
	            for(const i of Object.keys(this.TEMPLATE_VIEWKEYS)) {
	                if(typeof i === "string" && i === template) {
	                    return this.TEMPLATE_VIEWKEYS[i];
	                }
	            }

	            _logger.error(`ViewService, no configuration for template viewkey ${template} found!`);
	            return "_ERROR_";
	        }

	        /**
	         * Corrects the given result by calling {@link Wincor.UI.Service.ViewService#correctValue} for any string, which is found in the object at any nesting level.
	         * The purpose is to replace placeholders and change the data types from e.g. string to boolean if we find something like "true".
	         *
	         * @param {string} result    The JSON-notated configuration object for the specified viewKey
	         * @param {string} viewKey   The viewKey.
	         * @param {int=}   recursionCount Optional parameter for tracing. Not to be used by callers!
	         */
	        correctJSONObject(result, viewKey, recursionCount = 0) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::correctJSONObject(${recursionCount}): key ${viewKey}=${JSON.stringify(result)}`);
	            const keys = Object.keys(result);
	            for(let i = 0; i < keys.length; i++) {
	                const key = keys[i];
	                const value = result[key];
	                if(typeof value === "object" && !Array.isArray(value)) {
	                    this.correctJSONObject(value, key, recursionCount + 1);
	                } else if(typeof value === "string") {
	                    result[key] = this.correctValue(value);
	                }
	            }
	            _logger.log(_logger.LOG_ANALYSE, `< ViewService::correctJSONObject(${recursionCount}): changed key ${viewKey}=${JSON.stringify(result)}`);
	            return result;
	        }

	        /**
	         * This function can be called to correct a value.
	         * This means that:
	         * <ul>
	         * <li> placeholders for timeouts or defined keywords get replaced (see {@link Wincor.UI.Service.ViewService#DEFAULT_TIMEOUT_VALUES} and {@link Wincor.UI.Service.ViewService#KEYWORD_MAPPING} ).</li>
	         * <li> numeric entries will change to type "Int"</li>
	         * <li> "true" / "false" will change to type "boolean".</li>
	         * </ul>
	         *
	         * @param {string} inputString  The value which should be corrected.
	         * @return {string}             The string after the replacement.
	         */
	        correctValue(inputString) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::correctValue = ${inputString}`);
	            let value = "";
	            const orgInput = inputString;
	            let keywordFound = false;
	            // get first index values
	            let index = inputString.indexOf(VAR_REPLACE_MARKER);
	            let endIndex = inputString.indexOf(VAR_REPLACE_END_MARKER);
	            let placeholder;
	            // check if string contains placeholder
	            // yes - string with placeholder
	            if(index !== -1 && endIndex !== -1) {
	                // run through the string and replace the placeholder
	                while(index !== -1 && endIndex !== -1) {
	                    keywordFound = false;
	                    // copy part before placeholder
	                    value += inputString.substring(0, index);
	                    // extract placeholder
	                    placeholder = inputString.substring(index + 2, endIndex);
	                    // search placeholder in KEYWORD_MAPPING
	                    const keyWordKeys = Object.keys(this.KEYWORD_MAPPING);
	                    for(const p of keyWordKeys) {
	                        if(typeof p === "string" && p === placeholder) {
	                            placeholder = this.KEYWORD_MAPPING[p];
	                            keywordFound = true;
	                        }
	                    }
	                    // search placeholder in DEFAULT_TIMEOUT_VALUES
	                    const defaultTimeoutValueKeys = Object.keys(this.DEFAULT_TIMEOUT_VALUES);
	                    for(const i of defaultTimeoutValueKeys) {
	                        if(typeof i === "string" && i === placeholder) {
	                            const retVal = this.DEFAULT_TIMEOUT_VALUES[i];
	                            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< ViewService::correctValue returns = '${retVal}'`);
	                            return retVal;
	                        }
	                    }
	                    // add keyword to return string
	                    if(keywordFound) {
	                        value += placeholder;
	                    } else {
	                        _logger.error(`ViewService::correctValue: invalid value: ${orgInput}`);
	                        return orgInput;
	                    }

	                    // remove first part of the input string up to the end of the placeholder
	                    inputString = inputString.substr(endIndex + 2);

	                    // check if another placeholder is in the string
	                    index = inputString.indexOf(VAR_REPLACE_MARKER);
	                    endIndex = inputString.indexOf(VAR_REPLACE_END_MARKER);
	                }

	                // add rest of the string after the last placeholder
	                value += inputString;
	            } else {
	                value = inputString;
	            }

	            // check if defaultString could be parsed to an int
	            // REMARK: If the string only contains numbers, but begins with zero we omit the parsing and let the string as it is,
	            // otherwise we would lose the leading "0" -> (e.g. "017812345555" would be converted to 17812345555)
	    
	            const tmpString = value;

	            if(jQuery.isNumeric(tmpString) && (tmpString.length === 1 || tmpString[0] !== "0")) {
	                value = parseInt(tmpString);
	            }

	            // check if input value is a boolean
	            if(tmpString === "true") {
	                value = true;
	            } else if(tmpString === "false") {
	                value = false;
	            }

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< ViewService::correctValue returns = ${value}`);
	            return value;
	        }

	        /**
	         * Reads the configuration of the timeouts from <i>\\Services\\Timeouts</i> and stores it in {@link Wincor.UI.Service.ViewService#DEFAULT_TIMEOUT_VALUES}.
	         *
	         * @returns {Promise}   Resolving to the same object as {@link Wincor.UI.Service.ViewService#DEFAULT_TIMEOUT_VALUES}.
	         */
	        readTimeouts() {
	            const configService = this.serviceProvider.ConfigService;
	            const rootSection = configService.configuration.instanceName;
	            const timeoutSection = `${rootSection}\\Services\\Timeouts`;
	            return configService.getConfiguration(timeoutSection, null).then(timeoutResults => {
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::readTimeouts(): default timeouts = ${JSON.stringify(timeoutResults)}`);
	                this.DEFAULT_TIMEOUT_VALUES = Object.assign(this.DEFAULT_TIMEOUT_VALUES, timeoutResults);
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::readTimeouts(): this.DEFAULT_TIMEOUT_VALUES = ${JSON.stringify(this.DEFAULT_TIMEOUT_VALUES)}`);
	                // set variables for timeouts
	                this.pageTimeout = timeoutResults.PageTimeout;
	                this.immediateTimeout = timeoutResults.ImmediateTimeout;
	                this.endlessTimeout = timeoutResults.EndlessTimeout;
	                this.messageTimeout = timeoutResults.MessageTimeout;
	                this.confirmationTimeout = timeoutResults.ConfirmationTimeout;
	                this.inputTimeout = timeoutResults.InputTimeout;
	                this.pinentryTimeout = timeoutResults.PinentryTimeout;

	                return timeoutResults;
	            });
	        }

	        /**
	         * Reads the general configuration from <i>\\Services\\UIMapping</i>.
	         * It reads the parameters `onCancelQuestionDefault` and `onTimeoutQuestionDefault` and overwrites the corresponding defaults in {@link Wincor.UI.Service.ViewService#DEFAULT_VIEWKEY_VALUES}.
	         *
	         * @returns {Promise}   Resolving to a configuration object of the section.
	         */
	        readGeneralUIMapping() {
	            const configService = this.serviceProvider.ConfigService;
	            const rootSection = configService.configuration.instanceName;
	            const uiMappingSection = `${rootSection}\\Services\\UIMapping`;
	            return configService.getConfiguration(uiMappingSection, null).then(uiMappingResults => {
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::readGeneralUIMapping(): uiMappingResults = ${JSON.stringify(uiMappingResults)}`);

	                if(uiMappingResults.onCancelQuestionDefault === true || uiMappingResults.onCancelQuestionDefault === false) {
	                    this.DEFAULT_VIEWKEY_VALUES.popup.oncancel = uiMappingResults.onCancelQuestionDefault;
	                }
	                if(uiMappingResults.onTimeoutQuestionDefault === true || uiMappingResults.onTimeoutQuestionDefault === false) {
	                    this.DEFAULT_VIEWKEY_VALUES.popup.ontimeout = uiMappingResults.onTimeoutQuestionDefault;
	                }
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::readGeneralUIMapping(): DEFAULT_VIEWKEY_VALUES = ${JSON.stringify(this.DEFAULT_VIEWKEY_VALUES)}`);

	                return uiMappingResults;
	            });
	        }

	        /**
	         * Reads the keyword configuration from <i>\\Services\\UIMapping\\KeywordMapping</i> and stores it in {@link Wincor.UI.Service.ViewService#KEYWORD_MAPPING}.
	         *
	         * @returns {Promise}   Resolving to a configuration object of the section.
	         */
	        readKeywordMapping() {
	            const configService = this.serviceProvider.ConfigService;
	            const rootSection = configService.configuration.instanceName;
	            const keywordsSection = `${rootSection}\\Services\\UIMapping\\KeywordMapping`;

	            return configService.getConfiguration(keywordsSection, null).then(keywordResults => {
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::readKeywordMapping(): keywords = ${JSON.stringify(keywordResults)}`);

	                this.KEYWORD_MAPPING = keywordResults;

	                return keywordResults;
	            });
	        }

	        /**
	         * Reads the keyword configuration from <i>\\ProInstall\\Wosassp</i> and stores it in {@link Wincor.UI.Service.ViewService#softkeyPositionsY}.
	         *
	         * @returns {Promise}   Resolving to a reference to {@link Wincor.UI.Service.ViewService#softkeyPositionsY}.
	         */
	        readSoftkeyPositions() {
	            const configService = this.serviceProvider.ConfigService;

	            return configService.getConfiguration("\\ProInstall\\Wosassp", "FuncKeysPos").then(rootResults => {
	                // We expect something like: 0,34:0,49:0,63:0,78:100,34:100,49:100,63:100,78
	                const value = rootResults.FuncKeysPos;
	                if(value) {
	                    const split = value.split(":");
	                    // we only need the first 4 values, because we assume that the y positions are equal on both sides
	                    for(let i = 0; i < 4; i++) {
	                        const tmp = split[i];
	                        this.softkeyPositionsY.push(parseInt(tmp.substr(tmp.lastIndexOf(",") + 1, tmp.length - 1))); // isolate the Y pos value
	                    }
	                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): softkeyPositionsY=${this.softkeyPositionsY}`);
	                }
	                return this.softkeyPositionsY;
	            });
	        }

	        /**
	         * Reads the viewkey template configuration from either <i>\\Services\\UIMapping\\${viewSetName}\\Defaults</i> (Tooling 1.x) or
	         * from <i>\\Services\\UIMapping\\${viewSetName}\\Templates</i> (Tooling 2.0) and stores it in
	         * {@link Wincor.UI.Service.ViewService#TEMPLATE_VIEWKEYS}.
	         *
	         * @returns {Promise}   Resolving to a configuration object of the section.
	         */
	        readViewKeyTemplates(viewSetName) {
	            const configService = this.serviceProvider.ConfigService;
	            const rootSection = configService.configuration.instanceName;
	            const defaultKeySection = `${rootSection}\\Services\\UIMapping\\${viewSetName}\\Defaults`;
	            const templateKeySectionTooling20 = `${rootSection}\\Services\\UIMapping\\${viewSetName}\\Templates`;

	            return configService.getConfiguration(defaultKeySection, null).then(defaultResults => {
	                if(Object.keys(defaultResults).length > 0 && defaultResults[""] === undefined) {
	                    //if there's anything inside? In ApplicationMode we get {"":""} if there's nothing in the secion
	                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::readViewKeyTemplates(${viewSetName}) from ${defaultKeySection}: ${JSON.stringify(defaultResults)}`);

	                    this.TEMPLATE_VIEWKEYS = Object.assign(this.TEMPLATE_VIEWKEYS, defaultResults);

	                    return defaultResults;
	                }
	                return configService.getConfiguration(templateKeySectionTooling20, null).then(defaultResults => {
	                    _logger.LOG_ANALYSE &&
	                        _logger.log(_logger.LOG_ANALYSE, `* ViewService::readViewKeyTemplates(${viewSetName}) from ${templateKeySectionTooling20}: ${JSON.stringify(defaultResults)}`);

	                    this.TEMPLATE_VIEWKEYS = Object.assign(this.TEMPLATE_VIEWKEYS, defaultResults);

	                    return defaultResults;
	                });
	            });
	        }

	        /**
	         * Writes a journal message, which contains the 'userAgent'.
	         *
	         * Reads the configuration from the registry section <i>\\Services\\General</i>.
	         * Registers an "ADA state change handler" function if an 'adaViewSet' is configured.
	         *
	         * Reads the properties `PROP_UI_VIEWSET_KEY` and `PROP_UI_STYLE_TYPE_KEY`.
	         *
	         * Prepares the swapping functionality of <i>GUIAPP</i> and <i>GUIDM</i>.
	         *
	         * Reads all the other configuration parameters, like timeouts, viewkey configuration.
	         *
	         * If all other services are ready, it calls {@link Wincor.UI.Service.ViewService#startSPA} to load the initial URL.
	         *
	         * @returns {Promise}
	         * @lifecycle service
	         * @fires Wincor.UI.Service.ViewService#SERVICE_EVENTS:STYLE_TYPE_CHANGED
	         */
	        onServicesReady() {
	            const self = this;
	            const configService = this.serviceProvider.ConfigService;
	            const journalService = this.serviceProvider.JournalService;

	            journalService.whenReady.then(() => journalService.write(journalService.MSG_NUMBERS.MSG_BROWSER_VERSION, null, window.navigator.userAgent));

	            let hasAdaStarted = false; // flag (closured by -adaStateChangeHandler) to prevent from loadingViewSet only because CCTAFW_PROP_ADA_STATUS_VALUE has been stopped without started.
	            return ext.Promises.promise((resolve, reject) => {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::onServicesReady()");
	                // data/localize
	                configService
	                    .getConfiguration(`${configService.configuration.instanceName}\\Services\\General`, ["InitialViewSet", "AdaViewSet", "CacheHTML", "BeepOnTimeoutPopup", "BeepOnTimeoutPopupPeriod"])
	                    .then(genResult => {
	                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): genResult = ${JSON.stringify(genResult, null, " ")}`);
	                        // if not configured we set it to "" also to be compatible

	                        // WARNING: bool.toLowerCase() hangs up JS !!! no exception! no error log!
	                        //self.DEFAULT_VIEWKEY_VALUES.popup.beepontimeout = genResult["BeepOnTimeoutPopup"].toLowerCase() === "true";
	                        self.DEFAULT_VIEWKEY_VALUES.popup.beepontimeout = !!genResult["BeepOnTimeoutPopup"];
	                        if(genResult["BeepOnTimeoutPopupPeriod"] !== "") {
	                            self.DEFAULT_VIEWKEY_VALUES.popup.beepontimeoutperiod = genResult["BeepOnTimeoutPopupPeriod"];
	                        }
	                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): beepontimeoutperiod=${self.DEFAULT_VIEWKEY_VALUES.popup.beepontimeoutperiod}`);

	                        self.viewSetName = genResult["InitialViewSet"];
	                        self.initialViewSet = self.viewSetName;
	                        self.adaViewSet = genResult["AdaViewSet"];
	                        // normalize/check boolean config
	                        self.cacheHTML = !!genResult["CacheHTML"];
	                        _logger.LOG_ANALYSE &&
	                            _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): CacheHTML=${self.cacheHTML}, InitialViewSet=${self.viewSetName}, AdaViewSet=${self.adaViewSet}`);

	                        // register for ada events to auto switch viewset only if configured
	                        if(self.adaViewSet) {
	                            const adaService = Wincor.UI.Service.Provider.AdaService;
	                            // Please note that this state handler will often be triggered because the business app often changes the value CCTAFW_PROP_ADA_STATUS_VALUE property.
	                            // That's why we control the updates with an own flag called -hasAdaStarted
	                            const adaStateChangedHandler = eventData => {
	                                _logger.LOG_ANALYSE &&
	                                    _logger.log(
	                                        _logger.LOG_ANALYSE,
	                                        `* ViewService::onServicesReady::adaStateChangedHandler eventData=${eventData}, current ViewSet=${self.viewSetName}, ada ViewSet=${self.adaViewSet}`
	                                    );
	                                if(eventData === "FIRSTSTARTANDACTIVATE" || eventData === "FIRSTSTART") {
	                                    hasAdaStarted = true; // ADA has been really started now
	                                    // switch to ada view set on next view if not already active
	                                    if(self.viewSetName.toLowerCase() !== self.adaViewSet.toLowerCase()) {
	                                        _logger.LOG_ANALYSE &&
	                                            _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady::adaStateChangedHandler  - loading viewset for ada -> ${self.adaViewSet}`);
	                                        self.loadViewSet(self.adaViewSet)
	                                            .then(() =>
	                                                // send acknowledge with first start
	                                                adaService.externalAdaCommandAck(eventData)
	                                            )
	                                            .catch(cause => {
	                                                hasAdaStarted = false;
	                                                _logger.error(`* ViewService::onServicesReady::adaStateChangedHandler error loading new view set due to ADA first start event ${cause}`);
	                                                adaService.externalAdaCommandAck(eventData); // send acknowledge with first start anyway
	                                            });
	                                    } else {
	                                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "* ViewService::onServicesReady::adaStateChangedHandler viewset for ada already active");
	                                        adaService.externalAdaCommandAck(eventData); // send acknowledge with first start anyway
	                                    }
	                                } else if(hasAdaStarted && eventData === "LASTSTOP") {
	                                    // ADA has been started before?
	                                    hasAdaStarted = false;
	                                    if(self.viewSetName.toLowerCase() !== self.initialViewSet.toLowerCase()) {
	                                        _logger.LOG_ANALYSE &&
	                                            _logger.log(
	                                                _logger.LOG_ANALYSE,
	                                                `* ViewService::onServicesReady::adaStateChangedHandler - ADA stop event, loading initial viewset -> ${self.initialViewSet}`
	                                            );
	                                        self.loadViewSet(self.initialViewSet)
	                                            .then(() =>
	                                                // send acknowledge with last stop
	                                                adaService.externalAdaCommandAck(eventData)
	                                            )
	                                            .catch(cause => {
	                                                _logger.error(`* ViewService::onServicesReady::adaStateChangedHandler error loading initial view set due to ADA last stop event ${cause}`);
	                                                adaService.externalAdaCommandAck(eventData); // send acknowledge with last stop anyway
	                                            });
	                                    } else {
	                                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "* ViewService::onServicesReady::adaStateChangedHandler viewset for ending ada already active");
	                                        adaService.externalAdaCommandAck(eventData); // send acknowledge with last stop anyway
	                                    }
	                                }
	                            };
	                            self.registerForServiceEvent(adaService.SERVICE_EVENTS.FIRST_START, adaStateChangedHandler, true);
	                            self.registerForServiceEvent(adaService.SERVICE_EVENTS.LAST_STOP, adaStateChangedHandler, true);
	                        } else {
	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "* ViewService::onServicesReady(): no valid AdaViewSet configured... disabling automatic switching");
	                        }
	                        return ext.Promises.promise(resolve => {
	                            const PROP_UI_VIEWSET_KEY = "PROP_UI_VIEWSET_KEY";
	                            // read property and read text key for view-set switching
	                            const checkViewSetTextEntry = result => {
	                                const viewSetKey = result[PROP_UI_VIEWSET_KEY];
	                                _logger.LOG_INOUT && _logger.log(_logger.LOG_INOUT, `> ViewService::onServicesReady:checkViewSetTextEntry viewSetKey=${viewSetKey}`);
	                                if(viewSetKey && viewSetKey !== '""') {
	                                    // got a text key?
	                                    self.serviceProvider.LocalizeService.getText([viewSetKey], result => {
	                                        const viewSetName = result[viewSetKey];
	                                        _logger.LOG_ANALYSE &&
	                                            _logger.log(
	                                                _logger.LOG_ANALYSE,
	                                                `* ViewService::onServicesReady:checkViewSetTextEntry demanded view set name=${viewSetName}, current view set name=${self.viewSetName}`
	                                            );
	                                        if(viewSetName !== null && viewSetName !== self.viewSetName) {
	                                            // only if the demanded viewset is not already the current
	                                            _logger.LOG_INOUT && _logger.log(_logger.LOG_INOUT, "< ViewService::onServicesReady:checkViewSetTextEntry");
	                                            return self.loadViewSet(viewSetName);
	                                        }
	                                    });
	                                } else if(self.viewSetName !== self.initialViewSet) {
	                                    _logger.LOG_INOUT && _logger.log(_logger.LOG_INOUT, `< ViewService::onServicesReady:checkViewSetTextEntry load initial view set=${self.initialViewSet}`);
	                                    return self.loadViewSet(self.initialViewSet);
	                                }
	                                _logger.LOG_INOUT && _logger.log(_logger.LOG_INOUT, "< ViewService::onServicesReady:checkViewSetTextEntry did nothing");
	                                return ext.Promises.Promise.resolve();
	                            };

	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "* ViewService::onServicesReady getting viewSetKey");
	                            Wincor.UI.Service.Provider.DataService.getValues(
	                                [PROP_UI_VIEWSET_KEY],
	                                // callback
	                                result => {
	                                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "* ViewService::onServicesReady getting viewSetKey callback");
	                                    checkViewSetTextEntry(result).then(resolve);
	                                },
	                                // changed callback
	                                result => {
	                                    _logger.LOG_ANALYSE &&
	                                        _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady restarting=${self.restarting} viewSetKey changed to ${JSON.stringify(result)}`);
	                                    if(!self.restarting) {
	                                        checkViewSetTextEntry(result).then(resolve);
	                                    } else {
	                                        resolve();
	                                    }
	                                },
	                                true
	                            );
	                        });
	                    })
	                    .then(() => {
	                        return configService.getConfiguration(configService.configuration.instanceName, null).then(mainConfig => {
	                            self.initialLocation = {
	                                top: mainConfig["ContainerWindowPosY"],
	                                left: mainConfig["ContainerWindowPosX"],
	                                width: mainConfig["ContainerWindowSizeX"],
	                                height: mainConfig["ContainerWindowSizeY"]
	                            };

	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady() initialLocation:\n${JSON.stringify(self.initialLocation, null, " ")}`);
	                            self.baseLocation = Object.assign(self.initialLocation);

	                            // GUIVIDEO location is controlled by GUIAPP's VideoService, do not let GUIVIDEO's ViewService instance react on LOCATION_CHANGED by it self!
	                            if(self.serviceProvider.getInstanceName() !== "GUIVIDEO") {
	                                const eventSvc = self.serviceProvider.EventService;
	                                eventSvc.whenReady.then(() => {
	                                    const TXN_EVENTS = eventSvc.getEventInfo("TRANSACTION_MODULE");
	                                    eventSvc.registerForEvent(
	                                        TXN_EVENTS.ID_SESSION_END,
	                                        TXN_EVENTS.NAME,
	                                        () => {
	                                            _logger.LOG_ANALYSE &&
	                                                _logger.log(
	                                                    _logger.LOG_ANALYSE,
	                                                    `* ViewService::onServicesReady() received ID_SESSION_END initialLocation:\n
                                                    ${JSON.stringify(self.initialLocation, null, " ")}\n
                                                    baseLocation:\n
                                                    ${JSON.stringify(self.baseLocation, null, " ")}`
	                                                );
	                                            // only reset if baselocation top/left differs from initialLocation
	                                            if(self.baseLocation.top !== self.initialLocation.top || self.baseLocation.left !== self.initialLocation.left) {
	                                                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady() basLoc!=initialLoc (top/left) - resetLocation`);
	                                                window.setTimeout(self.resetLocation.bind(self), 1);
	                                            } else {
	                                                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady() basLoc==initialLoc (top/left) -  No resetLocation required`);
	                                            }
	                                        },
	                                        void 0,
	                                        "ASCII",
	                                        true
	                                    );
	                                });
	                            } else {
	                                _logger.LOG_ANALYSE &&
	                                    _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady() GUIVIDEO instance is controlled by GUIAPP -  No automatic resetLocation required`);
	                            }
	                        });
	                    })
	                    .then(() => {
	                        return self.readTimeouts();
	                    })
	                    .then(() => {
	                        return self.readGeneralUIMapping();
	                    })
	                    .then(() => {
	                        return self.readKeywordMapping();
	                    })
	                    .then(() => {
	                        return self.readSoftkeyPositions();
	                    })
	                    .then(() => {
	                        return self.readViewKeyTemplates(self.viewSetName);
	                    })
	                    .then(() => {
	                        return self.readViewKeys(self.viewSetName);
	                    })
	                    .then(() => {
	                        const ourInstance = self.serviceProvider.getInstanceName();
	                        // swapping currently restricted between APP/DM
	                        if(["GUIAPP", "GUIDM"].includes(ourInstance)) {
	                            const otherInstance = ourInstance === "GUIAPP" ? "GUIDM" : "GUIAPP";
	                            // register for GUI state change and resolve a promise when going into a state != "INIT"
	                            const guiStatePromise = ext.Promises.promise((resolve, reject) => {
	                                const eventService = self.serviceProvider.EventService;
	                                eventService.whenReady.then(async () => {
	                                    try {
	                                        const otherInstanceInstalled = await self.serviceProvider.ViewService.hasRemoteInstance(otherInstance);
	                                        _logger.LOG_ANALYSE &&
	                                            _logger.log(
	                                                _logger.LOG_ANALYSE,
	                                                `* ViewService::onServicesReady(): ${otherInstance} install state: ${otherInstanceInstalled} (for making first cross-call from ${ourInstance} to ${otherInstance})`
	                                            );
	                                        if(otherInstanceInstalled) {
	                                            const GUI_EVENT_INFO = eventService.getEventInfo(`${otherInstance}_MODULE`);
	                                            _logger.LOG_INFO && _logger.log(_logger.LOG_INFO, `* ViewService::onServicesReady(): ${ourInstance} now register ${JSON.stringify(GUI_EVENT_INFO)}`);
	                                            const regId = eventService.registerForEvent(
	                                                GUI_EVENT_INFO.ID_STATUS_CHANGED,
	                                                GUI_EVENT_INFO.NAME,
	                                                statusChangedHexDataString => {
	                                                    // first 8 bytes are type long status... slice data, split character pairs, reverse (because of gui.dll byte-order) and parseInt
	                                                    const statusValue = parseInt(
	                                                        statusChangedHexDataString
	                                                            .slice(0, 8)
	                                                            .match(/.{1,2}/g)
	                                                            .reverse()
	                                                            .join(""),
	                                                        16
	                                                    );
	                                                    _logger.LOG_DETAIL &&
	                                                        _logger.log(
	                                                            _logger.LOG_DETAIL,
	                                                            `* ViewService::onServicesReady(): ${otherInstance} status changed to: ${Object.keys(GUI_STATUS).find(
                                                                key => GUI_STATUS[key] === statusValue
                                                            )}`
	                                                        );
	                                                    if(statusValue !== GUI_STATUS.INIT && statusValue !== GUI_STATUS.UN_INIT && statusValue !== GUI_STATUS.ERROR) {
	                                                        eventService.deregisterEvent(regId);
	                                                        _logger.LOG_ANALYSE &&
	                                                            _logger.log(
	                                                                _logger.LOG_ANALYSE,
	                                                                `* ViewService::onServicesReady(): ${otherInstance} status is in ${statusValue}, resolve promise for making first cross-call from ${ourInstance} to ${otherInstance}`
	                                                            );
	                                                        resolve();
	                                                    }
	                                                },
	                                                null,
	                                                "HEX",
	                                                true
	                                            );
	                                        } else {
	                                            resolve();
	                                        }
	                                    } catch(e) {
	                                        _logger.LOG_INFO && _logger.log(_logger.LOG_INFO, `* ViewService::onServicesReady() error getting remote instance or GUI ID_STATUS_CHANGED handling: ${e}`);
	                                        reject(`ViewService::onServicesReady() error getting remote instance or GUI ID_STATUS_CHANGED handling: ${e}`);
	                                    }
	                                });
	                            });
	                            // wait for the correct (WAIT) state of GUI impl and for own readiness
	                            ext.Promises.Promise.all([self.whenReady, guiStatePromise]).then(() => {
	                                // register for a swap location change
	                                self.serviceProvider.ViewService.getRemoteInstance(otherInstance)
	                                    .then(otherViewService => {
	                                        // register both, ourself and remote... both could be initiator of swapLocation
	                                        const assignNewBase = locationData => {
	                                            _logger.LOG_ANALYSE &&
	                                                _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): received LOCATION_CHANGED:\n${JSON.stringify(locationData, null, " ")}`);
	                                            // new positions arrived... check if we are sender or target
	                                            self.baseLocation = Object.assign(locationData.source.instanceName === ourInstance ? locationData.source.location : locationData.target.location);
	                                            _logger.LOG_ANALYSE &&
	                                                _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): new baseLocation:\n${JSON.stringify(self.baseLocation, null, " ")}`);
	                                        };
	                                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): now registering for LOCATION_CHANGED events`);
	                                        self.registerForServiceEvent(self.SERVICE_EVENTS.LOCATION_CHANGED, assignNewBase, true);
	                                        otherViewService.registerForServiceEvent(otherViewService.SERVICE_EVENTS.LOCATION_CHANGED, assignNewBase, true);
	                                    })
	                                    .catch(reason => {
	                                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): getRemoteInstance(${otherInstance}) rejected with: ${reason}`);
	                                        // recover here... not throwing
	                                    });
	                            });
	                        } else {
	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): getRemoteInstance for ${ourInstance} skipped`);
	                        }
	                    })
	                    .then(() => {
	                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): proceed`);
	                        // viewkeys are read, open window and resolve onServicesReady call when window sends ACTIVATED... that's it
	                        self.registerForServiceEvent(
	                            self.SERVICE_EVENTS.VIEW_ACTIVATED,
	                            () => {
	                                super.onServicesReady().then(resolve);
	                            },
	                            self.DISPOSAL_TRIGGER_ONETIME
	                        );
	                        // This is the initial SPA start up. Further start ups might be possible during view set switch.
	                        // When all other services we depend on are ready, we start SPA.
	                        const svcNames = [];
	                        const serviceDependenciesReady = self.serviceProvider.serviceNames
	                            .filter(svcName => {
	                                // Attention: Waiting for other services without resolving 'onServicesReady' promise may result in a deadlock if two services wait for each other.
	                                // We exclude VideoService and our own name for this reason
	                                const isServiceToWaitFor = ![self.NAME, "VideoService"].includes(svcName);
	                                if(isServiceToWaitFor) {
	                                    svcNames.push(svcName);
	                                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): waiting for ${svcName}`);
	                                }
	                                return isServiceToWaitFor;
	                            })
	                            .map(svcName => {
	                                const p = self.serviceProvider[svcName].whenReady;
	                                if(p) {
	                                    p.then(() => {
	                                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): waiting for ${svcName} finished`);
	                                    });
	                                }
	                                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): pushing ${p} for ${svcName}`);
	                                return p;
	                            });
	                        ext.Promises.Promise.all(serviceDependenciesReady)
	                            .timeout(20000) // security timeout... If there is a deadlock somewhere it will nevertheless be safe to launch now
	                            .catch(reason => {
	                                // if it is timeout only, recover and pass
	                                if(!(reason && reason.name === "TimeoutError")) {
	                                    throw reason;
	                                }
	                                _logger.error(`WARNING: ViewService::onServicesReady():\nTimeout waiting for depending services! - Please check syncing of services: \n${svcNames.join("\n")}`);
	                            })
	                            .then(() => {
	                                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): all services ready - starting content`);
	                                self.startSPA(self.startURL);
	                            })
	                            .then(() => {
	                                // If GUIDM is running in fullscreen due to customer interaction, it will "suspend" us to avoid timeouts of underlying guiapp view
	                                // To avoid being stuck in case GUIDM crashes during our suspension, we register for GUIDM STATUS_CHANGED to ERROR event.
	                                // If we receive such an event and are suspended currently, we will automatically resume to stay interactive.
	                                // no need to sync... if services are ready, we install the GUIDM event handler
	                                const ourInstance = self.serviceProvider.getInstanceName();
	                                // register for DM (currently) going down to be able to resume all suspensions in this case
	                                if(ourInstance === "GUIAPP") {
	                                    self.serviceProvider.EventService.whenReady.then(async () => {
	                                        try {
	                                            const dmInstalled = await self.serviceProvider.ViewService.hasRemoteInstance("GUIDM");
	                                            _logger.LOG_ANALYSE &&
	                                                _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): GUIDM install state: ${dmInstalled} (for resuming ${ourInstance} if suspended)`);
	                                            if(dmInstalled) {
	                                                const GUIDM_EVENT = self.serviceProvider.EventService.getEventInfo("GUIDM_MODULE");
	                                                self.serviceProvider.EventService.registerForEvent(
	                                                    GUIDM_EVENT.ID_STATUS_CHANGED,
	                                                    GUIDM_EVENT.NAME,
	                                                    statusChangedHexDataString => {
	                                                        // first 8 bytes are type long status... slice data, split character pairs, reverse (because of gui.dll byte-order) and parseInt
	                                                        const statusValue = parseInt(
	                                                            statusChangedHexDataString
	                                                                .slice(0, 8)
	                                                                .match(/.{1,2}/g)
	                                                                .reverse()
	                                                                .join(""),
	                                                            16
	                                                        );
	                                                        _logger.LOG_DETAIL &&
	                                                            _logger.log(
	                                                                _logger.LOG_DETAIL,
	                                                                `* ViewService::onServicesReady(): GUIDM status changed to:
                                                                ${Object.keys(GUI_STATUS).find(key => GUI_STATUS[key] === statusValue)} (resume ${ourInstance} on suspend)`
	                                                            );
	                                                        if(statusValue === GUI_STATUS.ERROR && self.isSuspended) {
	                                                            self.suspendList = [];
	                                                            self.resume(-1);
	                                                        }
	                                                    },
	                                                    null,
	                                                    "HEX",
	                                                    true
	                                                );
	                                            }
	                                        } catch(e) {
	                                            _logger.LOG_INFO && _logger.log(_logger.LOG_INFO, `* ViewService::onServicesReady(): ${e}`);
	                                        }
	                                    });
	                                }
	                            });
	                    })
	                    .catch(exc => {
	                        self.serviceProvider.propagateError(self.NAME, "CONFIGURATION", exc);
	                        super.onServicesReady().then(reject("ViewService::onServicesReady failed because of a rejected promise in the chain"));
	                    });

	                // BEGIN retrieving style type stuff -->
	                const PROP_UI_STYLE_TYPE_KEY = "PROP_UI_STYLE_TYPE_KEY";
	                let reg = -1;

	                // PROP_UI_STYLE_TYPE_KEY callback on initial/update
	                function changeStyleType(result) {
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::onServicesReady::changeStyleType result=${JSON.stringify(result)}`);
	                    const styleTextKey = result[PROP_UI_STYLE_TYPE_KEY];
	                    if(styleTextKey !== null && styleTextKey !== void 0) {
	                        // Remark: Even if the styleTextKey is empty force a getText call, in such a case the result will be empty but the
	                        // StyleResourceResolver will handle this case.
	                        Wincor.UI.Service.Provider.LocalizeService.getText(
	                            [styleTextKey],
	                            result => {
	                                let value = result[styleTextKey];
	                                // map value to the right default, if empty or undefined
	                                value = value === "" || value === void 0 || value === null || value === "\\" || value === '""' ? "" : value;
	                                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady::changeStyleType type='${value}'`);
	                                self.currentStyleTypeByStylesheetKey = value;
	                                if(!self.isRestartOnNextDisplay) {
	                                    self.fireServiceEvent(self.SERVICE_EVENTS.STYLE_TYPE_CHANGED, value);
	                                } else {
	                                    // viewset will change on next display - postpone event until new viewset is loaded
	                                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "* ViewService::onServicesReady::changeStyleType postponing fire STYLE_TYPE_CHANGED.");
	                                    if(reg !== -1) {
	                                        self.deregisterFromServiceEvent(reg);
	                                    }
	                                    reg = self.registerForServiceEvent(
	                                        self.SERVICE_EVENTS.VIEW_ACTIVATED,
	                                        eventData => {
	                                            const href = typeof eventData === "string" ? eventData : eventData.href;
	                                            if(href && href.endsWith("index.html")) {
	                                                // check for welcome and then fire style event
	                                                _logger.LOG_ANALYSE &&
	                                                    _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady::changeStyleType viewset ${self.viewSetName} loaded (welcome).`);
	                                                // decouple
	                                                setTimeout(() => {
	                                                    self.fireServiceEvent(self.SERVICE_EVENTS.STYLE_TYPE_CHANGED, value);
	                                                    self.deregisterFromServiceEvent(reg);
	                                                    reg = -1;
	                                                }, 1);
	                                            }
	                                        },
	                                        true
	                                    );
	                                }
	                            },
	                            false
	                        ); // no auto update on language changed
	                    } else {
	                        // PROP_UI_STYLE_TYPE_KEY not existent
	                        _logger.error(`The property=${PROP_UI_STYLE_TYPE_KEY} doesn't exist which is unexpected!`);
	                    }
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::onServicesReady::changeStyleType");
	                }

	                //TODO Could the next getValues and calling of changeStyleType be dangerous, because the above code works in parallel? Maybe the getValues should be part of the above sequence.
	                Wincor.UI.Service.Provider.DataService.getValues([PROP_UI_STYLE_TYPE_KEY], changeStyleType, changeStyleType, true);
	                //<-- END retrieving stylesheet folder stuff
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::onServicesReady");
	            });
	        }

	        /**
	         * Reads the viewkey configuration from <i>\\Services\\UIMapping\\${viewSetName}</i>.
	         *
	         * During startup this function must not be called before timeouts, keywords and template viewkeys have been read, to be able to modify the mappings accordingly.
	         * This function already extends the results with missing default parameters, which are stored {@link Wincor.UI.Service.ViewService#DEFAULT_VIEWKEY_VALUES}.
	         * It also calls {@link Wincor.UI.Service.ViewService#mapToViewKey}, to replace values of the template-based viewkeys.
	         * Afterwards {@link Wincor.UI.Service.ViewService#correctJSONObject} is called.
	         * This means that all viewkey values in {@link Wincor.UI.Service.ViewService#urlMapping} will be valid JSON objects afterwards and the viewkeys are ready to use.
	         * @param {string} viewSetName `Touch` or `Softkey`, used to determine the correct section.
	         * @returns {Promise}
	         */
	        readViewKeys(viewSetName) {
	            const self = this;
	            const configService = this.serviceProvider.ConfigService;
	            return ext.Promises.promise(function(resolve, reject) {
	                const keySection = `${configService.configuration.instanceName}\\Services\\UIMapping\\${viewSetName}`;
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `> ViewService::readViewKeys(${viewSetName})`);
	                configService.getConfiguration(keySection, null).then(function(result) {
	                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::readViewKeys view keys = ${JSON.stringify(result)}`);
	                    // console.log("* ViewService::onServicesReady(): view keys = " + JSON.stringify(result));
	                    // layer one (map string to default viewkey if necessary and correction of the object)
	                    for(const viewKey of Object.keys(result)) {
	                        _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `* ViewService::readViewKeys(${viewKey}): result=${JSON.stringify(result[viewKey])}`);
	                        // check if viewkey must be mapped
	                        if(typeof result[viewKey] === "string") {
	                            // e.g. "(#DEFAULT_MESSAGE_MAPPING#)"
	                            result[viewKey] = self.mapToViewKey(result[viewKey]);
	                            if(result[viewKey] === "_ERROR_") {
	                                reject("viewKey configuration not available for viewSetName=" + viewSetName);
	                                break;
	                            }
	                            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `* ViewService::readViewKeys(${viewKey}): mapped result=${JSON.stringify(result[viewKey])}`);
	                        } else if(typeof result[viewKey] === "object" && result[viewKey]["useTemplate"] !== void 0) {
	                            //Tooling 2.0 mapping!
	                            result[viewKey] = self.getTemplateValue(result[viewKey]["useTemplate"], viewKey);
	                            if(result[viewKey] === "_ERROR_") {
	                                reject("viewKey configuration not available for viewSetName=" + viewSetName);
	                                break;
	                            }
	                        }

	                        // check if viewkey is a JSON object
	                        if(typeof result[viewKey] === "object") {
	                            // correction of the values
	                            // property correction will be done in processDisplay function
	                            //For jQuery extend see http://api.jquery.com/jquery.extend/, last example on that page is what we use here:
	                            result[viewKey] = jQuery.extend(true, {}, self.DEFAULT_VIEWKEY_VALUES, result[viewKey]); //extends viewKeyConfig with missing default parameters
	                            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `* ViewService::readViewKeys(${viewKey}): after-copy result: ${JSON.stringify(result[viewKey])}`);

	                            result[viewKey] = self.correctJSONObject(result[viewKey], viewKey);
	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::readViewKeys(${viewKey}): after-correct result: ${JSON.stringify(result[viewKey])}`);
	                            if (!result[viewKey].url) {
	                                reject(`ViewService::readViewKeys: Registry section 'UIMapping': Mapping for viewKey=${viewKey} is invalid due to missing or invalid, mandatory 'url' attribute !`);
	                                break;
	                            }
	                        }
	                    }

	                    // copy complete result to mapping variable
	                    self.urlMapping = result;
	                    if(self.urlMapping["Index"]) {
	                        self.startURL = self.urlMapping["Index"].url;
	                        self.setViewContext({}, self.urlMapping["Index"]);
	                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* | VIEW ViewService::readViewKeys setting startURL to ${self.startURL}`);
	                    }
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `< ViewService::readViewKeys(${viewSetName})`);
	                    resolve();
	                });
	            });
	        }

	        /**
	         * This function exists for debugging reasons only.
	         * It is a workaround, which helps to step into this file during a JavaScript debugging session.
	         */
	        debug() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewService::debug");
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::debug");
	        }

	        /**
	         * This method is called by the service-provider if an error occurred in any service.
	         *
	         * It will end the view by calling {@link Wincor.UI.Service.ViewService#endView}.
	         *
	         * @param {String} serviceName  The name of this service.
	         * @param {String} errorType    As defined in {@link Wincor.UI.Service.BaseService#ERROR_TYPE}.
	         */
	        onError(serviceName, errorType) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewService::onError(${serviceName}, ${errorType})`);
	            this.endView(this.UIRESULT_ERROR_VIEW, "ERROR_VIEW_SCRIPT");
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewService::onError");
	        }

	        /**
	         * A convenience function, which will re-read the viewkey templates and afterwards all other viewkeys.
	         * It only calls {@link Wincor.UI.Service.ViewService#readViewKeyTemplates} and {@link Wincor.UI.Service.ViewService#readViewKeys} internally.
	         *
	         * @param {string} viewSetName     `Touch` or `Softkey`, used to determine the correct section.
	         * @return {Promise}                See the return value of {@link Wincor.UI.Service.ViewService#readViewKeys}.
	         */
	        readViewSetConfiguration(viewSetName) {
	            const self = this;

	            return self.readViewKeyTemplates(viewSetName).then(() => {
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* ViewService::loadViewSet ready reading defaults of ${viewSetName}`);
	                return self.readViewKeys(viewSetName);
	            });
	        }

	        /**
	         * ReInitializes the view in case of viewSet changes.
	         *
	         * @param {String} viewSetName      The view-set to be loaded
	         * @param {boolean} immediately     If set to true, the current view will directly return 'UIRESULT_CANCEL_SW' after the new view-set has been loaded.
	         *                                  If omitted or false, the current view gets only deactivated, but the change will take place with the next call of {@link Wincor.UI.Service.ViewService#display}.
	         * @return {Promise}
	         */
	        loadViewSet(viewSetName, immediately) {
	            //TODO loadViewSet can be guarded against parallel calls with the AsyncJobQueue. Imagine a Property change and a Start-Ada event at the same time...
	            const self = this;
	            // const configService = this.serviceProvider.ConfigService;
	            this.loadingViewSet = true;
	            return ext.Promises.promise(function(resolve, reject) {
	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `> | VIEW ViewService::loadViewSet viewSetName=${viewSetName}, immediately=${immediately}`);
	                const oldViewSetName = self.viewSetName;
	                self.previousViewUrl = "";
	                viewSetName = viewSetName !== "" ? viewSetName : self.initialViewSet; // use initial view set if viewSetName is empty. Set self.viewSetName only in case of success

	                self.readViewSetConfiguration(viewSetName)
	                    .then(function() {
	                        _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* ViewService::loadViewSet ready reading viewkeys of ${viewSetName}`);
	                        if(immediately) {
	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, ". | VIEW ViewService::loadViewSet immediately restarting...");
	                            self.registerForServiceEvent(
	                                self.SERVICE_EVENTS.VIEW_ACTIVATED,
	                                function() {
	                                    window.setTimeout(() => {
	                                        self.restarting = false;
	                                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, ". | VIEW ViewService::loadViewSet navigating");
	                                        //TODO: why do we endView on load of index?
	                                        self.endView(self.UIRESULT_CANCEL_SW);
	                                        window.localStorage.setItem("restartSPA", "false");
	                                        resolve();
	                                    }, 250);
	                                },
	                                self.DISPOSAL_TRIGGER_ONETIME
	                            );
	                            self.restarting = true;
	                            window.localStorage.setItem("restartSPA", "true");
	                            _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. | VIEW ViewService::loadViewSet immediately starting ${self.startURL}`);
	                            const applModeContainer = jQuery("#applicationMode");
	                            if(applModeContainer.length) {
	                                jQuery("#applicationMode").fadeOut({
	                                    duration: 600,
	                                    easing: "easeOutQuart",
	                                    complete: () => {
	                                        self.startSPA(self.startURL); //load the new index.html of the new viewset
	                                        self.loadingViewSet = false;
	                                        self.viewSetName = viewSetName;
	                                    }
	                                });
	                            } else {
	                                self.startSPA(self.startURL); //load the new index.html of the new viewset
	                                self.loadingViewSet = false;
	                                self.viewSetName = viewSetName;
	                            }
	                        } else {
	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, ". | VIEW ViewService::loadViewSet postponing restart");
	                            self.isRestartOnNextDisplay = true; // postpone restart until next display is done
	                            self.loadingViewSet = false;
	                            self.viewSetName = viewSetName;
	                            resolve();
	                        }
	                    })
	                    .catch(e => {
	                        self.serviceProvider.propagateError(self.NAME, "loadViewSet", e);
	                        if(oldViewSetName !== viewSetName) {
	                            //will avoid endless recursion if the reload will also fail
	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::loadViewSet failed to load '${viewSetName}', trying noww to reload '${oldViewSetName}'`);
	                            self.loadViewSet(oldViewSetName, true)
	                                .then(() => {
	                                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::loadViewSet successfully re-loaded '${oldViewSetName}'`);
	                                    self.loadingViewSet = false;
	                                    reject("Had to re-load '${oldViewSetName}'");
	                                })
	                                .catch(() => {
	                                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::loadViewSet failed to re-load '${oldViewSetName}'`);
	                                    self.loadingViewSet = false;
	                                    reject("Unable to re-load '${oldViewSetName}'");
	                                });
	                        } else {
	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::loadViewSet rejected, no re-load, because oldViewSetname equals.`);
	                            self.loadingViewSet = false;
	                            reject(e);
	                        }
	                    });

	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "< | VIEW ViewService::loadViewSet");
	            });
	        }
	    };
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ ViewServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$e = getServiceClass$h({
	    Wincor: Wincor$2,
	    jQuery: jQuery$2,
	    ext: ext$2,
	    LogProvider,
	    PTService
	});

	const ServiceInterface$e = {
	    ViewProxy: {
	        interface: {
	            viewContext: {
	                type: "object",
	                keys: ["viewKey", "viewURL", "viewConfig", "viewID"],
	            },
	            EVENT_UIRESULT: {
	                type: "object",
	                keys: ["service", "eventName", "viewID", "UIResult"],
	            },
	            SERVICE_EVENTS: {
	                type: "object",
	                keys: [
	                    "NAVIGATE_SPA",
	                    "VIEW_CLOSING",
	                    "VIEW_BEFORE_CHANGE",
	                    "VIEW_PREPARED",
	                    "TURN_ACTIVE",
	                    "CONTENT_UPDATE",
	                    "VIEW_ACTIVATED",
	                    "VIEW_USERINTERACTION_TIMEOUT",
	                    "STYLE_TYPE_CHANGED",
	                    "POPUP_ACTIVATED",
	                    "POPUP_DEACTIVATED",
	                    "REFRESH_TIMEOUT",
	                    "SHUTDOWN",
	                    "SUSPEND",
	                    "RESUME",
	                    "LOCATION_CHANGED",
	                ],
	                writable: false,
	            },
	            Expand_StringDefines: {
	                attributes: [
	                    "UIRESULT_OK",
	                    "UIRESULT_TIMEOUT_USER",
	                    "UIRESULT_CANCEL_USER",
	                    "UIRESULT_CANCEL_SW",
	                    "UIRESULT_ERROR_VIEW",
	                    "UIRESULT_CANCEL_SW_ERROR",
	                ],
	                type: "string",
	                writable: false,
	            },
	            Expand_Booleans: {
	                attributes: [
	                    "cacheHTML",
	                    "contentRunning",
	                ],
	                type: "boolean",
	                writable: false,
	            },
	            currentStyleType: {
	                type: "string",
	            },
	            currentStyleTypeByStylesheetKey: {
	                type: "string",
	            },
	            currentVendor: {
	                type: "string",
	            },
	            currentResolution: {
	                type: "string",
	            },
	            viewSetName: {
	                type: "string",
	            },
	            Expand_StandardFunctions: {
	                attributes: [
	                    "offlineHandling",
	                    "endView",
	                    "fireActivated",
	                    "firePopupNotification",
	                    "fireContentUpdated",
	                    "firePrepared",
	                    "refreshTimeout",
	                    "getTimeoutValue",
	                    "clearTimeout",
	                    "setViewContext",
	                    "onError",
	                    "loadViewSet",
	                ],
	                type: "function",
	            },
	            Expand_Numbers: {
	                attributes: [
	                    "messageTimeout",
	                    "immediateTimeout",
	                    "endlessTimeout",
	                    "confirmationTimeout",
	                    "inputTimeout",
	                    "pinentryTimeout",
	                ],
	                type: "number",
	                writable: false,
	            },
	            resizeWindow: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            swapLocation: {
	                type: "function",
	            },
	            getLocation: {
	                type: "function",
	            },
	            initialLocation: {
	                type: "object",
	                writable: false,
	                crossCall: true,
	            },
	            bringToFront: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            navigate: {
	                type: "function",
	            },
	            display: {
	                type: "function",
	                external: true,
	                internal: false,
	            },
	            cancel: {
	                type: "function",
	                external: true,
	                internal: false,
	            },
	            prepare: {
	                type: "function",
	                external: true,
	                internal: false,
	            },
	            activate: {
	                type: "function",
	                external: true,
	                internal: false,
	            },
	            resetUserInteractionTimeout: {
	                type: "function",
	                external: true,
	                internal: false,
	            },
	            suspend: {
	                type: "function",
	                crossCall: true,
	            },
	            resume: {
	                type: "function",
	                crossCall: true,
	            },
	            addStyle: {
	                type: "function",
	                crossCall: true,
	            },
	            removeStyle: {
	                type: "function",
	                crossCall: true,
	            },
	            readConfiguration: {
	                type: "function",
	                external: true,
	                internal: false,
	            },
	            contentRunning: {
	                type: "boolean",
	                writable: false,
	                crossCall: true,
	                serviceEvent: true,
	            },
	        },
	    },
	};

	var ViewService = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$e,
		ServiceClass: ServiceClass$e
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany
	 
	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.
	 
	 $MOD$ wn.UI.Service.Interfaces.js 4.3.1-201130-21-086c3328-1a04bc7d
	 */

	const InterfaceGeneral = {
	    "Comment": "This is the standard service interface definition file of ProFlex4 UI",
	    "General": {
	        "interface": {
	            "Expand_GeneralConstants": {
	                "attributes": ["NAME", "DISPOSAL_TRIGGER_DEACTIVATE", "DISPOSAL_TRIGGER_UNLOAD", "DISPOSAL_TRIGGER_ONETIME", "DISPOSAL_TRIGGER_SHUTDOWN"],
	                "type": "string",
	                "writable": false
	            },
	            "onResponse": {
	                "type": "function",
	                "traceable": false
	            },
	            "onRequest": {
	                "type": "function",
	                "traceable": false
	            },
	            "onEvent": {
	                "type": "function",
	                "traceable": false
	            },
	            "registerForServiceEvent": {
	                "type": "function"
	            },
	            "fireServiceEvent": {
	                "type": "function",
	                "internal": false
	            },
	            "deregisterServiceEvents": {
	                "type": "function"
	            },
	            "deregisterFromServiceEvent": {
	                "type": "function"
	            },
	            "onSetup": {
	                "type": "function"
	            },
	            "onServicesReady": {
	                "type": "function"
	            },
	            "whenReady": {
	                "type": "object",
	                "writable": false
	            }
	        }
	    }
	};

	const ServiceBundle = [];

	ServiceBundle.push(LogService);

	ServiceBundle.push(AdaService);

	ServiceBundle.push(BeepService);

	ServiceBundle.push(ConfigService);

	ServiceBundle.push(UtilityService);

	ServiceBundle.push(ControlPanelService);

	ServiceBundle.push(DataService);

	ServiceBundle.push(EppService);

	ServiceBundle.push(EventService);

	ServiceBundle.push(FormatService);

	ServiceBundle.push(JournalService);

	ServiceBundle.push(LocalizeService);

	ServiceBundle.push(ValidateService);

	ServiceBundle.push(VideoService);

	ServiceBundle.push(ViewService);

	var wn_UI_Service_Interfaces = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceBundle: ServiceBundle,
		InterfaceGeneral: InterfaceGeneral
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.



	$MOD$ wn.UI.Service.LogServiceMock.js 4.3.1-210127-21-34ae33df-1a04bc7d
	 */

	/**
	 * @module
	 */
	const getServiceClass$i = ({ BaseService, GatewayProvider}) => {

	    return class LogServiceMock extends BaseService { //Hint: don't write a log in here!!!


	        /**
	         * "LogService" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {String}
	         */
	        NAME = "LogService";

	        /**
	         * The type of this logger. Used by the service-provider.
	         * @const
	         * @type {String}
	         */
	        TYPE = "TRACELOG";

	        /**
	         * The trace level "trace"
	         * @const
	         * @type {String}
	         */
	        METHOD_LOG = "trace";

	        /**
	         * The trace level "error"
	         * @const
	         * @type {String}
	         */
	        METHOD_ERROR = "error";

	        /**
	         * The message that has to be logged
	         * @type {Object}
	         */
	        LOG_MESSAGE = null;

	        /**
	         * Set of trace bits
	         * @type {Object}
	         */
	        TRACEBIT_SET = null;

	        /**
	         * "traceBitStates" - the array containg the states for the trace bits
	         * @type {object}
	         */
	        traceBitStates = {};

	        traceBitsChangedHandler = [];

	        /**
	         * See {@link Wincor.UI.Service.PTService#constructor}.
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            this.traceBitStates = {
	                20: true,
	                21: true,
	                22: true,
	                23: true,
	                24: true,
	                25: true,
	                26: true,
	                27: true,
	                28: true,
	                29: true
	            };
	            this.LOG_MESSAGE = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                eventName: this.METHOD_LOG,
	                traceBit: null,
	                logText: "" // text to log or write error
	            });

	            this.ERROR_MESSAGE = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                eventName: this.METHOD_ERROR,
	                logText: "" // text to log or write error
	            });

	            this.TRACEBIT_SET = Object.assign(Object.assign({}, this.REQUEST), {
	                service: this.NAME,
	                methodName: "trcCheckBit",
	                result: false
	            });
	        }

	        /**
	         * This method logs the given "data" with the traceBit as source identifier
	         * The changed key will be updated in the DataRegistration structure, which contains all prior requested keys.
	         * @param {int} traceBit
	         * @param {string} data
	         */
	        log(traceBit, data) {
	            // Simplify this to speed up things. Errors should be handled in native code
	            if (traceBit === false) {
	                return;
	            }
	            if(GatewayProvider.isConnected() || GatewayProvider.getGateway()) {
	                // TODO: Check if we really want to auto convert
	                data = "" + data; // implicit conversion
	                this.LOG_MESSAGE.traceBit = traceBit;
	                this.LOG_MESSAGE.logText = data;
	                this.sendEvent(this.LOG_MESSAGE);
	            } else {
	                console.log(data);
	            }
	        }

	        /**
	         * This method triggers an event, to log an error with the given data.
	         * @param {string} data
	         */
	        error(data) {
	            if(GatewayProvider.isConnected() || GatewayProvider.getGateway()) {
	                //TODO: Check if we really want to auto convert
	                data = "" + data; // implicit conversion
	                this.ERROR_MESSAGE.logText = data;
	                this.sendEvent(this.ERROR_MESSAGE);
	            } else {
	                console.error(data);
	            }
	        }

	        /**
	         * Check if a trace bit is set.
	         * @param {int} traceBit
	         * @return {boolean}
	         */
	        isTraceBitSet(traceBit) {
	            return this.traceBitStates[traceBit];
	        }

	        /**
	         * Reads the tracebit states from business logic
	         * @param callback Callback function is called when all responses did arrive
	         */
	        readCurrentTraceBitStates(callback) {
	            if (callback) {
	                callback();
	            }
	        }

	        /**
	         *
	         * @param handler
	         * @return {number}
	         */
	        registerTraceBitsChangedHandler(handler) {
	            return -1;
	        }

	        removeTraceBitsChangedHandler(id) {
	        }

	        /**
	         * Called from business logic to set tracebits, if they did change
	         * @param {object} message
	         */
	        setTraceBits(message) {
	        }

	        /**
	         *
	         */
	        onGatewayReady() {
	            //TODO implemented, because it's also in normal LogService, but this function is never called (should be called in toolingEDM mode, because then we have a gateway)
	            super.onGatewayReady();
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ LogServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/


	const ServiceClass$f = getServiceClass$i({
	    BaseService: BaseService$1,
	    GatewayProvider: GatewayProvider$2
	});

	const ServiceInterface$f = {
	    LogProxy: {
	        interface: {
	            log: {
	                type: "function",
	                traceable: false,
	            },
	            error: {
	                type: "function",
	                traceable: false,
	            },
	            isTraceBitSet: {
	                type: "function",
	                traceable: false,
	            },
	            registerTraceBitsChangedHandler: {
	                type: "function",
	                traceable: false,
	            },
	            readCurrentTraceBitStates: {
	                type: "function",
	                traceable: false,
	                callbackArgumentIndex: 0,
	            },
	            TYPE: {
	                type: "string",
	                writable: false,
	            },
	        },
	    },
	};

	var LogService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$f,
		ServiceClass: ServiceClass$f
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.AdaServiceMock.js 4.3.1-210420-21-c476740e-1a04bc7d

	*/

	/**
	 * @module
	 */
	/*global jQuery:false*/
	const getServiceClass$j = ({ BaseService, ext, LogProvider }) => {
	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;
	    let _localizeService;
	    let _currentSpeechLangIso;
	    let _currentVoice = null;
	    let _volume = 1.0;
	    let _pitch = 1;
	    let _rate = 1.0;
	    let _voices = null;
	    let _isVoiceChecking = false;
	    
	    const REPEAT_KEY = "HELP";
	    
	    function checkVoiceSupport(isoLang) {
	        function getVoice(voices) {
	            let supportedVoice = null;
	            for(let voice of voices) {
	                if(voice.lang === isoLang) {
	                    // check for further lang
	                    let others = voices.filter(v => {
	                        return v.lang === isoLang;
	                    });
	                    if(others.length > 1) {
	                        // to activate a supported Google voice use -others[1]. Note: (Chrome 71+) Google voices unfortunately interrupts speech in between text!
	                        supportedVoice = others[0];
	                    } else {
	                        supportedVoice = voice;
	                    }
	                    break;
	                } else {
	                    _logger.log(_logger.LOG_DETAIL, `AdaServiceMock::checkVoiceSupport ${isoLang} NOT supported.`);
	                }
	            }
	            return supportedVoice;
	        }
	        return ext.Promises.promise((resolve, reject) => {
	            if(!_isVoiceChecking) {
	                _isVoiceChecking = true;
	                jQuery("#extendedDesignModeContent").ready(() => {
	                    if(!_voices) {
	                        if(!speechSynthesis.onvoiceschanged) {
	                            speechSynthesis.onvoiceschanged = () => {
	                                _voices = speechSynthesis.getVoices();
	                                if(_voices.length) {
	                                    _currentVoice = getVoice(_voices);
	                                    _logger.log(_logger.LOG_DETAIL, `AdaServiceMock::checkVoiceSupport ${isoLang} use current=${_currentVoice ? JSON.stringify(_currentVoice) : "NO"}`);
	                                    _isVoiceChecking = false;
	                                    resolve(_currentVoice);
	                                } else {
	                                    reject();
	                                }
	                            };
	                        }
	                        _voices = speechSynthesis.getVoices(); // dummy call
	                        if(_voices.length) {
	                            _currentVoice = getVoice(_voices);
	                            _logger.log(_logger.LOG_DETAIL, `AdaServiceMock::checkVoiceSupport ${isoLang} use current=${_currentVoice ? JSON.stringify(_currentVoice) : "NO"}`);
	                            _isVoiceChecking = false;
	                            resolve(_currentVoice);
	                        }
	                    } else {
	                        if(isoLang !== _currentSpeechLangIso) {
	                            _currentVoice = getVoice(_voices);
	                        }
	                        resolve(_currentVoice);
	                    }
	                });
	            }
	        });
	    }

	    return class AdaServiceMock extends BaseService {

	        /**
	         * The logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         * @default "AdaService"
	         */
	        NAME = "AdaService";

	        /**
	         * Object containing the value definitions for state of ADA service {@link Wincor.UI.Service.AdaService#state}.
	         * @enum {string}
	         */
	        STATE_VALUES = {
	            /**
	             * Defines the inactive state for ADA service.
	             * ViewModel should do nothing.
	             * @const
	             * @type String
	             */
	            DONOTHING: "DONOTHING",
	            /**
	             * Defines the idle state for ADA service.
	             * ViewModel should prepare ADA texts.
	             * @const
	             * @type String
	             */
	            BEREADY: "BEREADY",
	            /**
	             * Defines the active state for ADA service.
	             * ViewModel should prepare ADA texts and speak them.
	             * @const
	             * @type String
	             */
	            SPEAK: "SPEAK",
	    
	            /**
	             * Sent when ADA text is on repeat.
	             * @type {String}
	             * @event Wincor.UI.Service.AdaService#SERVICE_EVENTS:REPEAT
	             * @eventtype service
	             */
	            REPEAT: "REPEAT"
	        };

	        /**
	         * Object containing the definitions of view-service events other services or view-models  may register for.
	         * @enum {string}
	         */
	        SERVICE_EVENTS = {
	            /**
	             * Sent when state of ADA service {@link Wincor.UI.Service.AdaServiceMock#state} changes.
	             * @see {@link Wincor.UI.Service.AdaServiceMock#STATE_VALUES}
	             * @event Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:STATE_CHANGED
	             * @eventtype service
	             */
	            STATE_CHANGED: "STATE_CHANGED",
	            /**
	             * Sent when error handling flag {@link Wincor.UI.Service.AdaServiceMock#errorHappened} is set to true.
	             * @type {String}
	             * @event Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:ERROR_HAPPENED
	             * @eventtype service
	             */
	            ERROR_HAPPENED: "ERROR_HAPPENED",
	            /**
	             * Sent when ADA speaking flag {@link Wincor.UI.Service.AdaServiceMock#isSpeaking} is changing from true to false.
	             * @type {String}
	             * @event Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:SPEAKING_STOPPED
	             * @eventtype service
	             */
	            SPEAKING_STOPPED: "SPEAKING_STOPPED",
	            /**
	             * Sent once when the ADA transaction begins.
	             * @type {String}
	             * @event Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:FIRST_START
	             * @eventtype service
	             */
	            FIRST_START: "FIRST_START",
	            /**
	             * Sent once when the ADA transaction ends.
	             * @type {String}
	             * @event Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:LAST_STOP
	             * @eventtype service
	             */
	            LAST_STOP: "LAST_STOP",

	            /**
	             * Sent when ADA text is on repeat.
	             * @type {String}
	             * @event Wincor.UI.Service.AdaService#SERVICE_EVENTS:REPEAT
	             * @eventtype service
	             */
	            REPEAT: "REPEAT"
	        };

	        /**
	         * The actual state of ADA service, changed by function {@link Wincor.UI.Service.AdaServiceMock#adaCommand}.
	         * For possible values see: {@link Wincor.UI.Service.AdaServiceMock#STATE_VALUES}
	         *
	         * @type {string}
	         */
	        state = "";

	        /**
	         * This flag is true when error happens in ADA framework and one view in the GUI have to be ended
	         * with ADA error return code.
	         * This flag should be set to false when the one view in the GUI is ended with ADA error return code.
	         *
	         * @type {boolean}
	         * @default false
	         */
	        errorHappened = false;

	        /**
	         * This flag is true when ADA service enters active state and no speak is done yet.
	         * This flag should be set to false when the first speak is done or ADA service leaves active state.
	         *
	         * @type {boolean}
	         * @default false
	         */
	        firstSpeak = false;

	        /**
	         * This flag is true when ADA service is speaking.
	         *
	         * @type {boolean}
	         * @default false
	         */
	        isSpeaking = false;

	        /**
	         * This flag is true, if autoRepeat has been called with argument > 0
	         *
	         * @type {boolean}
	         * @default false
	         */
	        isAutoRepeatActive = false;

	        /**
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         */
	        constructor(...args) {
	            super(...args, "Hello", "you");
	            this.eppHelpClaimId = -1;
	            this.repeatText = "";
	            this.lastSpokenText = "";
	            this.viewIdWhenRepeatWasStarted = -1;
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "> AdaServiceMock::AdaServiceMock");
	            this.state = this.STATE_VALUES.DONOTHING;
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::AdaServiceMock");
	        }
	        
	        /**
	         * Register ADA events for control of isSpeaking flag
	         * @private
	         */
	        registerAdaEventsForSpeakingControl() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaServiceMock::registerAdaEventsForSpeakingControl()");
	            // these events currently never fires in this mock!
	            let evtService = this.serviceProvider.EventService;
	            this.event1Id = evtService.registerForEvent(1, "CCADAFW", this.onAdaEventSpeakCompleted.bind(this),
	                () => _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaServiceMock::registerAdaEventsForSpeakingControl register callback for event (1): SpeakCompleted"),
	                "ASCII", true);
	            this.event2Id = evtService.registerForEvent(2, "CCADAFW", this.onAdaEventSpeakCancelled.bind(this),
	                () => _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaServiceMock::registerAdaEventsForSpeakingControl register callback for event (2): SpeakCancelled"),
	                "ASCII", true);
	            this.event4Id = evtService.registerForEvent(4, "CCADAFW", this.onAdaEventStop.bind(this),
	                () => _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaServiceMock::registerAdaEventsForSpeakingControl register callback for event (4): Stop"),
	                "ASCII", true);
	            this.event5Id = evtService.registerForEvent(5, "CCADAFW", this.onAdaEventRepeat.bind(this),
	                () => _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaServiceMock::registerAdaEventsForSpeakingControl register callback for event (5): Repeat"),
	                "ASCII", true);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaServiceMock::registerAdaEventsForSpeakingControl");
	        }

	        /**
	         * Deregister ADA events for control of isSpeaking flag
	         * @fires Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:SPEAKING_STOPPED
	         * @private
	         */
	        deregisterAdaEventsForSpeakingControl() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaServiceMock::deregisterAdaEventsForSpeakingControl()");
	            let evtService = this.serviceProvider.EventService;
	            if(this.event1Id !== 0) {
	                evtService.deregisterEvent(this.event1Id, () =>
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaServiceMock::deregisterAdaEventsForSpeakingControl deregister callback for event (1): SpeakCompleted")
	                );
	                this.event1Id = 0;
	            }
	            if(this.event2Id !== 0) {
	                evtService.deregisterEvent(this.event2Id, () =>
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaServiceMock::deregisterAdaEventsForSpeakingControl deregister callback for event (2): SpeakCancelled")
	                );
	                this.event2Id = 0;
	            }
	            if(this.event4Id !== 0) {
	                evtService.deregisterEvent(this.event4Id, () =>
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaServiceMock::deregisterAdaEventsForSpeakingControl deregister callback for event (4): Stop")
	                );
	                this.event4Id = 0;
	            }
	            if(this.event5Id !== 0) {
	                evtService.deregisterEvent(this.event5Id, () =>
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, "* AdaServiceMock::deregisterAdaEventsForSpeakingControl deregister callback for event (5): Repeat")
	                );
	                this.event5Id = 0;
	            }

	            if(this.isSpeaking) {
	                this.isSpeaking = false;
	                this.fireServiceEvent(this.SERVICE_EVENTS.SPEAKING_STOPPED);
	            }

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaServiceMock::deregisterAdaEventsForSpeakingControl");
	        }

	        /**
	         * This delegate is called when the speaking is completed.
	         * @eventhandler
	         * @fires Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:SPEAKING_STOPPED
	         * @private
	         */
	        onAdaEventSpeakCompleted() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaServiceMock::onAdaEventSpeakCompleted");
	            let currId = this.serviceProvider.ViewService.viewContext.viewID;
	            _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. AdaServiceMock::onAdaEventSpeakCompleted forID/currID ${this.viewIdWhenRepeatWasStarted}/${currId}`);
	            if(this.viewIdWhenRepeatWasStarted === currId) {
	                this.viewIdWhenRepeatWasStarted = -1;
	                // if a timeout popup is open it is using own timer handling and thus the view must not restart its own timer
	                const vmHelper = Wincor.UI.Content.ViewModelHelper;
	                if(!vmHelper.isTimeoutPopupActive()) {
	                    // in this case the repeat event results from pressing 'HELP' button on EPP -> refresh interaction timeout of ViewService
	                    this.serviceProvider.ViewService.refreshTimeout();
	                } else {
	                    const timerInfo = vmHelper.getTimerInfo();
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* AdaServiceMock::onAdaEventSpeakCompleted currently a timeout popup is open - refreshing timeout for popup with name=${timerInfo.name}: ${timerInfo.timeLen}`);
	                    vmHelper.refreshTimer(timerInfo.timeLen, timerInfo.name);
	                }
	            }
	            if(this.isSpeaking) {
	                this.isSpeaking = false;
	                this.fireServiceEvent(this.SERVICE_EVENTS.SPEAKING_STOPPED);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaServiceMock::onAdaEventSpeakCompleted");
	        }

	        /**
	         * This delegate is called when the speaking is cancelled.
	         * @eventhandler
	         * @fires Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:SPEAKING_STOPPED
	         * @private
	         */
	        onAdaEventSpeakCancelled() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaServiceMock::onAdaEventSpeakCancelled");
	            if(this.isSpeaking) {
	                this.isSpeaking = false;
	                this.fireServiceEvent(this.SERVICE_EVENTS.SPEAKING_STOPPED);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaServiceMock::onAdaEventSpeakCancelled");
	        }

	        /**
	         * This delegate is called when the ADA is stopped.
	         * @eventhandler
	         * @fires Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:SPEAKING_STOPPED
	         * @private
	         */
	        onAdaEventStop() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaServiceMock::onAdaEventStop");
	            if(this.isSpeaking) {
	                this.isSpeaking = false;
	                this.fireServiceEvent(this.SERVICE_EVENTS.SPEAKING_STOPPED);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaServiceMock::onAdaEventStop");
	        }

	        /**
	         * This delegate is called when the repeat is triggered.
	         * @eventhandler
	         * @private
	         */
	        onAdaEventRepeat() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> AdaServiceMock::onAdaEventRepeat");
	            if(!this.isAutoRepeatActive && !this.isSpeaking) {
	                // we will refresh it on next Completed event
	                this.serviceProvider.ViewService.clearTimeout();
	                this.viewIdWhenRepeatWasStarted = this.serviceProvider.ViewService.viewContext.viewID;
	                // if a timeout popup is open it is using own timer handling
	                const vmHelper = Wincor.UI.Content.ViewModelHelper;
	                if(vmHelper.isTimeoutPopupActive()) {
	                    const timerInfo = vmHelper.getTimerInfo();
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* AdaServiceMock::onAdaEventRepeat currently a timeout popup is open - refreshing timeout for popup with name=${timerInfo.name}: ${timerInfo.timeLen}`);
	                    vmHelper.refreshTimer(timerInfo.timeLen, timerInfo.name);
	                }
	                this.fireServiceEvent(this.SERVICE_EVENTS.REPEAT);
	            }
	            
	            if(this.isSpeaking === false) {
	                this.isSpeaking = true;
	            }
	    
	            if(this.repeatText) {
	                this.speak(this.repeatText, 1, 10);
	            } else if(this.lastSpokenText) {
	                this.speak(this.lastSpokenText, 1, 10);
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< AdaServiceMock::onAdaEventRepeat");
	        }
	    
	        /**
	         * This method is called by the {@link Wincor.UI.Service.Provider#propagateError} if an error occurred in any service. It logs the error to the console.
	         * @param {String} serviceName  The name of this service.
	         * @param {String} errorType    As defined in {@link Wincor.UI.Service.BaseService#ERROR_TYPE}.
	         */
	        onError(serviceName, errorType) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> AdaServiceMock::onError(${serviceName}, ${errorType})`);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::onError");
	        }

	        /**
	         * Text that should be spoken
	         * @param {string=} text        Text to speech
	         * @param {number=} prio        Possibilities: 0 (CCADAFW_PRIO_NO_PURGE), 1 (CCADAFW_PRIO_LOW), 2 (CCADAFW_PRIO_HIGH)
	         * @param {number=} privacy     Possibilities: 0 (CCADAFW_PRIVACY_NONCONFIDENTIAL), 1 (CCADAFW_PRIVACY_CONFIDENTIAL), 10 (CCADAFW_PRIVACY_USE_DEFAULT)
	         * @param {function=} callback  Reference to a function receiving the return code as a parameter.
	         * @async
	         */
	        async speak(text, prio, privacy, callback) {
	            if(localStorage.getItem("activateAdaOn") && this.state === this.STATE_VALUES.SPEAK) {
	                this.logger.log(this.logger.LOG_SRVC_INOUT, `> AdaServiceMock::speak(txt:${text}, prio:${prio}, privacy:${privacy}, ...)`);
	                this.callbackCaller(callback);
	                if(!_currentVoice || _currentVoice.lang !== _localizeService.currentLanguage) {
	                    _currentVoice = await checkVoiceSupport(_localizeService.currentLanguage);
	                }
	                if(_currentVoice && text) {
	                    _currentSpeechLangIso = _localizeService.currentLanguage;
	                    if(speechSynthesis.speaking && prio === 2) {
	                        speechSynthesis.cancel();
	                        this.isSpeaking = false;
	                        this.onAdaEventSpeakCancelled();
	                    }
	                    // First approach: Just eliminate the lang commands / NO_REPEAT in text, until we able to parse and switch language for a given text.
	                    text = text.replace(/<lang langid='\d+'>/g, "");
	                    text = text.replace(/<\/lang>/g, "");
	                    text = text.replace(/WX_ADA_NOREPEAT/g, "");
	                    text = text.trim();
	                    //
	                    if(text) {
	                        setTimeout(() => {
	                            this.lastSpokenText = text;
	                            this.logger.log(this.logger.LOG_SRVC_DATA, `. AdaServiceMock::speak(speech:${text}`);
	                            let speech = new SpeechSynthesisUtterance(text);
	                            speech.voice = _currentVoice;
	                            speech.volume = _volume;
	                            speech.rate = _rate;
	                            speech.pitch = _pitch;
	                            speech.onend = () => {
	                                this.onAdaEventSpeakCompleted();
	                                this.isSpeaking = false;
	                            };
	                            speech.onboundary = () => {
	                            };
	                            speech.onmark = () => {
	                                this.onAdaEventSpeakCompleted();
	                                this.isSpeaking = false;
	                            };
	                            speech.onerror = () => {
	                                this.onAdaEventSpeakCompleted();
	                                this.isSpeaking = false;
	                            };
	                            speech.onpause = () => {
	                                this.onAdaEventSpeakCompleted();
	                                this.isSpeaking = false;
	                            };
	                            this.isSpeaking = true;
	                            speechSynthesis.speak(speech);
	                        }, 500); // decouple, because creating new SpeechSynthesisUtterance in a short time period (< 100ms) causes the engine to stop speaking
	                    }
	                } else {
	                    this.logger.log(this.logger.LOG_DETAIL, `. AdaServiceMock::speak NO VOICE SUPPORT FOR ${_localizeService.currentLanguage}`);
	                    callback(-1);
	                }
	                this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::speak");
	            } else {
	                callback(-1);
	            }
	        }

	        /**
	         * Volume will be increased
	         * @param {function=} callback  Reference to a function receiving the return code as a parameter.
	         */
	        increaseVolume(callback) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "> AdaServiceMock::increaseVolume()");
	            if(_volume < 1.0) {
	                _volume += 0.1;
	            }
	            this.callbackCaller(callback);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::increaseVolume");
	        }

	        /**
	         * Volume will be decreased
	         * @param {function=} callback  Reference to a function receiving the return code as a parameter.
	         */
	        decreaseVolume(callback) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "> AdaServiceMock::decreaseVolume()");
	            if(_volume > 0.0) {
	                _volume -= 0.1;
	            }
	            this.callbackCaller(callback);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::decreaseVolume");
	        }

	        /**
	         * Rate will be increased
	         * @param {function=} callback  Reference to a function receiving the return code as a parameter.
	         */
	        increaseRate(callback) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "> AdaServiceMock::increaseRate()");
	            if(_rate < 10.0) {
	                _rate += 0.1;
	            }
	            this.callbackCaller(callback);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::increaseRate");
	        }

	        /**
	         * Rate will be decreased
	         * @param {function=} callback  Reference to a function receiving the return code as a parameter.
	         */
	        decreaseRate(callback) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "> AdaServiceMock::decreaseRate()");
	            if(_rate > 0.0) {
	                _rate -= 0.1;
	            }
	            this.callbackCaller(callback);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::decreaseRate");
	        }

	        /**
	         * Ada focus is switched to UI application instance dummy function
	         * @param {boolean} [stopSpeaking=true]
	         * @returns {Promise<number>}
	         */
	        switchToApp(stopSpeaking=true) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> AdaServiceMock::switchToApp()`);
	            return ext.Promises.promise(resolve => {
	                let rc = 0;
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< AdaServiceMock::switchToApp returns ${rc}`);
	                if (stopSpeaking) {
	                    this.speak(" ", 2, 0, () => {
	                        resolve(rc);
	                    });
	                } else {
	                    resolve(rc);
	                }
	            });
	        }

	        /**
	         * Text that should be spoken when user press repeat EPP function key, overloads standard repeat behaviour!
	         * @param {string} text         Text that should be spoken, turns this functionality ON. An empty string turns this functionality OFF!
	         * @param {function=} callback  Reference to a function receiving the return code as a parameter.
	         */
	        setRepeatText(text, callback) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> AdaServiceMock::setRepeatText(${text})`);
	            this.repeatText = text;
	            this.callbackCaller(callback);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::setRepeatText");
	        }

	        /**
	         * This method does nothing.
	         * @param {int=} repeatPause    The 0 or ommited argument stops the automatic repeat functionality. Positive number is pause in milliseconds between repeats.
	         * @param {function=} callback  Reference to a function receiving the return code as a parameter.
	         */
	        autoRepeat(repeatPause, callback) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> AdaServiceMock::AutoRepeat(${repeatPause})`);
	            this.callbackCaller(callback);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::AutoRepeat");
	        }

	        /**
	         * This method is called by the business logic to control ADA.
	         * @param {object} message      JSON object containing the key 'command'.
	         * @private
	         * @fires Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:STATE_CHANGED
	         * @fires Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:FIRST_START
	         * @fires Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:LAST_STOP
	         * @fires Wincor.UI.Service.AdaServiceMock#SERVICE_EVENTS:ERROR_HAPPENED
	         */
	        adaCommand(message) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> AdaServiceMock::adaCommand('${JSON.stringify(message)}')`);
	            if(message.command !== void 0 && message.command !== null) {
	                try {
	                    switch(message.command) {
	                        case "IDLE":
	                            this.state = this.STATE_VALUES.BEREADY;
	                            this.firstSpeak = false;
	                            this.errorHappened = false;
	                            this.deregisterAdaEventsForSpeakingControl();
	                            this.fireServiceEvent(this.SERVICE_EVENTS.STATE_CHANGED, this.state);
	                            localStorage.setItem("adaActive", "false");
	                            break;
	                        case "START":
	                            this.state = this.STATE_VALUES.SPEAK;
	                            this.firstSpeak = true;
	                            this.registerAdaEventsForSpeakingControl();
	                            this.fireServiceEvent(this.SERVICE_EVENTS.STATE_CHANGED, this.state);
	                            localStorage.setItem("adaActive", "true");
	                            this.eppHelpClaimId === -1 && Wincor.UI.Service.Provider.EppService.claimKeys([REPEAT_KEY], -1,
	                                res => {
	                                    this.eppHelpClaimId = res.claimId;
	                                }, this.onAdaEventRepeat.bind(this));
	                            break;
	                        case "FIRSTSTART":
	                            this.fireServiceEvent(this.SERVICE_EVENTS.FIRST_START, message.command);
	                            localStorage.setItem("adaActive", "true");
	                            break;
	                        case "FIRSTSTARTANDACTIVATE":
	                            this.fireServiceEvent(this.SERVICE_EVENTS.FIRST_START, message.command);
	                            // activate speaking
	                            this.state = this.STATE_VALUES.SPEAK;
	                            this.firstSpeak = true;
	                            this.registerAdaEventsForSpeakingControl();
	                            // don't send SERVICE_EVENTS.STATE_CHANGED to stay silent in IdleLoop view
	                            break;
	                        case "STOP":
	                            this.state = this.STATE_VALUES.DONOTHING;
	                            this.firstSpeak = false;
	                            this.deregisterAdaEventsForSpeakingControl();
	                            this.fireServiceEvent(this.SERVICE_EVENTS.STATE_CHANGED, this.state);
	                            localStorage.setItem("adaActive", "false");
	                            if (this.eppHelpClaimId > -1) {
	                                Wincor.UI.Service.Provider.EppService.releaseKeys(this.eppHelpClaimId);
	                                this.eppHelpClaimId = -1;
	                            }
	                            break;
	                        case "LASTSTOP":
	                            this.state = this.STATE_VALUES.DONOTHING;
	                            this.firstSpeak = false;
	                            this.deregisterAdaEventsForSpeakingControl();
	                            this.fireServiceEvent(this.SERVICE_EVENTS.STATE_CHANGED, this.state);
	                            this.fireServiceEvent(this.SERVICE_EVENTS.LAST_STOP, message.command);
	                            localStorage.setItem("adaActive", "false");
	                            break;
	                        case "ERROR":
	                            // Do "STOP" first
	                            this.state = this.STATE_VALUES.DONOTHING;
	                            this.firstSpeak = false;
	                            this.deregisterAdaEventsForSpeakingControl();
	                            this.fireServiceEvent(this.SERVICE_EVENTS.STATE_CHANGED, this.state);
	                            // Do "error handling"
	                            // NOTE: BL should only send ERROR if ADA is mandatory, otherwise BL should use STOP!
	                            this.errorHappened = true;
	                            this.fireServiceEvent(this.SERVICE_EVENTS.ERROR_HAPPENED);
	                            localStorage.setItem("adaActive", "false");
	                            break;
	                        default:
	                            break;
	                    }
	                } catch(e) {
	                    this.logger.error(e.message);
	                }
	            } else {
	                this.logger.error("AdaServiceMock::adaCommand() has been called without a command!");
	            }
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::adaCommand");
	        }

	        /**
	         * This method is called by the ViewService to sync viewset switch.
	         * @param eventData event data, possibilities: "FIRSTSTART", "FIRSTSTARTANDACTIVATE", "LASTSTOP"
	         */
	        externalAdaCommandAck(eventData) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> AdaServiceMock::externalAdaCommandAck('${eventData}')`);

	            if(eventData || eventData.length === 0) {
	                this.logger.log(this.logger.LOG_DETAIL, " AdaServiceMock::externalAdaCommandAck OK");
	            } else {
	                this.logger.error("AdaServiceMock::externalAdaCommandAck() has been called without a parameter!");
	            }
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::externalAdaCommandAck");
	        }

	        /**
	         * @param {object} message
	         * @returns {Promise}
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         */
	        onSetup(message) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> AdaServiceMock::onSetup('${JSON.stringify(message)}')`);
	            return ext.Promises.promise(function(resolve, reject) {
	                resolve();
	                this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::onSetup");
	            }.bind(this));
	        }

	        /**
	         * @returns {Promise}
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}.
	         */
	        onServicesReady() {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "> AdaServiceMock::onServicesReady()");
	            _localizeService = this.serviceProvider.LocalizeService;
	            window.localStorage.setItem("adaActive", "false");
	            return ext.Promises.promise((resolve) => {
	                // If a viewset switch is done all EPP registrations will be removed - usually, but in the case an ADA speak has been just
	                // started, the HELP key was claimed for repeat ADA, which is also removed then.
	                // We register us to a shutdown and wait for the first SPA in order to reclaim ourself at a save
	                // state after the viewset switch has been done.
	                let viewService = this.serviceProvider.ViewService;
	                viewService.registerForServiceEvent(viewService.SERVICE_EVENTS.SHUTDOWN, () => {
	                    let regId = viewService.registerForServiceEvent(viewService.SERVICE_EVENTS.NAVIGATE_SPA, () => {
	                        if (this.state === this.STATE_VALUES.SPEAK && this.eppHelpClaimId !== -1) {
	                            this.logger.log(this.logger.LOG_ANALYSE, `. AdaServiceMock::onServicesReady() SPA event received,
                                reclaim to the EPP 'HELP' key for ADA repeat functionality.`);
	                            // reclaim
	                            this.serviceProvider.EppService.claimKeys([REPEAT_KEY], -1,
	                                res => {
	                                    this.eppHelpClaimId = res.claimId;
	                                }, this.onAdaEventRepeat.bind(this));
	                        }
	                        viewService.deregisterFromServiceEvent(regId);
	                    }, true);
	                }, true);
	                super.onServicesReady().then(resolve);
	                this.logger.log(this.logger.LOG_SRVC_INOUT, "< AdaServiceMock::onServicesReady");
	            });
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ AdaServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/


	const ServiceClass$g = getServiceClass$j({
	    BaseService: BaseService$1,
	    ext: ext$3,
	    LogProvider
	});

	const ServiceInterface$g = {
	    AdaProxy: {
	        service: "../servicemocks/wn.UI.Service.AdaServiceMock.js",
	        interface: {
	            state: {
	                type: "string",
	            },
	            STATE_VALUES: {
	                type: "object",
	                keys: ["DONOTHING", "BEREADY", "SPEAK"],
	            },
	            errorHappened: {
	                type: "boolean",
	            },
	            isSpeaking: {
	                type: "boolean",
	                writable: false,
	            },
	            isAutoRepeatActive: {
	                type: "boolean",
	                writable: false,
	            },
	            SERVICE_EVENTS: {
	                type: "object",
	                keys: ["STATE_CHANGED", "ERROR_HAPPENED", "SPEAKING_STOPPED", "FIRST_START", "LAST_STOP"],
	                writable: false,
	            },
	            speak: {
	                type: "function",
	                callbackArgumentIndex: 3,
	            },
	            increaseVolume: {
	                type: "function",
	                callbackArgumentIndex: 0,
	            },
	            decreaseVolume: {
	                type: "function",
	                callbackArgumentIndex: 0,
	            },
	            increaseRate: {
	                type: "function",
	                callbackArgumentIndex: 0,
	            },
	            decreaseRate: {
	                type: "function",
	                callbackArgumentIndex: 0,
	            },
	            setRepeatText: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            autoRepeat: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            externalAdaCommandAck: {
	                type: "function",
	            },
	            adaCommand: {
	                type: "function",
	            },
	            switchToApp: {
	                type: "function",
	            }
	        }
	    }
	};

	var AdaService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$g,
		ServiceClass: ServiceClass$g
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.BeepServiceMock.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$k = ({ BaseService, ext }) => {

	    const _audio = new Audio();

	    return class BeepServiceMock extends BaseService {
	        /**
	         * The logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         * @default "BeepService"
	         */
	        NAME = 'BeepService';

	        /**
	         * This flag turns the beeping ON/OFF.
	         * @type {boolean}
	         * @default true
	         */
	        beeping = true;

	        /**
	         * This is the code for the beep of inactive EPP keys.
	         * Possible values are:<br>
	         *   <ul>
	         *     <li>0  = OFF</li>
	         *     <li>2  = SIU_KEYPRESS</li>
	         *     <li>4  = SIU_EXCLAMATION</li>
	         *     <li>8  = SIU_WARNING</li>
	         *     <li>16 = SIU_ERROR</li>
	         *     <li>32 = SIU_CRITICAL</li>
	         *   </ul>
	         * @type {number}
	         * @default 8
	         */
	        beepInactiveKeyCode = 8;
	    
	        /**
	         * @see {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '> BeepServiceMock::BeepServiceMock');
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '< BeepServiceMock::BeepServiceMock');
	        }
	    
	        /**
	         * This method is called by the {@link Wincor.UI.Service.Provider#propagateError} if an error occurred in any service. It logs the error to the console.
	         *
	         *
	         * @param {String} serviceName  The name of this service.
	         * @param {String} errorType    As defined in {@link Wincor.UI.Service.BaseService#ERROR_TYPE}.
	         */
	        onError(serviceName, errorType) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> BeepServiceMock::onError(${serviceName}, ${errorType})`);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '< BeepServiceMock::onError');
	        }

	        /**
	         * Do a beep.<br>
	         * This method is playing two sounds. For code 2 beep.wav, and for code 8 beep-warning.wav.
	         *
	         * @param {number} [code=2]     beep type, possibilities:
	         * <ul>
	         *      <li>2  (CCSELFW_SIU_KEYPRESS)</li>
	         *      <li>4  (CCSELFW_SIU_EXCLAMATION)</li>
	         *      <li>8  (CCSELFW_SIU_WARNING)</li>
	         *      <li>16 (CCSELFW_SIU_ERROR)</li>
	         *      <li>32 (CCSELFW_SIU_CRITICAL)</li>
	         * </ul>
	         * @param {function} [callback=null]      Reference to a function receiving the return code as a parameter.
	         */
	        beep(code = 2, callback = null) {
	            !arguments[2] && this.logger.log(this.logger.LOG_SRVC_INOUT, `> BeepServiceMock::beep(code:${code})`);
	            if (localStorage.getItem('activateBeepServiceOn') === 'true') {
	                switch (code) {
	                    case 2:
	                        if (_audio.paused) {
	                            _audio.setAttribute('src', 'assets/beep.wav');
	                        } else {
	                            setTimeout(() => {
	                                this.beep(code, null, true);
	                            }, 50);
	                            !arguments[2] && this.logger.log(this.logger.LOG_SRVC_INOUT, '< BeepServiceMock::beep');
	                            return;
	                        }
	                        break;
	                    case 8:
	                        if (_audio.paused) {
	                            _audio.setAttribute('src', 'assets/beep-warning.wav');
	                        } else {
	                            setTimeout(() => {
	                                this.beep(code, null, true);
	                            }, 50);
	                            !arguments[2] && this.logger.log(this.logger.LOG_SRVC_INOUT, '< BeepServiceMock::beep');
	                            return;
	                        }
	                        break;
	                }
	                try {
	                    _audio.play();
	                } catch (e) {
	                    // nothing here for work, error maybe thrown id the play will be interrupted
	                }
	                this.callbackCaller(callback);
	            }
	            !arguments[2] && this.logger.log(this.logger.LOG_SRVC_INOUT, '< BeepServiceMock::beep');
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         *
	         * @param {Object} message      See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onSetup(message) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> BeepServiceMock::onSetup('${JSON.stringify(message)}')`);
	            return ext.Promises.promise((resolve) => {
	                resolve();
	                this.logger.log(this.logger.LOG_SRVC_INOUT, '< BeepServiceMock::onSetup');
	            });
	        }
	        
	        /**
	         * @see {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}
	         * @async
	         * @lifecycle service
	         */
	        async onServicesReady() {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '> BeepServiceMock::onServicesReady()');
	            await super.onServicesReady();
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '< BeepServiceMock::onServicesReady');
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ BeepServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$h = getServiceClass$k({
	    BaseService: BaseService$1,
	    ext: ext$3
	});

	const ServiceInterface$h = {
	    BeepProxy: {
	        service: "../service/wn.UI.Service.BeepService.js",
	        interface: {
	            beeping: {
	                type: "boolean",
	                writable: false
	            },
	            beepInactiveKeyCode: {
	                type: "number",
	                writable: false
	            },
	            beep: {
	                type: "function",
	                callbackArgumentIndex: 1
	            }
	        }
	    }
	};

	var BeepService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$h,
		ServiceClass: ServiceClass$h
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.ConfigServiceMock.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$l = ({ BaseService, ext }) => {

	    let _configData = {};

	    return class ConfigServiceMock extends BaseService {
	        /**
	         * "ConfigServiceMock" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = 'ConfigService';

	        /**
	         * Holds the configuration for the ConfigService, currently only the instance name.
	         * @property {Object} configuration
	         * @property {String} configuration.instanceName the name of the instance e.g. <i>'GUIAPP', 'GUIDM' or 'GUIVIDEO'</i>
	         */
	        configuration = { instanceName: '' };

	        /**
	         * @see {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '> ConfigServiceMock::ConfigServiceMock');
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '< ConfigServiceMock::ConfigServiceMock');
	        }
	        
	        /**
	         * This method is called by the {@link Wincor.UI.Service.Provider#propagateError} if an error occurred in any service. It logs the error to the console.
	         *
	         *
	         * @param {String} serviceName  The name of this service.
	         * @param {String} errorType    As defined in {@link Wincor.UI.Service.BaseService#ERROR_TYPE}.
	         */
	        onError(serviceName, errorType) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> ConfigServiceMock::onError(${serviceName}, ${errorType})`);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '< ConfigServiceMock::onError');
	        }

	        /**
	         * Gets a configuration from the central config source, e.g. Windows registry.
	         *
	         * For examples see also {@link Wincor.UI.Service.ConfigService#getConfiguration}.
	         *
	         * @param {string} section                  Name e.g. "GUIAPP\\Services\\Timeouts"
	         * @param {Array<string> | string} keyArray E.g. ["DEFAULT_PAGE_TIMEOUT", "DEFAULT_INPUT_TIMEOUT", ...] or null for requesting the whole section
	         * @param {function=} callback              Callback function, which receives the result. See {@link Wincor.UI.Service.ConfigService#translateResponse} for the result structure.
	         */
	        getConfiguration(section, keyArray, callback) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> ConfigServiceMock::getConfiguration(${section})`);
	            if (callback) {
	                setTimeout(() => {
	                    const result = {};
	                    const path = section.split('\\');
	                    let ref;

	                    if (section === '') {
	                        ref = _configData;
	                    }

	                    ref =
	                        ref ||
	                        path.reduce((last, act) => {
	                            return last ? last[act] : null;
	                        }, _configData);

	                    if (ref) {
	                        keyArray = keyArray || Object.keys(ref);
	                        keyArray.forEach((key) => {
	                            result[key] = typeof ref[key] !== 'undefined' ? ref[key] : null;
	                        });
	                    }
	                    callback(result);
	                }, this.responseTimeSimulation);
	            }
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '< ConfigServiceMock::getConfiguration');
	        }

	        /**
	         * Reads 'UIConfig.json' and 'UIConfigCustom.json', to have the initial "Registry" parameters for the following getConfiguration() calls.
	         * @param {object} message      Not used by this service.
	         * @async
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         */
	        async onSetup(message) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> ConfigServiceMock::onSetup('${JSON.stringify(message)}')`);
	            const fileUIConfig = '../servicemocks/mockdata/UIConfig.json';
	            const fileUIConfigCustom = '../servicemocks/mockdata/UIConfigCustom.json';
	            try {
	                if (message && message.instanceName) {
	                    this.configuration.instanceName = message.instanceName;
	                }
	                let dataArray = await ext.Promises.Promise.all([
	                    this.retrieveJSONData(fileUIConfig),
	                    this.retrieveJSONData(fileUIConfigCustom)
	                ]);
	                delete dataArray[1]['//']; // remove possible comment
	                // we need deep merge here, therefore using jquery instead of Object.assign
	                _configData = jQuery.extend(true, {}, dataArray[0], dataArray[1]); // standard props with custom specific ones
	                this.logger.log(this.logger.LOG_SRVC_INOUT, '< ConfigServiceMock::onSetup');
	            } catch (e) {
	                console.error(`* importReference error getting ${fileUIConfig} or ${fileUIConfigCustom}`);
	                throw `* importReference error getting ${fileUIConfig} or ${fileUIConfigCustom} error: ${e}`;
	            }
	        }

	        /**
	         * @see {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}
	         * @async
	         * @lifecycle service
	         */
	        async onServicesReady() {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '> ConfigServiceMock::onServicesReady()');
	            await super.onServicesReady();
	            this.logger.log(this.logger.LOG_SRVC_INOUT, '< ConfigServiceMock::onServicesReady');
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ ConfigServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/


	const ServiceClass$i = getServiceClass$l({
	    BaseService: BaseService$1,
	    ext: ext$3
	});

	const ServiceInterface$i = {
	    ConfigProxy: {
	        service: "../service/wn.UI.Service.ConfigService.js",
	        interface: {
	            getConfiguration: {
	                type: "function",
	                callbackArgumentIndex: 2
	            },
	            configuration: {
	                type: "object",
	                keys: ["instanceName"]
	            },
	            retrieveJSONData: {
	                type: "function"
	            }
	        }
	    }
	};

	var ConfigService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$i,
		ServiceClass: ServiceClass$i
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.UtilityServiceMock.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$m = ({BaseService, ext, LogProvider }) => {

	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;

	    return class UtilityServiceMock extends BaseService {

	        /**
	         * "UtilityService" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "UtilityService";

	        IMG_FORMAT = {
	            "UNKNOWN": -1,
	            "BMP": 0,
	            "ICO": 1,
	            "JPEG": 2,
	            "JPG": 2,
	            "JNG": 3,
	            "KOALA": 4,
	            "LBM": 5,
	            "IFF": 5,
	            "MNG": 6,
	            "PBM": 7,
	            "PBMRAW": 8,
	            "PCD": 9,
	            "PCX": 10,
	            "PGM": 11,
	            "PGMRAW": 12,
	            "PNG": 13,
	            "PPM": 14,
	            "PPMRAW": 15,
	            "RAS": 16,
	            "TARGA": 17,
	            "TIFF": 18,
	            "WBMP": 19,
	            "PSD": 20,
	            "CUT": 21,
	            "XBM": 22,
	            "XPM": 23,
	            "DDS": 24,
	            "GIF": 25,
	            "HDR": 26
	        };

	        DEVICE_STATE = {
	            UNDEFINED: 0,
	            OPERATIONAL: 1,
	            NOT_OPERATIONAL: 2,
	            NOT_INSTALLED: 3,
	            DEACTIVATED: 6,
	            NOT_OPERATIONAL_DEACTIVATED: 7
	        };

	        INSTALL_STATE = {
	            NOT_INSTALLED: 0,
	            OPTIONAL: 1,
	            MANDATORY: 2
	        };
	        
	        WORKING_DIRS = {
	            TRANSACTION: "/TEMP_TRANSACTION/",
	            SESSION: "/TEMP_SESSION/"
	        };

	        /**
	         * This object contains all utility-service events, for which other services or view-models can register itself.
	         * @enum {string}
	         */
	        SERVICE_EVENTS = {
	            /**
	             * Sent if the business logic informs about a customer session has ended.
	             * @event Wincor.UI.Service.UtilityService#SERVICE_EVENTS:SESSION_END
	             * @eventtype service
	             */
	            SESSION_END: "SESSION_END",
	        };

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         * Initializes members
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args); // Invoke superclass's initialize
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityServiceMock::UtilityServiceMock");
	            this.savedFiles = [];
	            this.imageStore = "./WORK/TEMP_TRANSACTION/";
	            this.imageStoreRoot = "./WORK";
	            this.targetFileType = "bmp";
	            this.PATHS = {};
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityServiceMock::UtilityServiceMock");
	        }
	        
	        /**
	         * Loads image to memory of CCImgCnv.dll to prepare manipulation
	         * @param {string} srcFileName
	         * @param {string} srcFormat
	         * @param {number} flags
	         * @returns {Promise}
	         */
	        loadImage(srcFileName, srcFormat, flags) {
	            let result = 0;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityServiceMock::loadImage");
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< UtilityServiceMock::loadImage returned ${result}`);
	            return ext.Promises.Promise.resolve();
	        }

	        /**
	         * Unloads image from memory of CCImgCnv.dll
	         * @returns {Promise}
	         */
	        unloadImage() {
	            let result = 0;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityServiceMock::unloadImage");
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< UtilityServiceMock::unloadImage returned ${result}`);
	            return ext.Promises.Promise.resolve();
	        }

	        /**
	         * Save image to file from memory of CCImgCnv.dll
	         * @param {string} targetFileName
	         * @param {string} targetFormat
	         * @param {number} flags
	         * @returns {*}
	         */
	        saveImage(targetFileName, targetFormat, flags) {
	            let result = 0;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityServiceMock::saveImage");
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< UtilityServiceMock::saveImage returned ${result}`);
	            return ext.Promises.Promise.resolve();
	        }

	        /**
	         * Convenience function used to convert an existing image on file system to a specific format
	         * @param {string} srcFileName
	         * @param {string} srcFileFormat
	         * @param {string} targetFileName
	         * @param {string} targetFileFormat
	         */
	        convertFileType(srcFileName, srcFileFormat, targetFileName, targetFileFormat) {
	            let self = this;
	            return ext.Promises.promise(function(resolve, reject) {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> UtilityServiceMock::convertFileType(${srcFileName}, ${srcFileFormat}, ${targetFileName}, ${targetFileFormat})`);
	                let srcFormat = self.IMG_FORMAT[srcFileFormat.toUpperCase()];
	                let targetFormat = self.IMG_FORMAT[targetFileFormat.toUpperCase()];
	                let flags = 0;
	                if (!srcFormat) {
	                    reject("srcFileFormat invalid: " + srcFileFormat);
	                } else if (!targetFormat) {
	                    reject("targetFileFormat invalid: " + targetFileFormat);
	                } else {
	                    // go
	                    self.loadImage(srcFileName, srcFormat, flags)
	                        .then(function() {
	                            return self.saveImage(targetFileName, targetFormat, flags);
	                        })
	                        .then(self.unloadImage.bind(self))
	                        .then(function() {
	                            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityServiceMock::convertFileType");
	                        })
	                        .then(resolve);
	                }
	            });
	        }

	        /**
	         * This function does not work in extended design mode
	         * @returns {Promise}
	         */
	        removeTransparentWindowColor() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityServiceMock::removeTransparentWindowColor()");
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityServiceMock::removeTransparentWindowColor");
	            return ext.Promises.Promise.resolve();
	        }

	        /**
	         * This function does not work in extended design mode
	         * @returns {Promise}
	         */
	        setTransparentWindowColor() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityServiceMock::removeTransparentWindowColor()");
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityServiceMock::removeTransparentWindowColor");
	            return ext.Promises.Promise.resolve();
	        }

	        /**
	         * Saves image data to the filesystem using native UI component.
	         * @param {string} fileName Name without extension
	         * @param {string} imageData base64 coded
	         * @param {string} srcFileType
	         * @param {string=} id
	         * @param {string=} targetFileType
	         * @param {boolean=} base64Encoded
	         * @returns {Promise}
	         */
	        saveImageToFile(fileName, imageData, srcFileType, id, targetFileType, base64Encoded) {
	            let result = 0;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> UtilityServiceMock::saveImageToFile(${fileName},... ,${srcFileType},${id}, ${targetFileType}, ${base64Encoded})`);
	            let srcFileName;
	            let targetFileName;

	            if (fileName[0] === "/" || fileName[0] === "\\") {
	                srcFileName = this.imageStoreRoot + fileName + "." + srcFileType;
	                targetFileName = this.imageStoreRoot + fileName + "." + targetFileType;
	            } else {
	                srcFileName = this.imageStore + fileName + "." + srcFileType;
	                targetFileName = this.imageStore + fileName + "." + targetFileType;
	            }

	            this.PATHS[id] = targetFileType ? targetFileName : srcFileName;

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< UtilityServiceMock::saveImageToFile src:<${srcFileName}> target:<${targetFileName}> returned: ${result}`);
	            return ext.Promises.Promise.resolve();
	        }

	        /**
	         * This method runs a subFlow of the business logic and returns the result by means of resolving the returned promise
	         * @param {string} flowName Arguments for this activity as array
	         * @returns {Promise} Resolving to rc of the flow
	         */
	        callFlow (flowName) {
	            let result = 0;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> UtilityServiceMock::callFlow(${flowName})`);

	            return ext.Promises.Promise.resolve(result).delay(5000)
	                .then(()=>{_logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `< UtilityServiceMock::callFlow (${flowName} returned ${result}`);});
	        }

	        /**
	         * This function is used to delete the images after a customer session
	         * @returns {*|Promise.<T>}
	         */
	        clearImageStore() {
	            let result = 0;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityServiceMock::clearImageStore()");
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< UtilityServiceMock::clearImageStore returned: ${result}`);
	            return ext.Promises.Promise.resolve();
	        }

	        /**
	         * Adds a filter for tracing private information (mock does nothing...)
	         * @param {string|number} filter
	         * @return {Promise<number>} error on negative values
	         */
	        addTraceFilter(filter) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> UtilityServiceMock::addTraceFilter()");
	            const dataType = typeof filter;
	            if (dataType !== "string") {
	                // convert to string but write error-log for all others than number data-type
	                if (dataType !== "number") {
	                    this.logger.error(`UtilityServiceMock::addTraceFilter() got unsupported argument type [${dataType}]`);
	                }
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< UtilityServiceMock::addTraceFilter");
	            return ext.Promises.Promise.resolve(0);
	        }

	        /**
	         * Tries to stop the DM campaign
	         * @returns {Promise}
	         */
	        dmStop() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> UtilityServiceMock::dmStop`);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< UtilityServiceMock::dmStop`);
	            return ext.Promises.Promise.resolve(0);
	        }

	        /**
	         * Returns an array of [DEVICE_STATE, INSTALL_STATE] values for a given device
	         * @param {string} deviceName
	         */
	        async getDeviceState(deviceName) {
	            _logger.log(_logger.LOG_SRVC_DATA, `> UtilityServiceMock::getDeviceState(${deviceName})`);
	            _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `< UtilityServiceMock::getDeviceState returns [1, 1]`);
	            return [1, 1];
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ UtilityServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$j = getServiceClass$m({
	    BaseService: BaseService$1,
	    ext: ext$3,
	    LogProvider
	});

	const ServiceInterface$j = {
	    UtilityProxy: {
	        //service: "../service/wn.UI.Service.UtilityService.js",
	        interface: {
	            SERVICE_EVENTS: {
	                type: 'object',
	                keys: ['SESSION_END'],
	                writable: false
	            },
	            PATHS: {
	                type: 'object',
	                writable: false
	            },
	            WORKING_DIRS: {
	                type: 'object',
	                writable: false
	            },
	            setTransparentWindowColor: {
	                type: 'function'
	            },
	            removeTransparentWindowColor: {
	                type: 'function'
	            },
	            saveImageToFile: {
	                type: 'function'
	            },
	            callFlow: {
	                type: 'function'
	            },
	            addTraceFilter: {
	                type: 'function'
	            },
	            dmStop: {
	                type: 'function'
	            },
	            getDeviceState: {
	                type: 'function'
	            },
	            DEVICE_STATE: {
	                type: 'object',
	                writable: false
	            },
	            INSTALL_STATE: {
	                type: 'object',
	                writable: false
	            }
	        }
	    }
	};

	var UtilityService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$j,
		ServiceClass: ServiceClass$j
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.DataServiceMock.js 4.3.1-210701-21-172c70a5-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$n = ({ Wincor, BaseService, LogProvider }) => {
	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @const
	     * @private
	     */
	    const _logger = LogProvider;

	    const LISE_DATA_SEPARATOR = "_||_";
	    const PROP_ARRAY_MARKER = "[A";
	    const PROP_INDEX_BEGIN_MARKER = "[";
	    const PROP_ATTRIBUTE_BEGIN_MARKER = ".";

	    const MAX_LEN_REQUESTED_KEYS = 131072; // 128KB
	    const MAX_LEN_REQUESTED_VALUES = 131072; // 128KB
	    const MAX_COUNT_REQUESTED_KEYS = 1024;

	    let _businessData = {};
	    let _businessPropKeyMap = {};
	    let _viewService;
	    let _configService;
	    let _controlPanelService;

	    /**
	     * Array containing elements of {@link Wincor.UI.Service.DataServiceMock#DataRegistration}.
	     * @type {Array}
	     */
	    let _dataRegistrators = []; // [DataRegistration1, DataRegistration2, ... ]

	    let _requestId = 0;

	    /**
	     * The property request map.
	     * The map contain request id's with objects containing mapped properties.
	     * @example
	     * 4911:
	     * {
	     *      "CCTAFW_PROP_CURRENCY": "PROP_CURRENCY_ISO",
	     *      "CCTAFW_PROP_CURRENCY_EXPONENT": "PROP_CURRENCY_EXP"
	     * }
	     * @type {Map}
	     */
	    const _propRequestMap = new Map();

	    let _usedBusinessProperties = new Map();

	    return class DataServiceMock extends BaseService {
	        /**
	         * The logical name of this service as used in the {@link Wincor.UI.Service.Provider}.
	         * @default DataService
	         * @const
	         * @type {string}
	         */
	        NAME = "DataService";

	        /**
	         * @type {Array<function(string):boolean>}
	         */
	        propertyHandler = null;

	        /**
	         * Contains the business property keymap.
	         * @type {Object}
	         */
	        businessData = _businessData;

	        /**
	         * Contains the UI specific property keys.
	         * @type {Object}
	         */
	        UIPropertyKeys = {};

	        /**
	         * Structure containing the registered data keys
	         * @class
	         */
	        DataRegistration = function() {
	            /**
	             * The registered data keys of the business properties.
	             * @type {Array<string>}
	             */
	            this.keys = []; //the registered dataKeys

	            /**
	             * The key map may contain mapped business keys to original requested keys.
	             * E.g.: {"CCTAFW_PROP_CURRENCY": "PROP_CURRENCY_ISO"}
	             * @type {Object}
	             */
	            this.keyMap = {};

	            /**
	             * A callback function which is called when the dataChanged event is triggered
	             * @type {function}
	             */
	            this.onUpdate = null; //this callback is called when the dataChanged event is triggered

	            /**
	             * If registration is persistent (true), a content-page unload will not remove the registration, false otherwise.
	             * @type {boolean}
	             */
	            this.persistent = false; //if registration is persistent, a content-page unload will not remove the registration
	        };

	        /**
	         * The service events for the DataServiceMock.
	         * @enum {string}
	         */
	        SERVICE_EVENTS = {
	            /**
	             * Fired when any setValues() has been done.
	             * @event  Wincor.UI.Service.DataServiceMock#SERVICE_EVENTS:DATA_CHANGED
	             * @eventtype service
	             */
	            DATA_CHANGED: "DATA_CHANGED"
	        };

	        /**
	         * This event is sent if there are missing data keys.
	         * @type {Object}
	         * @eventtype native
	         * @event  Wincor.UI.Service.DataServiceMock#EVENT_MISSING_DATA_KEYS
	         */
	        EVENT_MISSING_DATA_KEYS = null;

	        /**
	         * Initializes the member of this class.
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.log(_logger.LOG_SRVC_INOUT, "> DataServiceMock::DataServiceMock");
	            this.EVENT_MISSING_DATA_KEYS = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                viewID: -1,
	                viewKey: null,
	                eventName: "MissingDataKeys",
	                keys: []
	            });

	            _logger.log(_logger.LOG_SRVC_INOUT, "< DataServiceMock::DataServiceMock");
	        }

	        /**
	         * Clean the {@link Wincor.UI.Service.DataService#dataArray} containing all
	         * {@link Wincor.UI.Service.DataService#DataRegistration} structures which has been set by the
	         * {@link Wincor.UI.Service.DataService#getValues} method.
	         */
	        cleanDataRegistrations() {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> DataServiceMock::cleanDataRegistrations()");
	            let newDataArray = [];
	            // keep the persistent items in -newDataArray
	            for(let i = _dataRegistrators.length - 1; i >= 0; i--) {
	                if(_dataRegistrators[i].persistent) {
	                    // keep the persistent item
	                    newDataArray.push(_dataRegistrators[i]);
	                }
	            }
	            _dataRegistrators = newDataArray; // empty array or the persistent items kept
	            _propRequestMap.clear(); // clean the property request map
	            _requestId = 0; // reset request id
	            _logger.log(_logger.LOG_SRVC_INOUT, "< DataServiceMock::cleanDataRegistrations");
	        }

	        /**
	         * Gets the current data registrations.
	         * Data registrations are properties which for an update callback has been given via {@link Wincor.UI.Service.DataService#getValues}
	         * @return {Array<DataRegistration>} the current data registrations
	         */
	        getDataRegistrations() {
	            return _dataRegistrators;
	        }

	        /**
	         * Gets a business property key map.
	         * @returns {Object} the property key map
	         */
	        getPropertyKeyMap() {
	            return _businessPropKeyMap;
	        }

	        /**
	         * Gets a map with the given request id.
	         * @param {Number} reqId the request id from the original{@link Wincor.UI.Service.DataService#getValues} request
	         * @return {Object} the key map, if one found, or a plain object in case if not
	         */
	        getKeyMap(reqId) {
	            let mapVal = {};
	            if(_propRequestMap.has(reqId)) {
	                mapVal = _propRequestMap.get(reqId);
	            }
	            return mapVal;
	        }

	        /**
	         * Maps business keys which have to replaced by the original keys from request.
	         * If the given request id is exists the properties are mapped back into the given response.
	         * The map with request id is removed after mapping back.
	         * @param {Object} response the response which might containing business keys which we have to replace with the original keys from request
	         * @param {Number} reqId the request id from the original{@link Wincor.UI.Service.DataServiceMock#getValues} request
	         * @return {Object} the given response which might have mapped back property keys
	         */
	        mapResponseKeys(response, reqId) {
	            if(response && reqId && _propRequestMap.has(reqId)) {
	                const mapVal = _propRequestMap.get(reqId);
	                const respKeys = Object.keys(response);
	                const len = respKeys.length;
	                for(let i = 0; i < len; i++) {
	                    let key = respKeys[i]; // business key
	                    if(key in mapVal) {
	                        response[mapVal[key]] = response[key]; // add a new one with the original request key
	                        delete response[key]; // delete the one with the business key
	                    }
	                }
	                _propRequestMap.delete(reqId); // finally delete mapping for that request id
	            }
	            return response;
	        }

	        /**
	         * Maps the requested key to the corresponding business key if necessary.
	         * @param {String} key the requested property key which might is a key which we have to map to a business key name using
	         * the 'BusinessPropertyKeyMap.json'
	         * @return {String} the mapped key or the given key in case of it could not mapped
	         */
	        mapKey(key) {
	            if(key && typeof key === "string") {
	                let attrMarker = key.indexOf(PROP_ATTRIBUTE_BEGIN_MARKER);
	                let arrayMarkerIdx = key.indexOf(PROP_INDEX_BEGIN_MARKER);
	                if(arrayMarkerIdx === -1 && attrMarker === -1) {
	                    return _businessPropKeyMap[key] || key;
	                } else {
	                    let plainKey = attrMarker !== -1 ? key.substr(0, attrMarker) : key.substr(0, arrayMarkerIdx);
	                    let marker = attrMarker !== -1 ? key.substr(attrMarker) : key.substr(arrayMarkerIdx);
	                    if(plainKey in _businessPropKeyMap) {
	                        return `${_businessPropKeyMap[plainKey]}${marker}`;
	                    }
	                }
	            }
	            return key;
	        }

	        /**
	         * Maps the requested keys to the corresponding business keys if necessary.
	         * If a request id is given and there are keys to map it stores the mapping
	         * until {@link Wincor.UI.Service.DataServiceMock#mapResponseKeys} has been invoked with the same request id.
	         * @param {Array<String>} keys the requested property keys which might contain keys which we have to map to business key names using
	         * the 'BusinessPropertyKeyMap.json'
	         * @param {Number=} reqId the request id from the original{@link Wincor.UI.Service.DataServiceMock#getValues} request
	         * @return {Array} the keys array might contain mapped keys
	         */
	        mapKeys(keys, reqId) {
	            let mappedKeys = [];
	            let val = {};
	            let mapVal;
	            const len = keys.length;
	            for(let i = 0; i < len; i++) {
	                let key = keys[i];
	                if(typeof key !== "string" || !isNaN(key)) {
	                    _logger.error(
	                        `DataServiceMock::mapKeys the key='${key}' within the given keys=[${keys}] array is not a string, please check your DataServiceMock::getValues call(s) for viewKey=${this.serviceProvider.ViewService.viewContext.viewKey}`
	                    );
	                    continue;
	                }
	                let attrMarker = key.indexOf(PROP_ATTRIBUTE_BEGIN_MARKER);
	                let arrayMarkerIdx = key.indexOf(PROP_INDEX_BEGIN_MARKER);
	                let plainKey = null;
	                let marker = null;
	                if(arrayMarkerIdx !== -1 || attrMarker !== -1) {
	                    plainKey = attrMarker !== -1 ? key.substr(0, attrMarker) : key.substr(0, arrayMarkerIdx);
	                    marker = attrMarker !== -1 ? key.substr(attrMarker) : key.substr(arrayMarkerIdx);
	                }
	                key = plainKey || key;
	                let keyFromMap = _businessPropKeyMap[key];
	                let propKey = keyFromMap || key;
	                propKey = plainKey ? `${propKey}${marker}` : propKey;
	                // force unique keys
	                if(!mappedKeys.includes(propKey)) {
	                    mappedKeys.push(propKey);
	                }
	                if(reqId && keyFromMap) {
	                    if(!mapVal) {
	                        if(_propRequestMap.has(reqId)) {
	                            mapVal = _propRequestMap.get(reqId);
	                        } else {
	                            mapVal = _propRequestMap.set(reqId, val).get(reqId);
	                        }
	                    }
	                    mapVal[propKey] = plainKey ? `${key}${marker}` : key;
	                }
	            }
	            return mappedKeys;
	        }

	        /**
	         * Get the values of the requested parameters stored in the registry.
	         * @param {Array<string> | string} keys e.g. ["VAR_MY_HTML_NAME_S", "CUSTOMER_SURNAME", ...]
	         * @param {function (Object)=} callback
	         * @param {function (Object)} onUpdateCallback callback is called when a key was updated.
	         * @param {boolean=} persistent true, if the -onUpdateCallback callback function should stay persistent, even a
	         *        {@link Wincor.UI.Service.DataService#cleanDataRegistrations} is invoked, false otherwise.
	         */
	        getValues(keys, callback, onUpdateCallback, persistent) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> DataServiceMock::getValues(${keys})`);
	            keys = Array.isArray(keys) ? keys : [keys];
	            keys = this.mapKeys(keys, ++_requestId);
	            const reqId = _requestId;

	            function sendMessageMissingKeys(missingKeys) {
	                if(missingKeys.length > 0) {
	                    const ctx = _viewService.viewContext;
	                    this.EVENT_MISSING_DATA_KEYS.viewID = ctx.viewID;
	                    this.EVENT_MISSING_DATA_KEYS.viewKey = ctx.viewKey;
	                    if(ctx.viewKeyRedirect) {
	                        this.EVENT_MISSING_DATA_KEYS.viewKey = ctx.redirectFrom; // overwrite to satisfy tooling
	                        this.EVENT_MISSING_DATA_KEYS.redirectedToViewKey = ctx.redirectTo;
	                    } else {
	                        delete this.EVENT_MISSING_DATA_KEYS.redirectedToViewKey;
	                    }
	                    this.EVENT_MISSING_DATA_KEYS.keys = missingKeys;
	                    this.sendEvent(this.EVENT_MISSING_DATA_KEYS);
	                }
	            }

	            function generateSpecificResponse(reqId) {
	                let response = {};
	                let uniqueKeys = [];
	                let missingKeys = [];
	                let overallLen = 0;
	                for(let i = 0; i < keys.length; ++i) {
	                    // must use forward loop, because of order of the keys (e.g. ProFlex4Op)
	                    let key = keys[i];
	                    if(key === void 0 || key === null) {
	                        _logger.error(`Error: DataServiceMock::getValues invalid key detected: ${key}`);
	                        continue;
	                    }
	                    // Note:
	                    // CCTAFW_PROP_CURRENCY[0] is always the same as CCTAFW_PROP_CURRENCY, even that property isn't an index based one!
	                    // ControlPanel: We will store the property as CCTAFW_PROP_CURRENCY, even the request was CCTAFW_PROP_CURRENCY[0]!
	                    if(!uniqueKeys.includes(key)) {
	                        uniqueKeys.push(key);
	                        overallLen += key.length;
	                        // check for something like "CCCHCCDMTAFW_CHEQUE_ACCEPTED[idx] or CCCHCCDMTAFW_CHEQUE_ACCEPTED.id[idx]"
	                        // except for something like "CCTAFW_PROP_EMV_APPLICATION_SELECTION_LISE_DATA[A,0,2]" which is for LISE concept
	                        let parts = this.extractKeyPartsFromProperty(key);
	                        let index = parts.idx === -1 ? 0 : parts.idx;
	                        let attrChain = parts.attrChain;
	                        let value = _businessData[parts.key];
	                        let viewKey = _viewService.viewContext.viewKey;
	                        // NOTE: Empty string is a valid value, if("") delivers false always
	                        if(value || value === "") {
	                            // first lookup with concrete view key, if it not exist then lookup with '*'
	                            if(!value[viewKey] && value !== "") {
	                                viewKey = "*";
	                                value = value[viewKey];
	                                if(Array.isArray(value)) {
	                                    // value is an array ?
	                                    value = value[index];
	                                }
	                                if(attrChain) {
	                                    // value is expected as JSON
	                                    value = this.getValueFromJSON(value, attrChain);
	                                }
	                                if(!value && value !== "") {
	                                    value = null;
	                                    _logger.error(
	                                        `Warning: No business value for key=${key} and viewKey=${viewKey} available. Please check 'BusinessData.json' file`
	                                    );
	                                }
	                            } else if(typeof value === "object") {
	                                // if a specific view key has been succeeded, its value is expected as object then...
	                                let data = value[viewKey];
	                                if(data) {
	                                    value = data;
	                                    if(Array.isArray(value)) {
	                                        // value is an array ?
	                                        value = value[index];
	                                    }
	                                    if(attrChain) {
	                                        // value is expected as JSON
	                                        value = this.getValueFromJSON(value, attrChain);
	                                    }
	                                } else {
	                                    value = null;
	                                    _logger.error(
	                                        `No LISE business value for key=${key} and viewKey=${viewKey} available. Please check 'BusinessData.json' file`
	                                    );
	                                }
	                            } else {
	                                value = null;
	                                _logger.error(
	                                    `No LISE business value for key=${key} and viewKey=${viewKey} available. Value is not an object as it was expected. Please check 'BusinessData.json' file`
	                                );
	                            }
	                        } else {
	                            value = null;
	                            Wincor.toolingEDM && missingKeys.push(key);
	                            _logger.error(
	                                `Warning: No business value for key=${key} and viewKey=${viewKey} available. Please check 'BusinessData.json' file`
	                            );
	                        }
	                        // LISE handling necessary ?
	                        // e.g.: If we got a key like "CCTAFW_PROP_PREPAID_LISE_LIST[A,7,11]"
	                        if(value && typeof value === "string" && value.includes(LISE_DATA_SEPARATOR)) {
	                            // we expect a string here due to indexOf
	                            // - Code when must consider the startIndex -
	                            // We have to extract the start index and deliver data from that point of array:
	                            // let dataArray = value.split(LISE_DATA_SEPARATOR), startIdx = 0;
	                            // if(key.indexOf(PROP_ARRAY_MARKER) !== -1) {
	                            //     startIdx = extractStartIndexFromArrayKey(key);
	                            // }

	                            // - Legacy code when not consider the startIndex -
	                            // We have to ignore the start index and deliver always the whole data length.
	                            // This is because the retrieved data (which are the original generated tooling data) are handled as net data, where the startIndex has already been
	                            // considered by a lower-level data generator (e.g. DataDictionaryExt) and hence must not be considered once again.
	                            response[key] = value.split(LISE_DATA_SEPARATOR);
	                        } else {
	                            response[key] = value; // a normal key/value
	                            if(key.includes(PROP_ARRAY_MARKER)) {
	                                // LISE access prop with only one item?
	                                response[key] = [value];
	                            }
	                        }
	                    } else {
	                        _logger.error(`Warning: DataServiceMock::getValues double key detected: ${key}`);
	                    }
	                }
	                if(Wincor.toolingEDM) {
	                    sendMessageMissingKeys.call(this, missingKeys);
	                }
	                // handle business properties map
	                let resKeys = Object.keys(response);
	                for(let i = 0; i < resKeys.length; i++) {
	                    let key = resKeys[i];
	                    if(!missingKeys.includes(key)) {
	                        let storeKey = key;
	                        // CCTAFW_PROP_CURRENCY[0] is always the same as CCTAFW_PROP_CURRENCY so we store CCTAFW_PROP_CURRENCY only
	                        // We pass something like "CCTAFW_PROP_TARGET_ACCOUNT_DATA.id[0]"
	                        if(key.includes("[0]") && !key.includes(PROP_ATTRIBUTE_BEGIN_MARKER)) {
	                            storeKey = key.substr(0, key.indexOf("[0]"));
	                        }
	                        _usedBusinessProperties.set(storeKey, response[key]);
	                    }
	                }
	                _controlPanelService.updateBusinessProperties(_usedBusinessProperties);

	                //build a new DataRegistration object and add it to our Array if (and only if!) an onUpdateCallback is given
	                if(onUpdateCallback) {
	                    let dataReg = new this.DataRegistration();
	                    dataReg.keys = uniqueKeys;
	                    dataReg.keyMap = this.getKeyMap(reqId);
	                    dataReg.onUpdate = onUpdateCallback;
	                    dataReg.persistent = persistent ? persistent : false; // note, persistent arg is optional
	                    _dataRegistrators.push(dataReg);
	                }

	                // check for potential argument error
	                if(overallLen > MAX_LEN_REQUESTED_KEYS || uniqueKeys.length > MAX_COUNT_REQUESTED_KEYS) {
	                    _logger.error(
	                        `DataServiceMock::getValues() too many or too long property keys argument requested. Please check your keys array argument. Number of keys requested: ${uniqueKeys.length}, string len: ${overallLen}`
	                    );
	                }

	                if(reqId) {
	                    response = this.mapResponseKeys(response, reqId); // replace business keys by the original requested mapped keys, if necessary
	                }
	                return response;
	            }

	            if(callback) {
	                setTimeout(() => callback(generateSpecificResponse.call(this, reqId)), this.responseTimeSimulation);
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, "< DataServiceMock::getValues");
	        }

	        /**
	         * Set the values of the requested parameters to be stored within the business logic.
	         * @param {Array<string> | string} keys e.g. a single string or ["VAR_MY_HTML_NAME_S", "CUSTOMER_SURNAME", ...]
	         * @param {Array<string> | string} values e.g. a single string or ["cardinsert.html", "Doe", ...]
	         * @param {function=} callback is called when the values are set
	         */
	        setValues(keys, values, callback) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> DataServiceMock::setValues(${keys}, ${values})`);

	            keys = Array.isArray(keys) ? keys : [keys];
	            values = Array.isArray(values) ? values : [values];

	            let uniqueKeys = [];
	            let correspondingValues = [];
	            let errorMessage;
	            if(keys.length !== values.length) {
	                errorMessage = "DataServiceMock::setValues(): keys and values do not have the same size.";
	            } else {
	                let overallKeysLen = 0;
	                let overallValuesLen = 0;
	                for(let i = 0; i < keys.length; ++i) {
	                    let key = keys[i];
	                    let value = values[i];
	                    if(key !== void 0 && key !== null) {
	                        //do NOT use '!keys[i]' because empty string is okay, 0 is okay
	                        let mappedKey = this.mapKey(key);
	                        if(!uniqueKeys.includes(mappedKey)) {
	                            uniqueKeys.push(mappedKey); // do the mapping of the key
	                            overallKeysLen += key.length;
	                            if(value !== void 0 && value !== null) {
	                                // do NOT use '!keys[i]' because empty string is okay, 0 is okay
	                                if(typeof value === "object") {
	                                    _logger.error(
	                                        `Warning: DataServiceMock::setValues value for key: ${mappedKey} is an object, please check EDM code!`
	                                    );
	                                }
	                                value = value.toString();
	                                correspondingValues.push(value);
	                                overallValuesLen += value.length;
	                            } else {
	                                errorMessage = "DataServiceMock::setValues() values contains null or undefined.";
	                                break;
	                            }
	                        } else {
	                            if(mappedKey !== key) {
	                                _logger.error(
	                                    `Warning: DataServiceMock::setValues double key detected: ${key} is the same as ${mappedKey}!`
	                                );
	                            } else {
	                                _logger.error(`Warning: DataServiceMock::setValues double key detected: ${key}`);
	                            }
	                        }
	                    } else {
	                        errorMessage = "DataServiceMock::setValues() argument keys contains null or undefined.";
	                        break;
	                    }
	                }
	                // check for potential argument error
	                if(overallKeysLen > MAX_LEN_REQUESTED_KEYS || uniqueKeys.length > MAX_COUNT_REQUESTED_KEYS) {
	                    errorMessage = `DataServiceMock::setValues() too many or too long property keys argument requested. Please check your keys array argument. Number of keys argument requested: ${uniqueKeys.length}, string len: ${overallKeysLen}`;
	                } else if(overallValuesLen > MAX_LEN_REQUESTED_VALUES) {
	                    errorMessage = `DataServiceMock::setValues() too long values argument requested. Please check your values array argument. Number of values argument requested: ${correspondingValues.length}, string len: ${overallValuesLen}`;
	                }
	            }

	            if(errorMessage) {
	                _logger.error(errorMessage);
	                Wincor.UI.Service.Provider.propagateError("DataService::setValues", this.ERROR_TYPE.REQUEST);
	            } else {
	                // update data:
	                keys = uniqueKeys;
	                values = correspondingValues;
	                // Note:
	                // Business data are context dependent. They are stored like this:
	                // CCTAFW_PROP_GENERIC_LIST_SELECTION_JSON_GROUPS: { "*": "", "ReceiptPreferenceMultipleChoiceSelection": {...}}.
	                // Whereas a simple view state property like VAR_VOUCHER_VIEWSTATE_S: { "*": "0" } is usually context independent.
	                // Because the extended design mode has only a simple business logic simulation the data are
	                // stored either view key dependent or independent.
	                // To be in the right context several properties are stored view key specific.
	                // For example the property "CCTAFW_PROP_GENERIC_LIST_SELECTION_JSON_GROUPS" is a generic property, but the values are context
	                // dependent which is a specific view key like "ReceiptPreferenceMultipleChoiceSelection".
	                // If the setting would be generic, a getValues call for another context would get the data from a setting before, which would be
	                // wrong in such a case.
	                // Note:
	                // CCTAFW_PROP_CURRENCY[0] is always the same as CCTAFW_PROP_CURRENCY, even that property isn't an index based one!
	                // ControlPanel: We will store the property as CCTAFW_PROP_CURRENCY, even the request was CCTAFW_PROP_CURRENCY[0]!
	                for(let i = 0; i < keys.length; ++i) {
	                    let viewKey = _viewService.viewContext.viewKey;
	                    let key = keys[i];
	                    if(key in _businessData) {
	                        // value exist with the current view key? (in such a case the value has been red with the same view key before)
	                        // or store unspecific to allow access view key independent "*"
	                        let candidate = _businessData[key][_businessData[key][viewKey] ? viewKey : "*"];
	                        // check whether the property is an array, in that case we have to set the zero index
	                        if(candidate !== void 0 && !Array.isArray(candidate)) {
	                            _businessData[key][_businessData[key][viewKey] ? viewKey : "*"] = values[i];
	                        } else {
	                            candidate[0] = values[i];
	                        }
	                        _usedBusinessProperties.set(key, values[i]);
	                    } else {
	                        // key maybe contain an index with ...[1] which is often the case for indexed based properties or even a JSON attribute access notation
	                        // check for something like "CCCHCCDMTAFW_CHEQUE_ACCEPTED[idx] or CCCHCCDMTAFW_CHEQUE_ACCEPTED.id[idx]"
	                        // don't accept something like "CCTAFW_PROP_EMV_APPLICATION_SELECTION_LISE_DATA[A,0,2]" which is for LISE concept
	                        let parts = this.extractKeyPartsFromProperty(key);
	                        if(parts.index !== -1 || parts.attrChain) {
	                            key = parts.key;
	                            if(key in _businessData) {
	                                // value exist with the current view key? (in such a case the value has been red with the same view key before)
	                                // or store unspecific to allow access view key independent "*"
	                                viewKey = _businessData[key][viewKey] ? viewKey : "*";
	                                if(_businessData[key][viewKey]) {
	                                    let attrChain = parts.attrChain;
	                                    // ControlPanel->properties tab: In order to not store every kind (CCTAFW_PROP_CURRENCY[0], CCTAFW_PROP_CURRENCY[999], see exception below,
	                                    // CCTAFW_PROP_CURRENCY.id[0]) of property access we use the plain key name (CCTAFW_PROP_CURRENCY) always, because
	                                    // otherwise we can't easily update the list of properties (referencing the same raw value)
	                                    // when updated a value using the plain (CCTAFW_PROP_CURRENCY) or any other access (CCTAFW_PROP_CURRENCY[999], etc.) method.
	                                    // Otherwise its possible using the original name by uncommenting this line and setting the -name instead of the -key:
	                                    // let name = this.buildKeyFromParts(parts);
	                                    if(Array.isArray(_businessData[key][viewKey])) {
	                                        let index = parts.idx;
	                                        if(attrChain) {
	                                            // value is expected as JSON
	                                            let candidate = _businessData[key][viewKey][index];
	                                            _businessData[key][viewKey][index] = this.setValueFromJSON(candidate, attrChain, values[i]);
	                                            if(_businessData[key][viewKey][index] !== candidate) {
	                                                // do we have successfully updated?
	                                                _usedBusinessProperties.set(key, values[i]);
	                                            }
	                                        } else {
	                                            _businessData[key][viewKey][index] = values[i];
	                                            // Store also indexed based also, except the [0] key
	                                            _usedBusinessProperties.set(parts.idx === 0 ? key : this.buildKeyFromParts(parts), values[i]);
	                                        }
	                                    } else {
	                                        if(attrChain) {
	                                            // value is expected as JSON
	                                            let candidate = _businessData[key][viewKey];
	                                            _businessData[key][viewKey] = this.setValueFromJSON(candidate, attrChain, values[i]);
	                                            if(_businessData[key][viewKey] !== candidate) {
	                                                // do we have successfully updated?
	                                                _usedBusinessProperties.set(key, values[i]);
	                                            }
	                                        } else {
	                                            _businessData[key][viewKey] = values[i];
	                                            _usedBusinessProperties.set(key, values[i]);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	                this.fireServiceEvent(this.SERVICE_EVENTS.DATA_CHANGED, { keys: keys, values: values });
	                _controlPanelService.updateBusinessProperties(_usedBusinessProperties);
	            }
	            this.callbackCaller(callback);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< DataServiceMock::setValues");
	        }

	        /**
	         * Updates the given key array with the corresponding values array.
	         * @param {Array<string> | String} keys either an array or a plain string with the property name(s)
	         * @param {Array<string>  | String} values either an array or a plain string with the value(s)
	         * @param {function=} callback
	         */
	        updateValues(keys, values, callback) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> DataServiceMock::updateValues(${keys}, ${values})`);
	            keys = Array.isArray(keys) ? keys : [keys];
	            keys = this.mapKeys(keys);
	            // we set the properties before we call the updates
	            this.setValues(keys, values, callback);
	            if(!Array.isArray(values)) {
	                values = [values];
	            }
	            for(let k = 0; k < keys.length; k++) {
	                let key = keys[k];
	                for(let i = 0; i < _dataRegistrators.length; i++) {
	                    let dataReg = _dataRegistrators[i];
	                    let keys = dataReg.keys;
	                    for(let j = 0; j < keys.length; j++) {
	                        if(keys[j] === key) {
	                            _logger.log(
	                                _logger.LOG_ANALYSE,
	                                `. DataServiceMock::updateValues found property=${key} has been updated with value=${values[k]}`
	                            );
	                            let result = {}; //build the object
	                            if(keys[j] in dataReg.keyMap) {
	                                // must replace the business key by the original requested key?
	                                result[dataReg.keyMap[keys[j]]] = values[k];
	                            } else {
	                                result[keys[j]] = values[k];
	                            }
	                            dataReg.onUpdate(result); //call the callback with the object
	                        }
	                    }
	                }
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, "< DataServiceMock::updateValues");
	        }

	        /**
	         * This method is called by the service-provider if an error occurred in any service
	         * @eventhandler
	         * @param {String} serviceName
	         * @param {String} errorType
	         */
	        onError(serviceName, errorType) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> DataServiceMock::onError(${serviceName}, ${errorType})`);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< DataServiceMock::onError");
	        }

	        /**
	         * This will read (again) all data from the JSON files.
	         * This was originally done in onSetup, but now moved into a separate function, to be called anytime.
	         *
	         * @async
	         */
	        async updateJSONData() {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> DataServiceMock::updateJSONData()");
	            let [profile, profileExtension] = await this.getToolingProfile();
	            _logger.log(_logger.LOG_DATA, `. DataServiceMock::updateJSONData profile=${profile}`);
	            const fileUIKeyMap = "../servicedata/UIPropertyKeyMap.json";
	            const fileBusinessData = `../servicemocks/mockdata/BusinessData${profileExtension}.json`;
	            const fileBusinessDataCustom = "../servicemocks/mockdata/BusinessDataCustom.json";
	            const fileBusinessKeys = "../servicedata/BusinessPropertyKeyMap.json";
	            const fileBusinessCustomKeys = "../servicedata/BusinessPropertyCustomKeyMap.json";
	            try {
	                let dataArray = await Promise.all([
	                    this.retrieveJSONData(fileBusinessData),
	                    this.retrieveJSONData(fileBusinessDataCustom),
	                    this.retrieveJSONData(fileBusinessKeys),
	                    this.retrieveJSONData(fileBusinessCustomKeys),
	                    this.retrieveJSONData(fileUIKeyMap)
	                ]);
	                delete dataArray[1]["//"]; // remove possible comment
	                _businessData = Object.assign(dataArray[0], dataArray[1]); // standard props with custom specific ones
	                delete dataArray[3]["//"]; // remove possible comment
	                _businessPropKeyMap = Object.assign(dataArray[2], dataArray[3]); // standard keys with custom specific ones
	                this.UIPropertyKeys = dataArray[4];
	                this.businessData = _businessData;
	                _logger.log(_logger.LOG_SRVC_INOUT, "< DataServiceMock::updateJSONData");
	            } catch(e) {
	                _logger.error(
	                    `* importReference error getting ${fileUIKeyMap}, ${fileBusinessData}, ${fileBusinessKeys}, ${fileBusinessDataCustom} or ${fileBusinessCustomKeys}`
	                );
	                throw e;
	            }
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * In addition it will call _updateJSONData_ to read the JSON files.
	         *
	         * @param {object} message      See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onSetup(message) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> DataServiceMock::onSetup('${JSON.stringify(message)}')`);
	            return new Promise((resolve, reject) => {
	                this.updateJSONData()
	                    .then(() => {
	                        _logger.log(_logger.LOG_SRVC_INOUT, "< DataServiceMock::onSetup");
	                        resolve();
	                    })
	                    .catch(e => {
	                        reject(e);
	                    });
	            });
	        }

	        /**
	         * @see {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}
	         * @async
	         * @lifecycle service
	         */
	        async onServicesReady() {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> DataServiceMock::onServicesReady()");
	            _controlPanelService = this.serviceProvider.ControlPanelService;
	            _configService = this.serviceProvider.ConfigService;
	            _viewService = this.serviceProvider.ViewService;
	            _viewService.registerForServiceEvent(
	                _viewService.SERVICE_EVENTS.VIEW_CLOSING,
	                () => {
	                    this.cleanDataRegistrations();
	                    this.propertyHandler = null;
	                },
	                true
	            );
	            _viewService.registerForServiceEvent(_viewService.SERVICE_EVENTS.SHUTDOWN, this.cleanDataRegistrations.bind(this), true);
	            await super.onServicesReady();
	            _logger.log(_logger.LOG_SRVC_INOUT, "< DataServiceMock::onServicesReady");
	        }

	        /**
	         * Callback for DataService~setPropertyHandler.
	         * @callback propertyHandlerCallback
	         * @async
	         * @param {object} propertyInfo The propertyInfo object
	         * @param {string} propertyInfo.key The name of the property to resolve
	         * @param {string} propertyInfo.value THe name of the property to resolve
	         * @returns {Promise<undefined|boolean>}
	         */

	        /**
	         * Adds a handler function to string property handlers
	         * @param {propertyHandlerCallback|null} handlerFx The handler function or null to reset
	         * @returns {boolean} success
	         */
	        setPropertyHandler(handlerFx) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> DataServiceMock::setPropertyHandler(...)`);
	            let ret = false;
	            if(!this.propertyHandler && typeof handlerFx === "function") {
	                const handler = handlerFx;
	                ret = true;
	                this.propertyHandler = (...args) => {
	                    try {
	                        return handler(...args);
	                    } catch(e) {
	                        _logger.error(
	                            `Error DataServiceMock: propertyHandler: ${handler ? handler.toString() : "<invalid_handler>"
                            } caught ${JSON.stringify(e)}`
	                        );
	                    }
	                };
	            } else {
	                if(handlerFx == null) {
	                    this.propertyHandler = null;
	                    _logger.error(`DataServiceMock::setPropertyHandler resetting handlerFx`);
	                    ret = true;
	                } else if(this.propertyHandler) {
	                    _logger.error(`DataServiceMock::setPropertyHandler handler already set!`);
	                } else {
	                    _logger.error(`DataServiceMock::setPropertyHandler argment is not a function!`);
	                }
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< DataServiceMock::setPropertyHandler returns id <${ret}>`);
	            return ret;
	        }

	        /**
	         * This function can be called from outside the UI to retrieve arbitrary viewModel data as a property!
	         * The functionality relies on a naming convention regarding the attribute name and context to access.
	         * Naming convention is defined as follows:
	         * GUIINSTANCENAME_ATTRIBUTENAME_CONTEXTNAME, where "GUIINSTANCENAME_" will be cut by gui.dll and not arrive here!
	         * This automatic value resolution via naming convention heavily relies on a correct case-sensitive spelling, therefore mappings can be
	         * used within the file "core/servicedata/businessPropertyKeyMap.json"
	         * For CONTEXTNAME the "observableAreaId" of a corresponding viewModel can be given so that a valid name could be:
	         * "GUIAPP_flexHeader.date". Service attributes can also be accessed if exposed via proxy using the servicename as context like:
	         * "ViewService.viewContext.viewConfig"
	         * The result will be send back to the native part as response containing the stringified value of the attribute or null if it does not exist.
	         * @param {object} message message containing request-data
	         * @param {string} message.propertyName contains the propertyName - has to follow the above naming convention
	         * @param {string} message.propertyValue will be set to the value of the property, unchanged if not found...
	         * @return {string | null} value for internal requests
	         */
	        getPropertyString(message) {
	            const _logger = this.logger;
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `> DataServiceMock::getPropertyString(${JSON.stringify(message)})`);
	            let name = message.propertyName || "";
	            let value = null;
	            let ret;
	            // filter probably instance name from prop key
	            if(name.startsWith(_configService.configuration.instanceName)) {
	                name = name.substr(_configService.configuration.instanceName.length + 1);
	            }
	            // try to get it from mapping, otherwise try to disassemble directly
	            name = this.UIPropertyKeys[name] || name;
	            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. after mapping: ${name}`);
	            if(!name) {
	                _logger.error(
	                    "DataServiceMock::getPropertyString argument 'message' is invalid: Expect an object with at least attribute 'propertyName' !"
	                );
	                return "";
	            }
	            const prop = { key: name, value: undefined };
	            let handled = false;
	            if(this.propertyHandler) {
	                handled = this.propertyHandler(prop);
	            }

	            if(handled) {
	                // any invalid falsish value is reset to ""
	                if(!prop.value) {
	                    _logger.LOG_DETAIL &&
	                        _logger.log(
	                            _logger.LOG_DETAIL,
	                            `. DataService::getPropertyString propertyHandler returned invalid value <${prop.value}> resetting to ''`
	                        );
	                    prop.value = "";
	                }
	                _logger.LOG_DETAIL &&
	                    _logger.log(_logger.LOG_DETAIL, `. DataService::getPropertyString propertyHandler returned <${prop.value}>`);
	                value = prop.value;
	            } else {
	                // now we have: flexHeader.date -> first index is context, next attributes might be more than one for nested objects... walk structure hierarchy
	                let parts = name.split(".");
	                let contextName = parts.splice(0, 1)[0]; // pop first entry as context
	                let context = Wincor.UI.Service.Provider[contextName];

	                if(!context) {
	                    // it wasn't a service, look for specials
	                    if(contextName.indexOf("Wincor") === 0) {
	                        context = Wincor;
	                    } else if(contextName.indexOf("window") === 0) {
	                        context = window.frames[0];
	                    }
	                }

	                // If there is a viewset switch active, we won't have "Content" available!
	                if(!context && Wincor.UI.Content && Wincor.UI.Content.ViewModelContainer) {
	                    // at last try if there is an observable area / vm with this name...
	                    context = Wincor.UI.Content.ViewModelContainer.getById(contextName);
	                }

	                if(context) {
	                    value = parts.reduce(function(c, a) {
	                        if(c && a in c) {
	                            try {
	                                if(typeof c[a] === "function" && "__ko_proto__" in c[a]) {
	                                    return c[a]();
	                                } else {
	                                    return c[a];
	                                }
	                            } catch(e) {
	                                _logger.error(`DataServiceMock::getPropertyString exception during attribute evaluation: '${e.message}'`);
	                            }
	                        }
	                        return void 0;
	                    }, context);
	                }
	            }

	            if(value !== void 0 && value !== null) {
	                message.propertyValue = value.toString();
	                ret = this.REQUEST_RESPONSE_OK;
	            } else {
	                let err = name;
	                if(message.propertyName !== name) {
	                    err = `${message.propertyName}' aka '${name}`;
	                }
	                _logger.LOG_DETAIL &&
	                    _logger.log(_logger.LOG_DETAIL, `DataServiceMock::getPropertyString attribute could not be found for: '${err}'`);
	                ret = "-1";
	            }

	            if(value !== null && typeof value === "object") {
	                try {
	                    value = JSON.stringify(value);
	                } catch(e) {
	                    value = value.toString();
	                }
	            }

	            _logger.LOG_DETAIL &&
	                _logger.log(_logger.LOG_DETAIL, `< DataServiceMock::getPropertyString returns ${ret} data: ${JSON.stringify(message)}`);
	            return value;
	        }
	    };
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ DataServiceInterface.js 4.3.1-210212-21-06af7f4f-1a04bc7d
	*/

	const ServiceClass$k = getServiceClass$n({
	    Wincor: Wincor$2,
	    BaseService: BaseService$1,
	    LogProvider
	});

	const ServiceInterface$k = {
	    DataProxy: {
	        interface: {
	            SERVICE_EVENTS: {
	                type: "object",
	                keys: ["DATA_CHANGED"],
	                writable: false
	            },
	            getPropertyKeyMap: {
	                type: "function"
	            },
	            getDataRegistrations: {
	                type: "function"
	            },
	            getValues: {
	                type: "function",
	                callbackArgumentIndex: 1
	            },
	            setValues: {
	                type: "function",
	                callbackArgumentIndex: 2
	            },
	            updateValues: {
	                type: "function"
	            },
	            businessData: {
	                type: "object",
	                writable: false
	            },
	            getPropertyString: {
	                comment: "This is only for  being able to test the function without application, normally designMode does not need it...",
	                type: "function",
	                external: true,
	                internal: true
	            },
	            propResolver: {
	                type: "function"
	            },
	            getPropValue: {
	                type: "function"
	            },
	            updateJSONData: {
	                type: "function"
	            },
	            setPropertyHandler: {
	                type: "function"
	            }
	        }
	    }
	};

	var DataService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$k,
		ServiceClass: ServiceClass$k
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.EppServiceMock.js 4.3.1-210420-21-c476740e-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$o = ({ BaseService, ext, LogProvider }) => {
	    const _logger = LogProvider;

	    let _claimId = 0;

	    /**
	     * Map containing registered callbacks key-pressed events of claimed keys
	     * @type {Map}
	     * @private
	     */
	    const _eppKeyPressed2CallbackMap = new Map();

	    /**
	     * Map containing registered callbacks for status changes of claimed keys
	     * @type {Map}
	     * @private
	     */
	    const _eppKeyStatusChanged2CallbackMap = new Map();

	    function strMapToObj(strMap) {
	        let obj = {};
	        for(let [k,v] of strMap) {
	            // We don’t escape the key '__proto__'
	            // which can cause problems on older engines
	            obj[k] = v;
	        }
	        return obj;
	    }

	    return class EppServiceMock extends BaseService {

	        /**
	         * "EppServiceMock" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "EppService";

	        /**
	         * Epp button F1
	         * @const
	         */
	        BUTTONEPP_F1 = "F1";
	        /**
	         * Epp button F2
	         * @const
	         */
	        BUTTONEPP_F2 = "F2";
	        /**
	         * Epp button F3
	         * @const
	         */
	        BUTTONEPP_F3 = "F3";
	        /**
	         * Epp button F4
	         * @const
	         */
	        BUTTONEPP_F4 = "F4";
	        /**
	         * Epp button F5
	         * @const
	         */
	        BUTTONEPP_F5 = "F5";
	        /**
	         * Epp button F6
	         * @const
	         */
	        BUTTONEPP_F6 = "F6";
	        /**
	         * Epp button F7
	         * @const
	         */
	        BUTTONEPP_F7 = "F7";
	        /**
	         * Epp button F8
	         * @const
	         */
	        BUTTONEPP_F8 = "F8";
	        /**
	         * Epp button F9
	         * @const
	         */
	        BUTTONEPP_F9 = "F9";
	        /**
	         * Epp button 0
	         * @const
	         */
	        BUTTONEPP_0 = "0";
	        /**
	         * Epp button 1
	         * @const
	         */
	        BUTTONEPP_1 = "1";
	        /**
	         * Epp button 2
	         * @const
	         */
	        BUTTONEPP_2 = "2";
	        /**
	         * Epp button 3
	         * @const
	         */
	        BUTTONEPP_3 = "3";
	        /**
	         * Epp button 4
	         * @const
	         */
	        BUTTONEPP_4 = "4";
	        /**
	         * Epp button 5
	         * @const
	         */
	        BUTTONEPP_5 = "5";
	        /**
	         * Epp button 6
	         * @const
	         */
	        BUTTONEPP_6 = "6";
	        /**
	         * Epp button 7
	         * @const
	         */
	        BUTTONEPP_7 = "7";
	        /**
	         * Epp button 8
	         * @const
	         */
	        BUTTONEPP_8 = "8";
	        /**
	         * Epp button 9
	         * @const
	         */
	        BUTTONEPP_9 = "9";
	        /**
	         * Epp button CONFIRM
	         * @const
	         */
	        BUTTONEPP_CONFIRM = "CONFIRM";
	        /**
	         * Epp button CANCEL
	         * @const
	         */
	        BUTTONEPP_CANCEL = "CANCEL";
	        /**
	         * Epp button HELP
	         * @const
	         */
	        BUTTONEPP_HELP = "HELP";
	        /**
	         * Epp button CLEAR
	         * @const
	         */
	        BUTTONEPP_CLEAR = "CLEAR";
	        /**
	         * Epp button BACKSPACE
	         * @const
	         */
	        BUTTONEPP_BACKSPACE = "BACKSPACE";
	        /**
	         * Epp button *
	         * @const
	         */
	        BUTTONEPP_STAR = "*";
	        /**
	         * Epp button CORRECT
	         * @const
	         */
	        BUTTONEPP_CORRECT = "CORRECT";
	        /**
	         * Epp button EDIT
	         * @const
	         */
	        BUTTONEPP_EDIT = "EDIT";
	        /**
	         * Epp button R (right)
	         * @const
	         */
	        BUTTONEPP_R = "R";
	        /**
	         * Epp button L (left)
	         * @const
	         */
	        BUTTONEPP_L = "L";

	        /**
	         * Define from the Gui.dll for the callback function id for pressed eppkey
	         * @const
	         */
	        GUI_COMM_CALLBACK_EPPKEY_PRESSED = 98;
	        /**
	         * Define from the Gui.dll for the callback function id for a status change of a claimed eppkey
	         * @const
	         */
	        GUI_COMM_CALLBACK_EPPCLAIM_STATUS_CHANGE = 99;

	        CLAIMSTATUS_DENIED = "DENIED";
	        CLAIMSTATUS_ENABLED = "ENABLED";
	        CLAIMSTATUS_DISABLED = "DISABLED";
	        CLAIMSTATUS_DENIED_BUT_ENABLED = "DENIED_BUT_ENABLED";
	        CLAIMSTATUS_DENIED_BUT_DISABLED = "DENIED_BUT_DISABLED";

	        claimingData = new Map([
	            ["F1", {"status": "RELEASED", "claims": 0}],
	            ["F2", {"status": "RELEASED", "claims": 0}],
	            ["F3", {"status": "RELEASED", "claims": 0}],
	            ["F4", {"status": "RELEASED", "claims": 0}],
	            ["F5", {"status": "RELEASED", "claims": 0}],
	            ["F6", {"status": "RELEASED", "claims": 0}],
	            ["F7", {"status": "RELEASED", "claims": 0}],
	            ["F8", {"status": "RELEASED", "claims": 0}],
	            ["1", {"status": "RELEASED", "claims": 0}],
	            ["2", {"status": "RELEASED", "claims": 0}],
	            ["3", {"status": "RELEASED", "claims": 0}],
	            ["4", {"status": "RELEASED", "claims": 0}],
	            ["5", {"status": "RELEASED", "claims": 0}],
	            ["6", {"status": "RELEASED", "claims": 0}],
	            ["7", {"status": "RELEASED", "claims": 0}],
	            ["8", {"status": "RELEASED", "claims": 0}],
	            ["9", {"status": "RELEASED", "claims": 0}],
	            ["0", {"status": "RELEASED", "claims": 0}],
	            ["*", {"status": "RELEASED", "claims": 0}],
	            ["CANCEL", {"status": "RELEASED", "claims": 0}],
	            ["CONFIRM", {"status": "RELEASED", "claims": 0}],
	            ["CORRECT", {"status": "RELEASED", "claims": 0}],
	            ["CLEAR", {"status": "RELEASED", "claims": 0}],
	            ["BACKSPACE", {"status": "RELEASED", "claims": 0}],
	            ["HELP", {"status": "RELEASED", "claims": 0}],
	            ["EDIT", {"status": "RELEASED", "claims": 0}],
	            ["R", {"status": "RELEASED", "claims": 0}],
	            ["L", {"status": "RELEASED", "claims": 0}]
	        ]);

	        /**
	         * Object containing the definitions of view-service events other services or view-models  may register for.
	         */
	        SERVICE_EVENTS = {
	            /**
	             * Sent if the claim status of any key changed.
	             * @example
	             * {
	             *  "F1":{
	             *          status: "ENABLED",  // tells if the current claiming is ENABLED/DISABLED due to higher prioritized claims of other UI instance
	             *          claims: 3           // number of claims due to e.g. popUp
	             *      }
	             * }
	             * @event Wincor.UI.Service.EppServiceMock#SERVICE_EVENTS:CLAIM_STATUS_CHANGED
	             * @eventtype service
	             */
	            CLAIM_STATUS_CHANGED: "CLAIM_STATUS_CHANGED"
	        };

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.log(_logger.LOG_SRVC_INOUT, "> EppServiceMock::EppServiceMock");
	            _logger.log(_logger.LOG_SRVC_INOUT, "< EppServiceMock::EppServiceMock");
	        }

	        /**
	         * This method is called by the service-provider if an error occurred in any service
	         * @eventhandler
	         * @param {String} serviceName
	         * @param {String} errorType
	         */
	        onError(serviceName, errorType) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> EppServiceMock::onError(${serviceName}, ${errorType})`);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< EppServiceMock::onError");
	        }

	        fireClaimStatusChanged(updateData) {
	            updateData = updateData || {};
	            _logger.log(_logger.LOG_SRVC_INOUT, `> EppServiceMock::fireClaimStatusChanged('${JSON.stringify(updateData)}')`);

	            /*
	             * Sample data:
	             * {
	             *  "F1":{
	             *          status: "ENABLED",  // tells if the current claiming is ENABLED/DISABLED due to higher prioritized claims of other UI instance
	             *          claims: 3           // number of claims due to e.g. popUp
	             *      }
	             * }
	             *
	             * */
	            if(Object.keys(updateData).length > 0) {
	                for(let [key, value] of this.claimingData) {
	                    let data = updateData[key];
	                    if(data) {
	                        if("status" in data) {
	                            value.status = data.status;
	                        }
	                        if("claims" in data) {
	                            value.claims = data.claims;
	                        }
	                    }

	                }
	            }
	            if(this.claimingData.size > 0) {
	                // JSON parse/stringify is really fast
	                this.fireServiceEvent(this.SERVICE_EVENTS.CLAIM_STATUS_CHANGED, jQuery.extend(true, {}, strMapToObj(this.claimingData)));
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, "< EppServiceMock::fireClaimStatusChanged");
	        }

	        /**
	         * Claim keys that should be able to use.
	         * @param {Array} keys "F1","F2","F3","F4","F5","F6","F7","F8","F9", "0","1","2","3","4","5","6","7","8","9","R","L", "CONFIRM","CANCEL","HELP","CLEAR","BACKSPACE", "*"
	         * @param {int} prio -1=configured prio
	         * @param {function=} callbackClaim function pointer
	         * @param {function=} callbackKeyPressedEvent
	         * @param {function=} callbackClaimStatusChange
	         */
	        claimKeys(keys, prio, callbackClaim, callbackKeyPressedEvent, callbackClaimStatusChange) {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> EppServiceMock::claimKeys(keys: " + keys + ", prio:" + prio);
	            let updateData = {}, claims, i, key;
	            _claimId++;
	            // save to key -> callback mapping!
	            for(i = 0; i < keys.length; i++) {
	                key = keys[i];
	                if(!_eppKeyPressed2CallbackMap.has(key)) {
	                    _eppKeyPressed2CallbackMap.set(key, [{id: _claimId, callback: callbackKeyPressedEvent}]);
	                }
	                else {
	                    _logger.log(_logger.LOG_DETAIL, ". already claimed key: '" + key + "'. Adding callback...");
	                    _eppKeyPressed2CallbackMap.get(key).push({id: _claimId, callback: callbackKeyPressedEvent});
	                }
	                if(callbackClaimStatusChange) {
	                    if(!_eppKeyStatusChanged2CallbackMap.has(key)) {
	                        _eppKeyStatusChanged2CallbackMap.set(key, [{id: _claimId, callback: callbackClaimStatusChange}]);
	                    }
	                    else {
	                        _logger.log(_logger.LOG_DETAIL, ". already claimed key: '" + key + "'. Adding callback...");
	                        _eppKeyStatusChanged2CallbackMap.get(key).push({id: _claimId, callback: callbackClaimStatusChange});
	                    }
	                }
	            }

	            let callbackRet = {claimId: _claimId};

	            for(i = 0; i < keys.length; i++) {
	                callbackRet[keys[i]] = "ENABLED";
	                // add unknown EPP keys to the map to be more flexible for enhanced/different EPP types
	                if(!this.claimingData.has(keys[i])) {
	                    this.claimingData.set(keys[i], {"status": "RELEASED", "claims": 0});
	                }
	                claims = this.claimingData.get(keys[i]).claims + 1;
	                updateData[keys[i]] = {
	                    status: "ENABLED",
	                    claims: claims
	                };
	            }

	            if(callbackClaim) {
	                window.setTimeout(callbackClaim.bind(null, callbackRet), 1);
	            }
	            this.fireClaimStatusChanged(updateData);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< EppServiceMock::claimKeys");
	        }

	        /**
	         * Release claimed keys after usage.
	         * @param {number} claimId The id returned by the claim result member result.claimId
	         * @param {function=} callback function pointer
	         */
	        releaseKeys(claimId, callback) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "> EppService::releaseKeys(" + claimId + ")");
	            if (claimId < 0) {
	                this.logger.error("EPPService::releaseKeys invalid claimId " + claimId + " given callback: \n" + callback);
	            }
	            //var keys = keysArray.slice();
	            let keysToRelease = [];
	            let doRelease = false;
	            // remove from key -> callback mapping!
	            let updateData = {};

	            // walk through map and find the entries with the claim id
	            let claims;
	            for (let [key, resultsArray] of _eppKeyPressed2CallbackMap) {
	                resultsArray = resultsArray.filter(entry => entry.id !== claimId);
	                claims = resultsArray.length;
	                if (claims > 0) {
	                    _eppKeyPressed2CallbackMap.set(key, resultsArray);
	                } else {
	                    _eppKeyPressed2CallbackMap.delete(key);
	                }

	                updateData[key] = {
	                    claims: claims
	                };
	                this.logger.log(this.logger.LOG_SRVC_DATA, ". EppService::releaseKeys remaining callbacks for "+key+": "+claims);
	                if (claims === 0) {
	                    keysToRelease.push(key);
	                    doRelease = true;
	                    updateData[key].status = "RELEASED";
	                }

	                if (_eppKeyStatusChanged2CallbackMap.has(key)) {
	                    resultsArray = _eppKeyStatusChanged2CallbackMap.get(key).filter(entry => entry.id !== claimId);
	                    if (resultsArray.length > 0) {
	                        _eppKeyStatusChanged2CallbackMap.set(key, resultsArray);
	                    } else {
	                        _eppKeyStatusChanged2CallbackMap.delete(key);
	                    }
	                }
	            }

	            this.fireClaimStatusChanged(updateData);

	            if (doRelease) {
	                this.logger.log(this.logger.LOG_SRVC_DATA, ". releasing keys -> " + keysToRelease);
	            }
	            if (callback) {
	                window.setTimeout(callback, 1);
	            }
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< EppService::releaseKeys");
	        }

	        /**
	         * Get number of FDKs available on this machine
	         * @returns {number}
	         * @async
	         */
	        async getNumberOfFDKs() {
	            return 8;
	        }
	        
	        /**
	         * Called by the gateway whenever an event is received from the business-logic.
	         * Override in subclass.
	         * @param {object} message
	         * @eventhandler
	         */
	        onEvent(message) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> EppServiceMock::onEvent('${JSON.stringify(message)}')`);
	            if(message.methodName === "KeyPressed") {
	                //check for registered callbacks for this key
	                if(_eppKeyPressed2CallbackMap.has(message.key)) {
	                    let delegates = _eppKeyPressed2CallbackMap.get(message.key);
	                    if(delegates) {
	                        // The new claim handling expects all handlers to be informed
	                        let activeFunctionCalled = false;
	                        let beepAllowedFromCallbacks = true;
	                        delegates.forEach(delegateObj => {
	                            try {
	                                // delegates can return "true" if an action was done that requires us to beep
	                                let ret = delegateObj.callback(message.key);
	                                if (ret === false) {
	                                    // callbacks can explicitly silence beeping by returning "false"
	                                    // no direct assignment to ret here, because of different meaning of false and undefined
	                                    beepAllowedFromCallbacks = false;
	                                }
	                                activeFunctionCalled |= ret;
	                            } catch(e) {
	                                _logger.error(`Epp event ${message.key} caught exception ${e.message} for ${delegateObj.callback}`);
	                            }
	                        });
	                        const beepService = this.serviceProvider.BeepService;
	                        const adaService = this.serviceProvider.AdaService;
	                        const eppInactiveKeyCode = beepService.beepInactiveKeyCode;
	                        // Beep warning if ADA not ON, basically the BeepService checks whether beeping is allowed!
	                        // Before we beep a warning we have to be aware of the fact whether this execution source was really an EPP key event and not any other,
	                        // e.g. programmatically calls of command execute!
	                        // We assume that a command which is claimed owns a valid claim id.
	                        if(beepAllowedFromCallbacks && adaService.state !== adaService.STATE_VALUES.SPEAK) {
	                            if(activeFunctionCalled) {
	                                beepService.beep(); // warning beep
	                            } else {
	                                _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. EppServiceMock::onEvent trigger warning beep for inactive EPP key '${message.key}' with beep code=${eppInactiveKeyCode}`);
	                                beepService.beep(eppInactiveKeyCode); // warning beep
	                            }
	                        } else {
	                            _logger.LOG_DETAIL && _logger.log(_logger.LOG_DETAIL, `. EppServiceMock::onEvent ada active, skipping beep`);
	                        }
	                    } else {
	                        _logger.log(_logger.LOG_DETAIL, `. KeyPressed(): delegate for key: '${message.key}' is null.`);
	                    }
	                } else {
	                    _logger.log(_logger.LOG_DETAIL, `. KeyPressed(): No callback found for key: '${message.key}'.`);
	                }
	                _logger.log(_logger.LOG_SRVC_INOUT, "< EppServiceMock::onEvent");
	            }
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         *
	         * @param {object} message      See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onSetup(message) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> EppServiceMock::onSetup('${JSON.stringify(message)}')`);
	            return ext.Promises.promise(resolve => {
	                resolve();
	                _logger.log(_logger.LOG_SRVC_INOUT, "< EppServiceMock::onSetup");
	            });
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onServicesReady() {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> EppServiceMock::onServicesReady()");
	            return ext.Promises.promise(resolve => {
	                let viewService = this.serviceProvider.ViewService;
	                viewService.registerForServiceEvent(viewService.SERVICE_EVENTS.SHUTDOWN, () => {
	                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "* EppServiceMock::onServicesReady() content shutdown in progress - release all EPP keys");
	                    let tempEppKeyPressed2CallbackMap = new Map(_eppKeyPressed2CallbackMap);
	                    for(let [key, resultsArray] of tempEppKeyPressed2CallbackMap) {
	                        resultsArray.forEach(item => {
	                            this.releaseKeys(item.id);
	                        });
	                    }
	                    _eppKeyPressed2CallbackMap.clear();
	                    _eppKeyStatusChanged2CallbackMap.clear();
	                }, true);
	                super.onServicesReady().then(resolve);
	                _logger.log(_logger.LOG_SRVC_INOUT, "< EppServiceMock::onServicesReady");
	            });
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ EppServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/


	const ServiceClass$l = getServiceClass$o({
	    BaseService: BaseService$1,
	    ext: ext$3,
	    LogProvider
	});

	const ServiceInterface$l = {
	    EppProxy: {
	        service: "../service/wn.UI.Service.EppService.js",
	        interface: {
	            Expand_StringDefines: {
	                attributes: [
	                    "BUTTONEPP_F1",
	                    "BUTTONEPP_F2",
	                    "BUTTONEPP_F3",
	                    "BUTTONEPP_F4",
	                    "BUTTONEPP_F5",
	                    "BUTTONEPP_F6",
	                    "BUTTONEPP_F7",
	                    "BUTTONEPP_F8",
	                    "BUTTONEPP_F9",
	                    "BUTTONEPP_0",
	                    "BUTTONEPP_1",
	                    "BUTTONEPP_2",
	                    "BUTTONEPP_3",
	                    "BUTTONEPP_4",
	                    "BUTTONEPP_5",
	                    "BUTTONEPP_6",
	                    "BUTTONEPP_7",
	                    "BUTTONEPP_8",
	                    "BUTTONEPP_9",
	                    "BUTTONEPP_CONFIRM",
	                    "BUTTONEPP_CANCEL",
	                    "BUTTONEPP_HELP",
	                    "BUTTONEPP_CLEAR",
	                    "BUTTONEPP_BACKSPACE",
	                    "BUTTONEPP_STAR",
	                    "BUTTONEPP_CORRECT",
	                    "BUTTONEPP_EDIT",
	                    "BUTTONEPP_R",
	                    "BUTTONEPP_L",
	                    "CLAIMSTATUS_DENIED",
	                    "CLAIMSTATUS_ENABLED",
	                    "CLAIMSTATUS_DISABLED",
	                    "CLAIMSTATUS_DENIED_BUT_ENABLED",
	                    "CLAIMSTATUS_DENIED_BUT_DISABLED"
	                ],
	                type: "string",
	                writable: false
	            },
	            SERVICE_EVENTS: {
	                type: "object",
	                keys: ["CLAIM_STATUS_CHANGED"],
	                writable: false
	            },
	            claimKeys: {
	                type: "function",
	                callbackArgumentIndex: 2
	            },
	            releaseKeys: {
	                type: "function",
	                callbackArgumentIndex: 1
	            },
	            getNumberOfFDKs: {
	                type: "function"
	            }
	        }
	    }
	};

	var EppService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$l,
		ServiceClass: ServiceClass$l
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.EventServiceMock.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$p = ({ BaseService, EventInfoList }) => {

	    return class EventServiceMock extends BaseService {

	        /**
	         * "EventServiceMock" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "EventService";

	        /**
	         * registerMap: key   = moduleName (string)
	         *              value = [EventRegstration1, EventRegstration2, ...]  (Array of EventRegistration objects)
	         */
	        registerMap = new Map();
	        regIdxCounter = 0;

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         * @lifecycle service
	         */
	        constructor (...args) {
	            super(...args);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "> EventServiceMock::EventServiceMock");
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< EventServiceMock::EventServiceMock");
	        }
	        
	        /**
	         * An object of EventRegistration is created every time, when s.o. registers for an event
	         */
	        EventRegistration() {
	            this.eventId = null;    //the registered event
	            this.regIdx = null;     //an unique index for every registration, needed for deregistration (compare to setTimeout/clearTimeout)
	            this.callback = null;   //this callback is called when the event is triggered
	            this.dataType = null;   //specifies the type of data which is send via the event
	            this.persistent = false; //if registration is persistent, a content-page unload will not remove the registration
	        }

	        /**
	         * Gets the event info from the event owner list.
	         * The caller has to know the module name and the id definition name.
	         * @param {String} name the name of the owner
	         * @returns {Object} an object containing the name (NAME) of the owner and one or more event ids or an empty object in case of error
	         */
	        getEventInfo(name) {
	            if(name in EventInfoList) {
	                return EventInfoList[name];
	            } else {
	                this.logger.log(this.logger.LOG_ERROR, `Unknown event module name ${name} not in event owner list available.`);
	                return {};
	            }
	        }

	        /**
	         * Returns an index, that must be used when you call deregisterEvent()
	         * @param {Number} event The event ID, 'null' for ALL events of a moduleName
	         * @param {String} moduleName The moduleName that sends the event (normally ProTopas framework)
	         * @param {Function} callbackEvent Callback(keys, values) method that is called if the event is triggered
	         * @param {Function} callbackRegister Callback(message) can be used to check wether registration was successful or not, check message.RC
	         * @param {String} dataType Type of data which were send by the event: "HEX", "ASCII", "UTF-8"
	         * @param {Boolean=} persistent (default: false) If registered with persistent=true, the registration will not be automatically removed on page deactivation
	         */
	        registerForEvent(event, moduleName, callbackEvent, callbackRegister, dataType, persistent) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> EventServiceMock::registerForEvent(${event}, ${moduleName}, ..., ..., ${dataType}, ${persistent})`);
	            this.regIdxCounter++;

	            //build the new EventRegistration object and add it to the map
	            let reg = new this.EventRegistration();
	            reg.regIdx = this.regIdxCounter;
	            reg.eventId = event;
	            reg.callback = callbackEvent;
	            reg.dataType = dataType;
	            reg.persistent = persistent || false;

	            let regArray = [];

	            if(this.registerMap.has(moduleName)) {
	                regArray = this.registerMap.get(moduleName);
	            }

	            regArray.push(reg);
	            this.registerMap.set(moduleName, regArray);

	            if(callbackRegister) {
	                callbackRegister({RC: 0});
	            }
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `< EventServiceMock::registerForEvent returns regId: ${this.regIdxCounter}`);
	            return this.regIdxCounter;
	        }

	        /**
	         * Used to de-register a specific event or all non persistent events
	         * @param regIdx id previously returned by registerForEvent or -1 to de-register all non-persistent registrations
	         * @param callbackDeregister
	         */
	        deregisterEvent(regIdx, callbackDeregister) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> EventServiceMock::deregisterEvent(${regIdx})`);
	            let foundModule = null;
	            for(let [module, regEventArray] of this.registerMap) {
	                for(let i = regEventArray.length - 1; i >= 0; i--) {
	                    if(regIdx === -1) {
	                        if(!regEventArray[i].persistent) {
	                            regEventArray.splice(i, 1);
	                            if(regEventArray.length === 0) {
	                                this.registerMap.delete(module);
	                            }
	                        }
	                    } else if(regEventArray[i].regIdx === regIdx) {
	                        foundModule = module;
	                        regEventArray.splice(i, 1);
	                        if(regEventArray.length === 0) {
	                            this.registerMap.delete(module);
	                        }
	                        break;
	                    }
	                }
	                if(foundModule) {
	                    break;
	                }
	            }
	            if(callbackDeregister) {
	                callbackDeregister({RC: 0});
	            }
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< EventServiceMock::deregisterEvent");
	        }

	        /**
	         * This method will be triggered on message receive
	         * @param {Object} message
	         * @eventhandler
	         */
	        onEvent(message) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> EventServiceMock::onEvent('${JSON.stringify(message)}')`);
	            if(message && this.registerMap.has(message.FWName)) {
	                try {
	                    let delegate = null;
	                    for(let [module, regEventArray] of this.registerMap) {
	                        if(module === message.FWName) {
	                            for(let i = regEventArray.length - 1; i >= 0; i--) {
	                                if(regEventArray[i].eventId === null || regEventArray[i].eventId == message.FWEventID) { //Do not use '===' for FWEventID here !
	                                    delegate = regEventArray[i].callback;
	                                    if(typeof delegate === "function") {
	                                        delegate(message.FWEventParam, message.FWEventID, message.FWName);
	                                    } else {
	                                        this.logger.log(this.logger.LOG_ERROR, `. Error! Delegate is ${typeof delegate}`);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                } catch(e) {
	                    // Provider writes error-log
	                    Wincor.UI.Service.Provider.propagateError(this.NAME, this.ERROR_TYPE.EVENT, e);
	                }
	            } else {
	                this.logger.log(this.logger.LOG_ERROR, `. unknown event or framework message=${JSON.stringify(message)}`);
	            }
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< EventServiceMock::onEvent");
	        }

	        /**
	         * This method is called by the service-provider if an error occurred in any service
	         * @eventhandler
	         * @param {String} serviceName
	         * @param {String} errorType
	         */
	        onError(serviceName, errorType) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> EventServiceMock::onError(${serviceName}, ${errorType})`);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< EventServiceMock::onError");
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * @param {object} message      See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onSetup(message) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> EventServiceMock::onSetup('${JSON.stringify(message)}')`);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `< EventServiceMock::onSetup`);
	            return Promise.resolve();
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onServicesReady() {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "> EventServiceMock::onServicesReady()");
	            return new Promise((resolve, reject) => {
	                // every time a content-page is closing, we have to de-register the non persistent registrations
	                const ds = this.serviceProvider.ViewService;
	                ds.registerForServiceEvent(ds.SERVICE_EVENTS.VIEW_CLOSING, this.deregisterEvent.bind(this, -1, null), true);
	                super.onServicesReady().then(resolve);
	                this.logger.log(this.logger.LOG_SRVC_INOUT, "< EventServiceMock::onServicesReady");
	            });
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ EventServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$m = getServiceClass$p({
	    BaseService: BaseService$1,
	    EventInfoList
	});

	const ServiceInterface$m = {
	    EventProxy: {
	        interface: {
	            registerForEvent: {
	                type: "function",
	            },
	            deregisterEvent: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            getEventInfo: {
	                type: "function",
	            },
	        },
	    },
	};

	var EventService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$m,
		ServiceClass: ServiceClass$m
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	$MOD$ wn.UI.Service.FormatServiceMock.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$q = ({ BaseService, ext, LogProvider }) => {

	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;
	    let _localizeService;

	    function addGroupSeparator(nStr, decSep, separator) {
	        nStr += '';
	        let x = nStr.split(decSep);
	        let x1 = x[0];
	        let x2 = x.length > 1 ? decSep + x[1] : '';
	        let rgx = /(\d+)(\d{3})/;
	        while(rgx.test(x1)) {
	            x1 = x1.replace(rgx, `$1${separator}$2`);
	        }
	        return x1 + x2;
	    }

	    return class FormatServiceMock extends BaseService {

	        /**
	         * "FormatServiceMock" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "FormatService";
	    
	        /**
	         * See {@link Wincor.UI.Service.FormatService#config}.
	         */
	        config = {};

	        /**
	         * See {@link Wincor.UI.Service.FormatService#bankingContext}.
	         */
	        bankingContext = {};
	    
	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> FormatServiceMock::FormatServiceMock");
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< FormatServiceMock::FormatServiceMock");
	        }
	        
	        /**
	         * This method is called by the {@link Wincor.UI.Service.Provider#propagateError} if an error occurred in any service. It logs the error to the console.
	         *
	         *
	         * @param {String} serviceName  The name of this service.
	         * @param {String} errorType    As defined in {@link Wincor.UI.Service.BaseService#ERROR_TYPE}.
	         */
	        onError(serviceName, errorType) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> FormatServiceMock::onError(${serviceName}, ${errorType})`);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< FormatServiceMock::onError");
	        }

	        /**
	         * See {@link Wincor.UI.Service.FormatService#format}.
	         *
	         * In contrast to the ProTopas FormatService, asynchronous requests, whose format options are not implemented in formatHelper(),
	         * can not be supported by anyone else (for the ProTopas FormatService they _could_ possibly supported by the ProTopas FormatFW),
	         * so there will be an error immediately.
	         */
	        format(value, formatOption, callback, isSynchronous) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> FormatService::format(value=${value}, formatOption='${formatOption}', isSynchronous=${isSynchronous})`);
	            let self = this;
	            function generateSpecificResponse() {
	                return self.formatHelper(typeof value === 'object' ? value.raw : value, formatOption);
	            }
	            if(!isSynchronous) {
	                callback({ result: generateSpecificResponse.bind(this)(), raw: typeof value === 'object' ? value.raw : value });
	            } else if(typeof value === "object") {
	                _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< FormatServiceMock::format");
	                value.result = this.formatHelper(value.raw, formatOption);
	            } else {
	                _logger.error("Wrong format arguments. Please check arguments in order to handle format in a right way.");
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< FormatServiceMock::format");
	        }

	        /**
	         * See {@link Wincor.UI.Service.FormatService#formatHelper}.
	         */
	        formatHelper(value, pattern) {
	            const languageISO = _localizeService.currentLanguage;
	            if(!this.config[languageISO]) {
	                _logger.error(`Can't format value '${value}', because no language specific format configuration is available for ISO language culture name '${languageISO}'.`);
	                return value;
	            }
	            const separator = this.config[languageISO].CurrDecimalSep;
	            const groupSep = this.config[languageISO].CurrGroupSep || "";
	            const order = this.config[languageISO].CurrPositiveOrder; //0: Prefix, 1: Suffix, 2+3 are not supported and treated as 0
	            const currencyExtension = this.bankingContext.currencyData.symbol || this.bankingContext.currencyData.iso;

	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> FormatServiceMock::formatHelper(value=${value}, pattern='${pattern}), current languageISO=${languageISO}`);

	            let output = value;
	            let expAbs = Math.abs(this.bankingContext.currencyData.exponent); //Exponent

	            if((pattern === "#C" || pattern === "#M") && jQuery.isNumeric(value)) { // 10.00 or 1,000.00 || € 10.00 or € 1,000.00
	                output = parseInt(value);
	                output /= Math.pow(10, expAbs);
	                output = parseFloat(output).toFixed(expAbs);
	                output = output.toString();
	                output = output.replace(".", separator);
	                output = addGroupSeparator(output, separator, groupSep); // 10.00 or 1,000.00
	                if(pattern === "#M") { // € 10.00 or € 1,000.00
	                    if(order === 1) {
	                        output = `${output} ${currencyExtension}`;
	                    } else { // 0 and others (2+3)
	                        output = `${currencyExtension} ${output}`;
	                    }
	                }
	            // #i is deprecated and thus will be removed later, behavior is now same as '#aTRM0'
	            } else if((pattern === "#ATRM0" || pattern === "#aTRM0" || pattern === "#i") && jQuery.isNumeric(value)) { // € 0 or € 10 or € 1,000 (with group separator) or € 0.10 for a 10 cent coin instead of € 0.1
	                output = parseInt(value);
	                let fixIt = output && output < 100; // determine if its less than 1 EUR, but > 0
	                output /= Math.pow(10, expAbs);
	                if(fixIt) {
	                    output = parseFloat(output).toFixed(expAbs); // we want 0.10 for a 10 cent coin instead of 0.1
	                }
	                output = output.toString();
	                output = output.replace(".", separator);
	                output = addGroupSeparator(output, separator, groupSep); // 10 or 100 or 1.000 (with group separator)
	                if(pattern === "#ATRM0") { // € 0 or € 10 or € 1,000 (with group separator)
	                    if(order === 1) {
	                        output = `${output} ${currencyExtension}`;
	                    } else { // 0 and others (2+3)
	                        output = `${currencyExtension} ${output}`;
	                    }
	                } else if(pattern === "#i") {
	                    _logger.error(`FormatService::format Deprecated use of pattern '#i' found for viewkey=${this.serviceProvider.ViewService.viewContext.viewKey}, please use '#aTRM0' instead.`);
	                }
	            } else if(pattern ==="#SSN" && jQuery.isNumeric(value)) { // 123-45-6789
	                let outputSSNString = output.toString();
	                output = output.toString();
	                let len = outputSSNString.length;
	                switch (len) {
	                    case 1:
	                    case 2:
	                    case 3:
	                        break;
	                    case 4:
	                    case 5: outputSSNString = output.substr(0, 3) + "-" + output.substr(3, len-3);
	                        break;
	                    case 6:
	                    case 7:
	                    case 8:
	                    case 9:
	                        outputSSNString = output.substr(0, 3) + "-" + output.substr(3, 2)  + "-" + output.substr(5, len-5);
	                        break;
	                }
	                output = outputSSNString;
	            } else if(pattern.indexOf("+-") === 2) { // #x+-4:4 xxxxxxx1234 or #*+-4:4 *******1234, the char after the '#' is the char to mask with
	                let len = value.length;
	                let res = "";
	                let maskChar = pattern.substr(1, 1);
	                let remainingLen = parseInt(pattern.substring(pattern.indexOf(":") + 1));
	                for(let i = 0; i < len - remainingLen; i++) {
	                    res += maskChar;
	                }
	                output = res + value.substring(len - remainingLen, len);
	            } else if(pattern.indexOf("#X") !== -1) { // **********
	                output = output.toString().replace(/./g, pattern.substr(2)); // the part after the '#X' is the char to replace with
	            } else if(pattern.includes("#conditional")) {
	                try {
	                    let replacementObject = JSON.parse(pattern.replace("#conditional", ""));
	                    if(value in replacementObject) {
	                        output = replacementObject[value];
	                    } else if("*" in replacementObject){
	                        output = replacementObject["*"];
	                    } else {
	                        output = value;
	                    }
	                    if(typeof output === "string" && output.includes("$val")) {
	                        output = output.replace("$val", value);
	                    }
	                } catch(e) {
	                    _logger.error(`FormatService: Error formatting value=${value} with pattern=${pattern} exception: ${e.message}`);
	                    output = value;
	                }
	            } else {
	                if(value !== "" && pattern) { // in case of empty string we skip the log entry, since this could be the normal case in some circumstances
	                    if (!jQuery.isNumeric(value)) {
	                        _logger.error(`Can't format value='${value}' with pattern '${pattern}', because value is not a number`);
	                    } else {
	                        _logger.error(`Can't format value='${value}' with unknown pattern '${pattern}'`);
	                    }
	                }
	                output = value; // return original value
	            }
	    
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< FormatServiceMock::formatHelper return '${output}'`);
	            return output;
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         *
	         * @param {object} message      See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onSetup(message) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> FormatServiceMock::onSetup('${JSON.stringify(message)}')`);
	            return ext.Promises.promise(resolve => {
	                resolve();
	                _logger.log(_logger.LOG_SRVC_INOUT, "< FormatServiceMock::onSetup");
	            });
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}
	         
	         * Stores references to the LocalizeSerivce.
	         * As soon as this services is ready, it stores the configuration,
	         * which is retrived from the LocalizeService, see {@link Wincor.UI.Service.LocalizeService#getLanguageSpecifications}.
	         *
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onServicesReady() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> FormatServiceMock::onServicesReady()");
	            _localizeService = this.serviceProvider.LocalizeService;
	            const self = this;
	            return _localizeService.whenReady.then(() => {
	                self.config = _localizeService.getLanguageSpecifications();
	                _logger.log(_logger.LOG_DETAIL, `* FormatServiceMock:  ${JSON.stringify(self.config)}`);
	                return super.onServicesReady();
	            });
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ FormatServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$n = getServiceClass$q({
	    BaseService: BaseService$1,
	    ext: ext$3,
	    LogProvider
	});

	const ServiceInterface$n = {
	    FormatProxy: {
	        service: "../service/wn.UI.Service.FormatService.js",
	        interface: {
	            format: {
	                type: "function",
	                callbackArgumentIndex: 2,
	            },
	            bankingContext: {
	                type: "object",
	            }
	        }
	    }
	};

	var FormatService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$n,
		ServiceClass: ServiceClass$n
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.JournalServiceMock.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$r = ({ BaseService, ext, LogProvider }) => {

	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;
	    
	    return class JournalServiceMock extends BaseService {

	        /**
	         * "JournalService" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "JournalService";
	    
	        /**
	         * Stores the configuration for the JournalService, currently only the journalOffset number, which depends on the current instance.
	         * @type {object}
	         * @example
	         * "config": {"journalOffset": 0}
	         */
	        config = {};
	    
	        /**
	         * Message number defines.
	         * These defines are currently used by ProFlex4 UI product. There is an offset of 50 to other UI instances, in which 20 messages of 4 UI instances are reserved.
	         * The offsets are added automatically regarding the appropriate instance.
	         * GUIAPP (520000-520019)
	         * GUIDM  (520050-520069)
	         * GUISOP (520100-520119)
	         * GUIxx  (520150-520169)
	         * For project specific journal messages please use 520000 with an offset of 30-49
	         */
	        MSG_NUMBERS = {
	            MSG_VIEW_DISPLAY: 520000,
	            MSG_AJAX_REQUEST: 520001,
	            MSG_BROWSER_VERSION: 520002,
	            MSG_VIEW_ACTIVATED: 520003,
	            MSG_VIEW_INTERACTION: 520010,
	            MSG_VIEW_RESULT: 520011
	        }
	    
	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "> JournalServiceMock::JournalServiceMock");
	            /**
	             * The offset for the journal numbers, depending on the instance.
	             * @example {{GUIAPP: 0, GUIDM: 50, GUISOP: 100}}
	             * @type {{GUIAPP: number, GUIDM: number, GUISOP: number}}
	             */
	            this.journalOffsets = {
	                GUIAPP: 0,
	                GUIDM: 50,
	                GUISOP: 100
	            };
	    
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< JournalServiceMock::JournalServiceMock");
	        }
	        
	        /**
	         * This method is called by the {@link Wincor.UI.Service.Provider#propagateError} if an error occurred in any service. It logs the error to the console.
	         *
	         *
	         * @param {String} serviceName  The name of this service.
	         * @param {String} errorType    As defined in {@link Wincor.UI.Service.BaseService#ERROR_TYPE}.
	         */
	        onError(serviceName, errorType) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> JournalServiceMock::onError(${serviceName}, ${errorType})`);
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< JournalServiceMock::onError");
	        }

	        /**
	         * Write a journal entry.
	         * @param {Number} messageID number, ID of journal message
	         * @param {function} callback reference to a function receiving the return code as a parameter
	         * @param [arguments] optional arguments for journal message
	         * @example
	         * // use of CCJOURNAL_FW_FUNC_WRITE_MSG_BY_NUMBER method of CCJournal framework
	         * // uses ProFlex4/Op registry config:
	         * //   [HKEY_LOCAL_MACHINE\SOFTWARE\Wincor Nixdorf\ProTopas\CurrentVersion\JOURNAL\TOPMSG]
	         * //     "MSG1001"="=====================================================================================#NL#"
	         * // output in *.jrn file:
	         * //   =====================================================================================
	         * write(1001);
	         * @example
	         * // use of CCJOURNAL_FW_FUNC_WRITE_MSG_BY_NUMBER_WITH_ARGS method of CCJournal framework
	         * // uses ProFlex4/Op registry config:
	         * //   [HKEY_LOCAL_MACHINE\SOFTWARE\Wincor Nixdorf\ProTopas\CurrentVersion\JOURNAL\TOPMSG]
	         * //     "MSG1015"=" @005   @001 <Application> Application state is: #1# (#2#)  #3# #NL#"
	         * // output in *.jrn file:
	         * //    13:45:12   1015 <Application> Application state is: 111 (222)  333
	         * write(1015, null, 111, 222, "333");
	         */
	        write(messageID, callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> JournalService::write(messageID:${messageID}+offset(${this.config.journalOffset}), ...)`);
	    
	            if(messageID) {
	                messageID += this.config.journalOffset;
	                // check for optional params
	                _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. arguments.length: ${arguments.length}`);
	                if(arguments.length < 3) {
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. request < 3`);
	                } else {
	                    // put all additional params in one string, separator ',',
	                    let strMessage = "";
	                    for(let i = 2; i < arguments.length; i++) {
	                        strMessage += arguments[i];
	                        strMessage += ", ";
	                    }
	                    // this doesn't works ... TrcWritef() cut at first \u0000
	                    // output >>>. message strings: '111<<<
	                    //_logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, ". message strings: '" + strMessage + "'.");
	                    // put the string in an object and the stringify() does the job!
	                    // output example >>>. {"message strings":"111\u0000222\u0000333\u0000\u0000"}.<<<
	                    _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. ${JSON.stringify({"message strings": strMessage})}.`);
	                }
	            } else {
	                // if user wants callback ...
	                if(callback) {
	                    // emulate CCJournalFW return code for this case!
	                    this.callbackCaller(callback);   // CCJOURNAL_FW_ERROR
	                }
	            }
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "< JournalServiceMock::write");
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         *
	         * @param {object} message      See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onSetup(message) {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, `> JournalServiceMock::onSetup('${JSON.stringify(message)}')`);
	            return ext.Promises.promise((resolve, reject) => {
	                resolve();
	                this.logger.log(this.logger.LOG_SRVC_INOUT, "< JournalServiceMock::onSetup");
	            });
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onServicesReady() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> JournalServiceMock::onServicesReady()");
	            const self = this;
	            return ext.Promises.promise(resolve => {
	                const configService = Wincor.UI.Service.Provider.ConfigService;
	                const instanceName = configService.configuration.instanceName;
	                configService.getConfiguration(instanceName + "\\Services\\JournalServiceMock", null, function configCallback(config) {
	                    _logger.LOG_DATA && _logger.log(_logger.LOG_DATA, `* JournalServiceMock::configCallback(${JSON.stringify(config)})`);
	        
	                    self.config.journalOffset = self.journalOffsets[instanceName];
	                    self.config = jQuery.extend(true, self.config, config); //...and extend our config with missing default config parameters
	        
	                    _logger.LOG_DATA && _logger.log(_logger.LOG_DATA, `* JournalServiceMock::configCallback, config=${JSON.stringify(self.config)}`);
	        
	                    const viewService = self.serviceProvider.ViewService;
	        
	                    //persistantly register on NAVIGATE_SPA to write logs
	                    viewService.registerForServiceEvent(viewService.SERVICE_EVENTS.NAVIGATE_SPA, data => {
	                        _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* JournalServiceMock::callback(), SPA data=${JSON.stringify(data)}`);
	                        let journalData = jQuery.extend(true, {viewId: viewService.viewContext.viewID}, data);
	                        self.write(self.MSG_NUMBERS.MSG_VIEW_DISPLAY, null, JSON.stringify(journalData), journalData.viewId, journalData.viewKey);
	                    }, true);
	        
	                    //persistantly register on VIEW_ACTIVATED to write logs (here customers can refer to UI properties within the journal messages)
	                    viewService.registerForServiceEvent(viewService.SERVICE_EVENTS.VIEW_ACTIVATED, () => {
	                        // welcome fragment activates without viewkey
	                        if(viewService.viewContext.viewKey) {
	                            let journalData = {
	                                viewId: viewService.viewContext.viewID,
	                                viewKey: viewService.viewContext.viewKey,
	                                url: viewService.viewContext.viewURL
	                            };
	                            self.write(self.MSG_NUMBERS.MSG_VIEW_ACTIVATED, null, JSON.stringify(journalData), journalData.viewId, journalData.viewKey);
	                        }
	                    }, true);
	        
	                    //persistently register on VIEW_CLOSING to write logs
	                    viewService.registerForServiceEvent(viewService.SERVICE_EVENTS.VIEW_CLOSING, d => {
	                        let privateInput = viewService.viewContext.viewConfig.privateInput;
	                        _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* JournalServiceMock::callback(), SPA data=${JSON.stringify(d)}`);
	                        let data = Object.assign({}, d);
	                        if(privateInput) {
	                            data.resultDetail = "*";
	                        }
	                        self.write(self.MSG_NUMBERS.MSG_VIEW_RESULT, null, JSON.stringify(data), data.viewId, data.viewKey, data.resultCode, data.resultDetail);
	                    }, true);
	        
	                    //register for the first(!) VIEW_ACTIVATED (i.e. DISPOSAL_TRIGGER_ONETIME) just to register for the ajaxComplete event.
	                    //We can not directly register ajaxComplete here in onServicesReady, because that is too early and will not work, most likely because
	                    //jQuery is not a member of the contentDocoument at that point in time, because contentDocument is not yet loaded.
	                    let regId = viewService.registerForServiceEvent(viewService.SERVICE_EVENTS.VIEW_ACTIVATED, data => {
	                        let activeFrameName = window.localStorage.getItem("activeFrameName");
	                        if(activeFrameName) {
	                            let iframeDocument = document.getElementById(activeFrameName).contentDocument;
	                            let iframeWindow = document.getElementById(activeFrameName).contentWindow;
	                            _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* JournalServiceMock::callback2(), activeFrameName=${activeFrameName}, SPA data=${JSON.stringify(data)}`);
	                            // Note:
	                            // The content window's jQuery object is not the same as the required one, the required belongs to the services document whereas the
	                            // second one belongs to the window of the content frame and there we want to get informed on AJAX completions.
	                            if(typeof iframeWindow.jQuery === "function") {
	                                try {
	                                    iframeWindow.jQuery(iframeDocument).ajaxComplete((event, jqXHR, ajaxOptions) => {
	                                        let journalMessage = {
	                                            url: ajaxOptions.url,
	                                            statusText: jqXHR.statusText
	                                        };
	                                        _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `* JournalServiceMock::onAjaxComplete() ${JSON.stringify(journalMessage)}`);
	                
	                                        self.write(self.MSG_NUMBERS.MSG_AJAX_REQUEST, null, JSON.stringify(journalMessage), viewService.viewContext.viewID, viewService.viewContext.viewKey);
	                                    });
	                                    viewService.deregisterFromServiceEvent(regId);
	                                } catch(e) {
	                                    self.logger.log(self.logger.LOG_SRVC_DATA, `* JournalServiceMock::onAjaxComplete couldn't register ${e.message}`);
	                                }
	                            }
	                        }
	                    }, true); // register persistent, deregister manually
	        
	                    
	        
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< JournalServiceMock::onServicesReady");
	                })
	                .then(() => {
	                    super.onServicesReady().then(resolve);
	                });
	            });
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ JournalServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$o = getServiceClass$r({
	    BaseService: BaseService$1,
	    ext: ext$3,
	    LogProvider
	});

	const ServiceInterface$o = {
	    JournalProxy: {
	        service: "../service/wn.UI.Service.JournalService.js",
	        interface: {
	            MSG_NUMBERS: {
	                type: "object",
	                keys: [
	                    "MSG_AJAX_REQUEST",
	                    "MSG_VIEW_DISPLAY",
	                    "MSG_VIEW_INTERACTION",
	                    "MSG_VIEW_RESULT",
	                    "MSG_BROWSER_VERSION",
	                ],
	                writable: false,
	            },
	            write: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	        },
	    },
	};

	var JournalService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$o,
		ServiceClass: ServiceClass$o
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.LocalizeServiceMock.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$s = ({ Wincor, BaseService, LogProvider }) => {

	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @const
	     * @private
	     */
	    const _logger = LogProvider;
	    

	    let _localizeText;
	    let _businessData;

	    // default configuration of 'Transaction\\GENERAL\\Language_Map' registry section. Is currently not configured by Tooling for the json files.
	    // will be overwritten during mock setup by reading the file of FILE_NAME_LANGUAGE_MAPPINGS
	    let _langConf = {
	        "InstalledLanguages": "de-DE;en-US",
	        "German": "01;de-DE",
	        "English": "06;en-US"
	    };

	    const LANG_GENERAL = "General";
	    
	    const MAX_LEN_REQUESTED_KEYS = 262144; // 256KB
	    const MAX_COUNT_REQUESTED_KEYS = 2048;
	    
	    
	    function replaceViewKeyInString(value, replaceWith) {
	        value = value.split("_");
	        value[1] = replaceWith; // is the GUI key
	        return value.join("_");
	    }

	    function resolveKey(value, missingDataKeys) {
	        // var regExp = "\\[%WX_TEXT\\[(.+?)\\];(.*?)%\\]";
	        value = this.propResolver(value, _businessData, missingDataKeys);
	        value = this.wxtKeyResolver(value, _localizeText, _businessData, missingDataKeys);
	        return value;
	    }

	    return class LocalizeServiceMock extends BaseService {

	        /**
	         * The logical name of this service as used in the {@link Wincor.UI.Service.Provider}.
	         * @default LocalizeService
	         * @const
	         * @type {string}
	         */
	        NAME = "LocalizeService";

	        /**
	         * Structure containing the registered translation keys
	         * @class
	         */
	        TranslateRegistration = function() {
	            /**
	             * The registered translation keys.
	             * @type {Array<string>}
	             */
	            this.keys = [];         //the registered translationKeys

	            /**
	             * A callback function which is called when a LANGUAGE_CHANGED event is triggered, see {@link Wincor.UI.Service.LocalizeService#SERVICE_EVENTS}.
	             * @type {function}
	             */
	            this.callback = null;   //this callback is called when the languageChanged event is triggered

	            /**
	             * Ordinary texts should be auto updated (true) on LANGUAGE_CHANGED
	             * events triggered by the business logic, see {@link Wincor.UI.Service.LocalizeService#SERVICE_EVENTS}.
	             * @type {boolean}
	             */
	            this.autoUpdate = true; // ordinary texts should be auto updated on LanguageChanged events from BL
	        };

	        /**
	         * Array containing elements of {@link Wincor.UI.Service.LocalizeServiceMock#TranslateRegistration}.
	         * @type {Array}
	         */
	        translationArray = []; // [TranslateRegistration1, TranslateRegistration2, ... ]

	        /**
	         * The current language as ISO code xx-XX, e.g.: en-US.
	         * @type {String}
	         */
	        currentLanguage = "";

	        /**
	         * The language to ISO map.
	         * @type {Object}
	         */
	        languageMap = {};

	        languageSpecifications = {};

	        /**
	         * The service events for the LocalizeServiceMock
	         * @enum {string}
	         */
	        SERVICE_EVENTS = {
	            /**
	             * Fired when the language has been changed.
	             * @event  Wincor.UI.Service.LocalizeServiceMock#SERVICE_EVENTS:LANGUAGE_CHANGED
	             * @eventtype service
	             */
	            LANGUAGE_CHANGED: "LANGUAGE_CHANGED"
	        };
	    
	        /**
	         * This event is sent if there are missing text keys.
	         * @type {Object}
	         * @eventtype native
	         * @event  Wincor.UI.Service.LocalizeServiceMock#EVENT_MISSING_TEXT_KEYS
	         */
	        EVENT_MISSING_TEXT_KEYS = null;
	    
	        /**
	         * This event is sent if there are missing data keys.
	         * Data keys are often part of WX text keys and thus being resolved as well.
	         * @type {Object}
	         * @eventtype native
	         * @event  Wincor.UI.Service.LocalizeServiceMock#EVENT_MISSING_DATA_KEYS
	         */
	        EVENT_MISSING_DATA_KEYS = null;
	    
	        /**
	         * This event is sent the loaded text keys.
	         * @type {Object}
	         * @eventtype native
	         * @event  Wincor.UI.Service.LocalizeServiceMock#EVENT_LOADED_TEXT_KEYS
	         */
	        EVENT_LOADED_TEXT_KEYS = null;
	    
	        /**
	         * Initializes the member of this class.
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.log(_logger.LOG_SRVC_INOUT, "> LocalizeServiceMock::LocalizeServiceMock");

	            this.currentLanguage = "en-US";
	            this.currentLanguageName = "English";
	            this.languageMap = {
	                isoToName: {},
	                nameToIso: {},
	                defaultLanguage: this.currentLanguage // becomes the ISO code
	            };
	    
	            this.EVENT_MISSING_TEXT_KEYS = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                viewID: -1,
	                viewKey: null,
	                eventName: "MissingTextKeys",
	                keys: [],
	            });
	    
	            this.EVENT_MISSING_DATA_KEYS = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                viewID: -1,
	                viewKey: null,
	                eventName: "MissingDataKeys",
	                keys: [],
	            });
	    
	            this.EVENT_LOADED_TEXT_KEYS = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                viewID: -1,
	                viewKey: null,
	                eventName: "LoadedTextKeys",
	                keys: [],
	            });
	    
	            _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeServiceMock::LocalizeServiceMock");
	        }
	        
	        /**
	         * This method is called by the {@link Wincor.UI.Service.Provider#propagateError} if an error occurred in any service. It logs the error to the console.
	         *
	         *
	         * @param {String} serviceName  The name of this service.
	         * @param {String} errorType    As defined in {@link Wincor.UI.Service.BaseService#ERROR_TYPE}.
	         */
	        onError(serviceName, errorType) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> LocalizeServiceMock::onError(${serviceName}, ${errorType})`);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeServiceMock::onError");
	        }

	        /**
	         * Updates the text keys currently stored in the translation map.
	         * @return {Promise<void>} gets resolved when the text callbacks have been called with the updated texts
	         * @async
	         */
	        async updateTexts() {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> LocalizeServiceMock::updateTexts()");

	            const itemPromises = [];
	            // Install a ready callback all elements with -autoUpdate=true.
	            // We do this in order to signal readiness when really all texts have been updated, so that the caller can fire LANGUAGE_CHANGED
	            // event which is way too early otherwise.
	            for(let i = this.translationArray.length - 1; i >= 0; i--) {
	                let trans = this.translationArray[i];
	                if(trans.autoUpdate) {
	                    itemPromises.push(new Promise(resolve => {
	                        const org = trans.callback;
	                        trans.callback = value => {
	                            org(value);
	                            trans.callback = org;
	                            resolve();
	                        };
	                    }));
	                }
	            }
	            for(let i = this.translationArray.length - 1; i >= 0; i--) {
	                let trans = this.translationArray[i];
	                if(trans.autoUpdate) {
	                    //do not call getText, because this is not a 'new' request from the outside where we would
	                    //have to add sth. to the translationArray -- instead it's just an update!
	                    this.processText(trans.keys, trans.callback);
	                }
	            }
	            await Promise.all(itemPromises);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeService::updateTexts()");
	        }

	        /**
	         * Clear values for all requested translation keys contained by the translationArray.
	         * @param {boolean=} [cleanAll=true] cleanAll true, all registrations will be cleaned, false means only registrations which contains a dispose function will be cleaned
	         */
	        cleanTranslationTexts(cleanAll = true) {
	            for(let i = this.translationArray.length - 1; i >= 0; i--) {
	                let reg = this.translationArray[i];
	                if(cleanAll || reg.disposeFn) {
	                    reg.keys = null;
	                    reg.callback = null;
	                    if(reg.disposeFn) {
	                        reg.disposeFn();
	                        reg.disposeFn = null;
	                    }
	                    this.translationArray.splice(i, 1);
	                }
	            }
	            if(cleanAll) {
	                this.translationArray.length = 0;
	            }
	        }

	        /**
	         * Get the values of the requested translation keys stored in the localizeText object.
	         * @param {Array<string> | string} keys the text keys
	         * @param {function} callback Callback(result)
	         * @param {boolean=} [autoUpdate=true] autoUpdate default is true, for texts that should not be updated automatically on languageChanged events, set this parameter to false
	         * @param {function=} [disposeFn=null] disposeFn dispose function to be called when {@link Wincor.UI.Service.LocalizeServiceMock#cleanTranslationTexts} is invoked with an false argument
	         */
	        getText(keys, callback, autoUpdate = true, disposeFn = null) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> LocalizeServiceMock::getText(${keys})`);

	            //BEGIN: check input parameters
	            keys = Array.isArray(keys) ? keys : [keys];
	            let uniqueKeys = [];
	            let errorMessage, len = keys.length;
	            let overallLen = 0;
	            for(let i = 0; i < len; ++i) { // must use forward loop, because of order of the keys (e.g. ProFlex4Op)
	                let key = keys[i];
	                if(key !== void 0 && key !== null) { //do NOT use '!keys[i]' because empty string is okay, 0 is okay
	                    if(!uniqueKeys.includes(key)) {
	                        uniqueKeys.push(key);
	                        overallLen += key.length;
	                    } else {
	                        _logger.error(`Warning: LocalizeServiceMock::getText() double key detected: ${key}`);
	                    }
	                } else {
	                    errorMessage = "LocalizeServiceMock::getText(): keys contains null or undefined.";
	                    break;
	                }
	            }
	    
	            // check for potential argument error
	            if(overallLen > MAX_LEN_REQUESTED_KEYS || uniqueKeys.length > MAX_COUNT_REQUESTED_KEYS) {
	                errorMessage = `LocalizeServiceMock::getText() too many or too long text keys argument requested. Please check your keys array argument. Number of keys requested: ${uniqueKeys.length}, string len: ${overallLen}`;
	            }
	    
	            keys = uniqueKeys;

	            if(errorMessage) {
	                _logger.error(errorMessage);
	                callback({}); //call callback with empty object
	                Wincor.UI.Service.Provider.propagateError("LocalizeServiceMock::getText", this.ERROR_TYPE.REQUEST);
	                return;
	            }
	            //END: check input parameters

	            //build a new TranslateRegistration object and add it to our Array
	            let transReg = new this.TranslateRegistration();
	            if(disposeFn) {
	                transReg.disposeFn = disposeFn;
	            }
	            transReg.keys = keys;
	            transReg.callback = callback;
	            transReg.autoUpdate = autoUpdate;
	            this.translationArray.push(transReg);
	            this.processText(keys, callback);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeServiceMock::getText");
	        }

	        /**
	         * Process the text values of the requested translation keys stored in the localizeText object.
	         * @param {Array<string>} keyArray the text keys
	         * @param {function} callback Callback(result)
	         */
	        processText(keyArray, callback) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> LocalizeServiceMock::processText(${keyArray})`);
	    
	            function sendMessageMissingKeys(missingKeys) {
	                if (missingKeys.length > 0) {
	                    const ctx = Wincor.UI.Service.Provider.ViewService.viewContext;
	                    this.EVENT_MISSING_TEXT_KEYS.viewID = ctx.viewID;
	                    this.EVENT_MISSING_TEXT_KEYS.viewKey = ctx.viewKey;
	                    if(ctx.viewKeyRedirect) {
	                        this.EVENT_MISSING_TEXT_KEYS.viewKey = ctx.redirectFrom;
	                        this.EVENT_MISSING_TEXT_KEYS.redirectedToViewKey = ctx.redirectTo;
	                    } else {
	                        delete this.EVENT_MISSING_TEXT_KEYS.redirectedToViewKey;
	                    }
	                    this.EVENT_MISSING_TEXT_KEYS.keys = missingKeys;
	                    this.sendEvent(this.EVENT_MISSING_TEXT_KEYS);
	                }
	            }
	    
	            function sendMessageMissingDataKeys(missingKeys) {
	                if(missingKeys.length > 0) {
	                    const ctx = Wincor.UI.Service.Provider.ViewService.viewContext;
	                    this.EVENT_MISSING_DATA_KEYS.viewID = ctx.viewID;
	                    this.EVENT_MISSING_DATA_KEYS.viewKey = ctx.viewKey;
	                    if(ctx.viewKeyRedirect) {
	                        this.EVENT_MISSING_DATA_KEYS.viewKey = ctx.redirectFrom; // overwrite to satisfy tooling
	                        this.EVENT_MISSING_DATA_KEYS.redirectedToViewKey = ctx.redirectTo;
	                    } else {
	                        delete this.EVENT_MISSING_DATA_KEYS.redirectedToViewKey;
	                    }
	                    this.EVENT_MISSING_DATA_KEYS.keys = missingKeys;
	                    this.sendEvent(this.EVENT_MISSING_DATA_KEYS);
	                }
	            }
	    
	            function sendMessageLoadedKeys(loadedKeys) {
	                if(loadedKeys.length > 0) {
	                    const ctx = Wincor.UI.Service.Provider.ViewService.viewContext;
	                    this.EVENT_LOADED_TEXT_KEYS.viewID = ctx.viewID;
	                    this.EVENT_LOADED_TEXT_KEYS.viewKey = ctx.viewKey;
	                    if(ctx.viewKeyRedirect) {
	                        this.EVENT_LOADED_TEXT_KEYS.viewKey = ctx.redirectFrom;
	                        this.EVENT_LOADED_TEXT_KEYS.redirectedToViewKey = ctx.redirectTo;
	                    } else {
	                        delete this.EVENT_LOADED_TEXT_KEYS.redirectedToViewKey;
	                    }
	                    this.EVENT_LOADED_TEXT_KEYS.keys = loadedKeys;
	                    this.sendEvent(this.EVENT_LOADED_TEXT_KEYS);
	                }
	            }
	    
	            function generateSpecificResponse() {
	                let response = {};
	                let missingKeys = [];
	                let missingDataKeys = [];
	                let loadedKeys = [];
	                for(let i = keyArray.length - 1; i >= 0; i--) {
	                    let key = keyArray[i];
	                    let value = this.getTextValue(key, _localizeText);
	                    if(value === -1) {
	                        value = this.getTextValue(replaceViewKeyInString(key, "*"), _localizeText);
	                        if(value === -1) {
	                            Wincor.toolingEDM && !missingKeys.includes(key) && missingKeys.push(key);
	                            value = null; // key isn't available in text config nor as default text (*), null is what in such a case must be set within the response
	                        }
	                    }
	                    if(value) {
	                        value = this.getTextFromObj(value);
	                        value = resolveKey.call(this, value, missingDataKeys);
	                        // work around for € sign when coming from registry export
	                        if(value.indexOf("â‚¬") !== -1) {
	                            value = "€";
	                        }
	                        Wincor.toolingEDM && loadedKeys.push(key);
	                    }
	                    response[key] = value;
	                }
	                if(Wincor.toolingEDM) {
	                    sendMessageMissingKeys.call(this, missingKeys);
	                    sendMessageMissingDataKeys.call(this, missingDataKeys);
	                    sendMessageLoadedKeys.call(this, loadedKeys);
	                }
	                _logger.log(_logger.LOG_DATA, `. LocalizeServiceMock::processText response=${JSON.stringify(response)}`);
	                return response;
	            }

	            setTimeout(() => callback(generateSpecificResponse.call(this)), this.responseTimeSimulation);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeServiceMock::processText");
	        }

	        /**
	         * Set the new ISO language.
	         * @param {string} langISO Language in ISO compatible "xx-YY" notation
	         * @param {function=} callback Callback(result) will be called to inform about the reception of this function.
	         * A successful language change will be propagated by SERVICE_EVENTS.LANGUAGE_CHANGED
	         */
	        setLanguage(langISO, callback) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> LocalizeServiceMock::setLanguage(${langISO})`);
	            const langName = this.languageMap.isoToName[langISO];
	            _logger.log(_logger.LOG_SRVC_DATA, `* LocalizeServiceMock::setLanguage, mapped: ${langName}`);

	            if (!langName) {
	                _logger.error(`LocalizeServiceMock::setLanguage called with unknown ISO language culture name '${langISO}'`);
	                return;
	            }

	            if (callback) {
	                if (langISO === this.currentLanguage) {
	                    callback("-1");
	                } else {
	                    callback("0");
	                }
	            }

	            if (langISO !== this.currentLanguage) {
	                this.onLanguageChanged(langISO);
	            }

	            _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeServiceMock::setLanguage");
	        }

	        /**
	         * This delegate is called when the language has been changed.
	         * The information will be received from the GatewayService.
	         * @param {string} newLanguageISO the new language ISO code such as xx-XX, e.g. en-US
	         */
	        onLanguageChanged(newLanguageISO) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> LocalizeServiceMock::onLanguageChanged(${newLanguageISO})`);

	            this.currentLanguage = newLanguageISO;
	            this.currentLanguageName = this.languageMap.isoToName[newLanguageISO];
	            const viewService = this.serviceProvider.ViewService;
	            if (viewService.viewContext && viewService.viewContext.viewConfig) { //during onServicesReady we already call setLanguage and get here. Then some members of the ViewService are null or undefined.
	                let config = viewService.viewContext.viewConfig.config;
	                // The updateTexts() call maybe unwanted, which is possible by configuring at a certain viewkey with {..., "config": {"autoUpdateOnLanguageChange": "false"}, ...}
	                // E.g. 'TransactionEnd' -> "Thank you and have a nice day." is not desired that the currently shown text changes back to the default language when its e.g. currently
	                // displayed in chinese while the view is presented.
	                // Usually the OP does switch to the default language at this point of end of transaction.
	                if (!config || config.autoUpdateOnLanguageChange === void 0 || this.convertToBoolean(config.autoUpdateOnLanguageChange)) {
	                    this.updateTexts().then(() => {
	                        this.fireServiceEvent(this.SERVICE_EVENTS.LANGUAGE_CHANGED, newLanguageISO); // fire when almost really ready with update of texts
	                    });
	                } else {
	                    this.fireServiceEvent(this.SERVICE_EVENTS.LANGUAGE_CHANGED, newLanguageISO);
	                }
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeServiceMock::onLanguageChanged");
	        }

	        /**
	         * INTERNAL USE ONLY! Only used by FormatService, can be dropped at any time!
	         * @returns {Object}
	         */
	        getLanguageMapping() {
	            return this.languageMap;
	        }

	        /**
	         * Gets the language specifications.
	         * @returns {Wincor.UI.Service.LocalizeServiceMock.languageSpecifications|{}}
	         */
	        getLanguageSpecifications() {
	            return this.languageSpecifications;
	        }

	        /**
	         * Get the used properties from the localize text.
	         * The method does a static analyse of the text data to search for business properties.
	         * @returns {Set} the used properties
	         */
	        getUsedProperties() {
	            let extractedProps = [];
	            let lang = this.languageMap.isoToName[this.currentLanguage];
	            let keys = Object.keys(_localizeText), guiKey, text;
	            for(let i = keys.length - 1; i >= 0; i--) {
	                guiKey = keys[i];
	                text = _localizeText[lang];
	                if(text === void 0) {
	                    text = _localizeText[guiKey][LANG_GENERAL];
	                    extractedProps = extractedProps.concat(this.extractPropertiesFromText(text));
	                }
	            }
	            return new Set(extractedProps);
	        }
	    
	        /**
	         * This will read (again) all data from the JSON files.
	         * This was originally done in onSetup, but now moved into a separate function, to be called anytime.
	         * @async
	         */
	        async updateJSONData() {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> LocalizeServiceMock::updateJSONData()");
	            try {
	                let [profile, profileExtension] = await this.getToolingProfile();
	                _logger.log(_logger.LOG_DATA, `. LocalizeServiceMock::updateJSONData profile=${profile}`);
	                const fileLocalizedText = `../servicemocks/mockdata/LocalizedText${profileExtension}.json`;
	                const fileLocalizedTextCustom = "../servicemocks/mockdata/LocalizedTextCustom.json";
	                const fileLanguageMappings = `../servicemocks/mockdata/LanguageMappings${profileExtension}.json`;
	                const fileLanguageMappingsCustom = "../servicemocks/mockdata/LanguageMappingsCustom.json";
	                let dataArray = await Promise.all([
	                    this.retrieveJSONData(fileLocalizedText),
	                    this.retrieveJSONData(fileLocalizedTextCustom),
	                    this.retrieveJSONData(fileLanguageMappings),
	                    this.retrieveJSONData(fileLanguageMappingsCustom)
	                ]);
	                delete dataArray[1]["//"]; // remove possible comment
	                _localizeText = Object.assign(dataArray[0], dataArray[1]); // standard props with custom specific ones
	                delete dataArray[3]["//"]; // remove possible comment
	                _langConf = Object.assign(dataArray[2], dataArray[3]); // standard props with custom specific ones
	                this.logger.log(this.logger.LOG_SRVC_INOUT, "< LocalizeServiceMock::updateJSONData");
	            } catch(e) {
	                throw `* importReference error or getToolingProfile failed ${e}`;
	            }
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onSetup}.
	         * In addition it will call _updateJSONData_ to read the JSON files.
	         *
	         * @param {object} message
	         * @see {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * @lifecycle service
	         * @async
	         */
	        async onSetup(message) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> LocalizeServiceMock::onSetup('${JSON.stringify(message)}')`);
	            try {
	                await this.updateJSONData();
	                _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeServiceMock::onSetup");
	            } catch(e) {
	                throw e;
	            }
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onServicesReady() {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> LocalizeServiceMock::onServicesReady()");
	            this.serviceProvider.ViewService.registerForServiceEvent(this.serviceProvider.ViewService.SERVICE_EVENTS.VIEW_CLOSING, this.cleanTranslationTexts.bind(this, true), true);
	            this.serviceProvider.ViewService.registerForServiceEvent(this.serviceProvider.ViewService.SERVICE_EVENTS.SHUTDOWN, this.cleanTranslationTexts.bind(this, true), true);
	            return new Promise(resolve => {
	                _businessData = this.serviceProvider.DataService.businessData;

	                function convertRegistryMappingToInternalMapping(languageMappings) {
	                    let internalMapping = {nameToIso: {}, isoToName: {}};
	                    try {
	                        let installedLangsIso = languageMappings["InstalledLanguages"].split(";");
	                        let langSpecs = languageMappings["LanguageSpecifications"];
	                        if(installedLangsIso.length <= langSpecs.length) {
	                            for(let i = 0; i < installedLangsIso.length; i++) {
	                                let isoCode = installedLangsIso[i]; // get e.g. "en-US"
	                                for(let k = 0; k < langSpecs.length; k++) {
	                                    let spec = langSpecs[k][isoCode];
	                                    if(spec) {
	                                        this.languageSpecifications[isoCode] = spec;
	                                        let langName = Object.keys(spec["NameToIso"])[0];        // get e.g. "English" or "German"...
	                                        isoCode = spec["NameToIso"][langName].split(";")[1]; // get e.g. "en-US" or "de-DE"
	                                        if(isoCode) {
	                                            internalMapping.nameToIso[langName] = isoCode;   // set e.g. "German": "de-DE"
	                                            internalMapping.isoToName[isoCode] = langName;   // set e.g. "de-DE": "German"
	                                        }
	                                        break;
	                                    }
	                                }
	                            }
	                            internalMapping.defaultLanguage = installedLangsIso.length ? installedLangsIso[0] : "en-US";
	                        } else {
	                            internalMapping = null;
	                            _logger.error("LanguageMappings.json invalid configuration: InstalledLanguages exceeds mapped languages - allowed is less or euqal !");
	                        }
	                    } catch (e) {
	                        internalMapping = null;
	                        _logger.error(e);
	                    }
	                    return internalMapping;
	                }
	    
	                this.languageMap = convertRegistryMappingToInternalMapping.call(this, _langConf);

	                // If there is a default language configured (e.g. by a QueryString), then CoreResources.js has stored it in the localStorage.
	                // We expect it as ISO code
	                let defLangFromStorage = localStorage.getItem("defaultLanguage");
	                if (defLangFromStorage) {
	                    this.languageMap.defaultLanguage = defLangFromStorage;
	                    this.setLanguage(defLangFromStorage);
	                }
	                
	                super.onServicesReady().then(resolve);
	                _logger.log(_logger.LOG_SRVC_INOUT, "< LocalizeServiceMock::onServicesReady");
	            });
	        }

	        /**
	         * Returns all installed languages as an array of ISO Codes
	         * @return {Array<String>} will be an Array of ISO codes, e.g. [en-US, de-DE]
	         */
	        getInstalledLanguages() {
	            const result = Object.keys(this.languageMap.isoToName);
	            _logger.log(_logger.LOG_SRVC_INOUT, `. LocalizeServiceMock::getInstalledLanguages ISO languageMap=${result}`);
	            return result;
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ LocalizeServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$p = getServiceClass$s({
	    Wincor: Wincor$2,
	    BaseService: BaseService$1,
	    LogProvider
	});

	const ServiceInterface$p = {
	    LocalizeProxy: {
	        service: '../service/wn.UI.Service.LocalizeService.js',
	        interface: {
	            SERVICE_EVENTS: {
	                type: 'object',
	                keys: ['LANGUAGE_CHANGED'],
	                writable: false
	            },
	            currentLanguage: {
	                type: 'string',
	                writable: false
	            },
	            currentLanguageName: {
	                type: 'string',
	                writable: false
	            },
	            getText: {
	                type: 'function',
	                callbackArgumentIndex: 1
	            },
	            setLanguage: {
	                type: 'function',
	                callbackArgumentIndex: 1
	            },
	            updateTexts: {
	                type: 'function'
	            },
	            getInstalledLanguages: {
	                type: 'function'
	            },
	            getLanguageMapping: {
	                type: 'function'
	            },
	            getLanguageSpecifications: {
	                type: 'function'
	            },
	            getUsedProperties: {
	                type: 'function'
	            },
	            cleanTranslationTexts: {
	                type: 'function'
	            },
	            updateJSONData: {
	                type: 'function'
	            }
	        }
	    }
	};

	var LocalizeService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$p,
		ServiceClass: ServiceClass$p
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.ValidateServiceMock.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$t = ({ BaseService, ext, LogProvider }) => {

	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;

	    let _viewService;

	    return class ValidateServiceMock extends BaseService {

	        /**
	         * "ValidateServiceMock" - the logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         */
	        NAME = "ValidateService";

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ValidateServiceMock::ValidateServiceMock`);
	            _logger.log(_logger.LOG_SRVC_INOUT, `< ValidateServiceMock::ValidateServiceMock`);
	        }
	        
	        /**
	         * This method is called by the {@link Wincor.UI.Service.Provider#propagateError} if an error occurred in any service. It logs the error to the console.
	         *
	         *
	         * @param {String} serviceName  The name of this service.
	         * @param {String} errorType    As defined in {@link Wincor.UI.Service.BaseService#ERROR_TYPE}.
	         */
	        onError(serviceName, errorType) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ValidateServiceMock::onError(${serviceName}, ${errorType})`);
	            _logger.log(_logger.LOG_SRVC_INOUT, `< ValidateServiceMock::onError`);
	        }

	        /**
	         * Checks if a given value is a number. Will returns true, if it is a number, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @return {Boolean}
	         */
	        isNumbers(value) {
	            //Problem: isNaN(5-2) = false
	            //var isNum = value !== "" && !isNaN(value);
	            let isNum = false;

	            try {
	                var array = value.split("");

	                if(value === "") {
	                    isNum = false;
	                }
	                else {
	                    // Start with the last value of the array
	                    for(var i = array.length - 1; i >= 0; i--) {
	                        if(!isNaN(array[i])) {
	                            isNum = true;
	                        }
	                        else {
	                            isNum = false;
	                            break;
	                        }
	                    }
	                }
	            } catch(e) {
	                //pass
	            }
	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DETAIL, `ValidateServiceMock::isNumbers: ${isNum} for ${value}`);
	            return isNum;
	        }

	        /**
	         * Checks if a given value is a char sequence. Will return true, if it is a char sequence, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @return {Boolean}
	         */
	        isChars(value) {
	            const re = /[0-9]/;
	            const isChar = value !== "" && !re.test(value);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DETAIL, `ValidateServiceMock::isChars: ${isChar} for ${value}`);
	            return isChar;
	        }

	        /**
	         * Checks if a given value is a mail address. Will return true, if it is a mail address, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @return {Boolean}
	         */
	        isEmail(value) {
	            // http://stackoverflow.com/questions/46155/validate-email-address-in-javascript
	            const re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
	            const isEMail = re.test(value);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DETAIL, `ValidateServiceMock::isEmail: ${isEMail} for ${value}`);
	            return isEMail;
	        }

	        /**
	         * Checks if a given value has a valid date format. Will return true, if it has a valid date format, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {string} [pattern=""] - Valid date format e.g. yyyy/mm/dd Currently not used. Browser-known patterns only.
	         * @return {Boolean}
	         */
	        isDateFormat(value, pattern="") {     /*TODO: date pattern must be known, to check if a date is valid*/
	            const date = new Date(value);

	            const isDate = date.toString() !== "Invalid Date";

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DETAIL, `ValidateServiceMock(isDateFormat): ${isDate} for ${value}`);
	            return isDate;
	        }

	        /**
	         * Checks if a given value is within a valid period. Will return true, if it is within the period, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {string} from - Earliest date
	         * @param {string} to - Latest date
	         * @param {string=} pattern - Valid date format e.g. yyyy/mm/dd
	         * @return {Boolean}
	         */
	        isDateInRange(value, from, to, pattern) {
	            let isDateInRange = false;

	            if(this.isDateFormat(value) && this.isDateFormat(from) && this.isDateFormat(to)) {
	                isDateInRange = (value !== "") && (value >= from) && (value <= to);
	            }

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DETAIL, `ValidateServiceMock(isDateFormat): ${isDateInRange} for ${value}`);
	            return isDateInRange;
	        }

	        /**
	         * Checks if a given value is in range. Will return true, if it is in range, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {number} min - Minimum value
	         * @param {number} max - Maximum value
	         * @param {number=} stepLen - Value for modulo function e.g. '100' for full amounts, default = 1
	         * @return {Boolean}
	         */
	        isInRange(value, min, max, stepLen) {
	            if (stepLen === void 0) {
	                stepLen = 1;
	            }

	            let inRange = (value !== "") && (value >= min) && (value <= max) && ((value % (stepLen)) === 0);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DETAIL, `ValidateServiceMock::isInRange: ${inRange} for ${value}`);
	            return inRange;
	        }

	        /**
	         * Checks if a given value is higher than the minimum. <BR>
	         * Will return true, if it is higher than or equal to the minimum, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {number} min - Minimum value
	         * @return {Boolean}
	         */
	        isMin(value, min) {
	            const resultMin = (value !== "") && (value >= min);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DETAIL, `ValidateServiceMock::isMin: ${resultMin} for ${value}`);
	            return resultMin;
	        }

	        /**
	         * Checks if a given value is lower than the maximum. <BR>
	         * Will return true, if it is lower than or equal to the maximum, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {number} max - Maximum value
	         * @return {Boolean}
	         */
	        isMax(value, max) {
	            let resultMax = (value !== "") && (value <= max);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DETAIL, `ValidateServiceMock::isMax: ${resultMax} for ${value}`);
	            return resultMax;
	        }

	        /**
	         * Checks if a given value is in step length. Will return true, if it is in step length, otherwise false.
	         * @param {string} value - Parameter to check
	         * @param {number} stepLen - Value for modulo function e.g. '100' for full amounts || '60' for number of minutes
	         * @return {Boolean}
	         */
	        isStepLen(value, stepLen) {
	            const stepLength = (value !== "") && (value % stepLen === 0);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DETAIL, `ValidateServiceMock::isStepLen: ${stepLength} for ${value}`);
	            return stepLength;
	        }

	        /**
	         * Checks if the length of a given value is greater than or equal to a minimum length. <BR>
	         * Will return true, if it is greater than / equal to the minLen, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {number} [minLen=0] - minimum length
	         * @return {Boolean}
	         */
	        isWithinMinLength(value, minLen=0) {
	            if (value === void 0) {
	                _logger.error(`ValidateServiceMock::isWithinMinLength - value is undefined`);
	                return false;
	            }
	            if (value === null ) {
	                _logger.error(`ValidateServiceMock::isWithinMinLength - value is null`);
	                return false;
	            }

	            let isWithin = true;
	            if (minLen >= 0) {
	                isWithin = value.length >= minLen;
	            }
	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DETAIL, `ValidateServiceMock::isWithinMinLength (input=${value}, minLen=${minLen}, isWithin=${isWithin})`);
	            return isWithin;
	        }

	        /**
	         * Checks if the length of a given value is smaller than or equal to a maximum length. <BR>
	         * Will return true, if it is smaller than / equal to the maxLen, otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {number} [maxLen=Infinity] - maximum length
	         * @return {Boolean}
	         */
	        isWithinMaxLength(value, maxLen=Infinity) {
	            if (value === void 0 ) {
	                _logger.error(`ValidateServiceMock::isWithinMaxLength - value is undefined`);
	                return false;
	            }
	            if (value === null ) {
	                _logger.error(`ValidateServiceMock::isWithinMaxLength - value is null`);
	                return false;
	            }

	            let isWithin = true;
	            if (maxLen >= 0) {
	                isWithin = value.length <= maxLen;
	            }
	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DETAIL, `ValidateServiceMock::isWithinMaxLength (input=${value}, maxLen=${maxLen}, isWithin=${isWithin})`);
	            return isWithin;
	        }

	        /**
	         * Checks if the length of a given value is smaller than or equal to a maximum length <BR>
	         * and greater than / equal to a minimum length. <BR>
	         * Will return true, if it is smaller than / equal to the maxLen and greater than / equal to the minLen, <BR>
	         * otherwise false.
	         * @param {string} value - Parameter to be checked
	         * @param {number} [minLen=0] - minimum length
	         * @param {number} [maxLen=Infinity] - maximum length
	         * @return {Boolean}
	         */
	        isWithinLength(value, minLen=0, maxLen=Infinity) {
	            if (value === void 0 ) {
	                _logger.error(`ValidateServiceMock::isWithinLength - value is undefined`);
	                return false;
	            }
	            if (value === null ) {
	                _logger.error(`ValidateServiceMock::isWithinLength - value is null`);
	                return false;
	            }
	            const isWithin = this.isWithinMinLength(value, minLen) && this.isWithinMaxLength(value, maxLen);

	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DETAIL, `ValidateServiceMock::isWithinLength (input=${value}, minLen=${minLen}, maxLen=${maxLen}, isWithin=${isWithin})`);
	            return isWithin;
	        }

	        /**
	         * Checks if a given value starts with a '0'. <BR>
	         * Will return false, if the first digit is '0' and it is not allowed to be '0', otherwise it will return true.
	         * @param {string} value - Parameter to be checked
	         * @param {Boolean} allowLeadingZero - Flag that determines whether a leading zero is allowed (true) or not (false)
	         * @return {Boolean}
	         */
	        checkLeadingZero(value, allowLeadingZero) {
	            let zeroCheck = true;

	            if ( ( allowLeadingZero === false ) && ( value.length >= 1 ) && ( value[0] === "0" )  ) {
	                zeroCheck = false;
	            }
	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DATA, `ValidateServiceMock::checkLeadingZero (input=${value}, allowLeadingZero=${allowLeadingZero}, zeroCheck=${zeroCheck})`);
	            return zeroCheck;
	        }

	        /**
	         * Checks whether the given value is in line with a regular expression.
	         * @param {string} value - Parameter to be checked
	         * @param {string} forbiddenPattern - reg. expression
	         * @return {Boolean}
	         */
	        matchesForbiddenPattern(value, forbiddenPattern) {
	            let isForbidden = false;

	            if (!(forbiddenPattern === "" || forbiddenPattern === undefined || forbiddenPattern === null)) {

	                // Examples:
	                // forbiddenPattern = "^\\s+$" --> will not accept string only consisting of blanks
	                // forbiddenPattern = "gr[" --> will throw exception

	                try {
	                    const pattern = new RegExp(forbiddenPattern);
	                    isForbidden = pattern.test(value);
	                    !_viewService.viewContext.viewConfig.privateInput &&
	                    _logger.log(_logger.LOG_DATA, `ValidateServiceMock::matchesForbiddenPattern - after test() call: (input=${value}, forbiddenPattern=${forbiddenPattern}, isForbidden=${isForbidden})`);
	                } catch(e){
	                    isForbidden = false;
	                    _logger.log(_logger.LOG_DATA, `ValidateServiceMock::matchesForbiddenPattern: exception: forbiddenPattern=${forbiddenPattern} is invalid`);
	                }
	            }
	            !_viewService.viewContext.viewConfig.privateInput &&
	            _logger.log(_logger.LOG_DATA, `ValidateServiceMock::matchesForbiddenPattern (input=${value}, forbiddenPattern=${forbiddenPattern}, isForbidden=${isForbidden}`);
	            return isForbidden;
	        }


	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         *
	         * @param {object} message      See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onSetup(message) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ValidateServiceMock::onSetup('${JSON.stringify(message)}')`);
	            return ext.Promises.promise((resolve, reject) => {
	                resolve();
	                _logger.log(_logger.LOG_SRVC_INOUT, `< ValidateServiceMock::onSetup`);
	            });
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}
	         * @async
	         * @lifecycle service
	         */
	        async onServicesReady() {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ValidateServiceMock::onServicesReady()`);
	            _viewService = this.serviceProvider.ViewService;
	            await super.onServicesReady();
	            _logger.log(_logger.LOG_SRVC_INOUT, `< ValidateServiceMock::onServicesReady`);
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ ValidateServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$q = getServiceClass$t({
	    BaseService: BaseService$1,
	    ext: ext$3,
	    LogProvider
	});

	const ServiceInterface$q = {
	    ValidateProxy: {
	        service: "../service/wn.UI.Service.ValidateService.js",
	        interface: {
	            Expand_StandardFunctions: {
	                attributes: [
	                    "isNumbers",
	                    "isChars",
	                    "isEmail",
	                    "isDateFormat",
	                    "isDateInRange",
	                    "isInRange",
	                    "isMin",
	                    "isMax",
	                    "isStepLen",
	                    "isWithinMinLength",
	                    "isWithinMaxLength",
	                    "isWithinLength",
	                    "checkLeadingZero",
	                    "matchesForbiddenPattern",
	                ],
	                type: "function",
	            },
	        },
	    },
	};

	var ValidateService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$q,
		ServiceClass: ServiceClass$q
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.VideoServiceMock.js 4.3.1-210203-21-1b8704b6-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$u = ({ BaseService, ext, LogProvider }) => {

	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @const
	     * @private
	     */
	    const _logger = LogProvider;

	    return class VideoServiceMock extends BaseService {

	        /**
	         * The logical name of this service as used in the service-provider
	         * @const
	         * @type {string}
	         * @default "VideoService"
	         */
	        NAME = "VideoService";
	    
	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);
	            _logger.log(_logger.LOG_SRVC_INOUT, "> VideoServiceMock::VideoServiceMock");
	            _logger.log(_logger.LOG_SRVC_INOUT, "< VideoServiceMock::VideoServiceMock");
	        }
	        
	        /**
	         * This method is called by the {@link Wincor.UI.Service.Provider#propagateError} if an error occurred in any service. It logs the error to the console.
	         *
	         *
	         * @param {String} serviceName  The name of this service.
	         * @param {String} errorType    As defined in {@link Wincor.UI.Service.BaseService#ERROR_TYPE}.
	         */
	        onError(serviceName, errorType) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> VideoServiceMock::onError(${serviceName}, ${errorType})`);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< VideoServiceMock::onError");
	        }

	        /**
	         * This method does nothing in moment.
	         *
	         * @param {number} step             in %, Range: [1-100], Default: 10 (10%)
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        increaseVolume(step, callback) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> VideoService::increaseVolume(step:${step}, ...)`);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< VideoService::increaseVolume");
	        }

	        /**
	         * This method does nothing in moment.
	         *
	         * @param {number} step             in %, Range: [1-100], Default: 10 (10%)
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        decreaseVolume(step, callback) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> VideoService::decreaseVolume(step:${step}, ...)`);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< VideoService::decreaseVolume");
	        }

	        /**
	         * This method does nothing in moment.
	         *
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        mute(callback) {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> VideoService::mute(...)");
	            _logger.log(_logger.LOG_SRVC_INOUT, "< VideoService::mute");
	        }

	        /**
	         * This method does nothing in moment.
	         *
	         * @param {function=} callback      Reference to a function receiving the return code as a parameter.
	         */
	        unmute(callback) {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> VideoService::unmute(...)");
	            _logger.log(_logger.LOG_SRVC_INOUT, "< VideoService::unmute");
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         *
	         * @param {object} message      See {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * @returns {Promise}
	         * @lifecycle service
	         */
	        onSetup(message) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> VideoServiceMock::onSetup('${JSON.stringify(message)}')`);
	            return ext.Promises.promise(function(resolve, reject) {
	                resolve();
	                _logger.log(_logger.LOG_SRVC_INOUT, "< VideoServiceMock::onSetup");
	            }.bind(this));
	        }

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}
	         * @async
	         * @lifecycle service
	         */
	        async onServicesReady() {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> VideoServiceMock::onServicesReady()");
	            await super.onServicesReady();
	            _logger.log(_logger.LOG_SRVC_INOUT, "< VideoServiceMock::onServicesReady");
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ VideoServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$r = getServiceClass$u({
	    BaseService: BaseService$1,
	    ext: ext$3,
	    LogProvider
	});

	const ServiceInterface$r = {
	    VideoProxy: {
	        service: "../service/wn.UI.Service.VideoService.js",
	        interface: {
	            increaseVolume: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            decreaseVolume: {
	                type: "function",
	                callbackArgumentIndex: 1,
	            },
	            mute: {
	                type: "function",
	                callbackArgumentIndex: 0,
	            },
	            unmute: {
	                type: "function",
	                callbackArgumentIndex: 0,
	            },
	        },
	    },
	};

	var VideoService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$r,
		ServiceClass: ServiceClass$r
	});

	/**
	 @preserve
	 Copyright (c) 2001-2021 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.ViewServiceMock.js 4.3.1-210702-21-a51e474c-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$v = ({ jQuery, Wincor, BaseService, ext, LogProvider }) => {

	    /**
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider|*|Wincor.UI.Diagnostics.LogProvider|*}
	     * @private
	     */
	    const _logger = LogProvider;
	    
	    let _registrationID = 0;

	    return class ViewServiceMock extends BaseService {

	        /**
	         * "ViewServiceMock" - the logical name of this service as used in the service-provider.
	         * @const
	         * @type {string}
	         */
	        NAME = "ViewService";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#viewContext}.
	         */
	        viewContext = null;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#interactionTimerId}.
	         */
	        interactionTimerId = 0;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#interactionTimeoutValue}.
	         */
	        interactionTimeoutValue = -1;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#contentRunning}.
	         */
	        contentRunning = false;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#autoActivate}.
	         */
	        autoActivate = true;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#startURL}.
	         */
	        startURL = "../../content_softkey/views/index.html";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#previousViewUrl}.
	         */
	        previousViewUrl = "";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#isRestartOnNextDisplay}.
	         */
	        isRestartOnNextDisplay = false;

	        /**
	         * See {@link Wincor.UI.Service.ViewService#SERVICE_EVENTS}.
	         * @enum {string}
	         */
	        SERVICE_EVENTS = {
	            /**
	             * @see Wincor.UI.Service.ViewServiceMock#SERVICE_EVENTS:NAVIGATE_SPA
	             */
	            NAVIGATE_SPA: "NAVIGATE_SPA",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_CLOSING
	             */
	            VIEW_CLOSING: "VIEW_CLOSING",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_BEFORE_CHANGE
	             */
	            VIEW_BEFORE_CHANGE: "VIEW_BEFORE_CHANGE",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_PREPARED
	             */
	            VIEW_PREPARED: "VIEW_PREPARED",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:TURN_ACTIVE
	             */
	            TURN_ACTIVE: "TURN_ACTIVE",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:CONTENT_UPDATE
	             */
	            CONTENT_UPDATE: "CONTENT_UPDATE",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_ACTIVATED
	             */
	            VIEW_ACTIVATED: "VIEW_ACTIVATED",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:VIEW_USERINTERACTION_TIMEOUT
	             */
	            VIEW_USERINTERACTION_TIMEOUT: "VIEW_USERINTERACTION_TIMEOUT",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:STYLE_TYPE_CHANGED
	             */
	            STYLE_TYPE_CHANGED: "STYLE_TYPE_CHANGED",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:POPUP_ACTIVATED
	             */
	            POPUP_ACTIVATED: "POPUP_ACTIVATED",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:POPUP_DEACTIVATED
	             */
	            POPUP_DEACTIVATED: "POPUP_DEACTIVATED",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:REFRESH_TIMEOUT
	             */
	            REFRESH_TIMEOUT: "REFRESH_TIMEOUT",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:SHUTDOWN
	             */
	            SHUTDOWN: "SHUTDOWN",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:SUSPEND
	             */
	            SUSPEND: "SUSPEND",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:RESUME
	             */
	            RESUME: "RESUME",

	            /**
	             * @see Wincor.UI.Service.ViewService#SERVICE_EVENTS:LOCATION_CHANGED
	             */
	            LOCATION_CHANGED: "LOCATION_CHANGED"
	        };
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#EVENT_NAME_UIRESULT}.
	         */
	        EVENT_NAME_UIRESULT = "UIResult";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#EVENT_UIRESULT}.
	         */
	        EVENT_UIRESULT = null;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#EVENT_ACTIVATED}.
	         */
	        EVENT_ACTIVATED = null;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#EVENT_POPUP}.
	         */
	        EVENT_POPUP = null;
	    
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#EVENT_PREPARED}.
	         */
	        EVENT_PREPARED = null;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#EVENT_CONTENT_UPDATED}.
	         */
	        EVENT_CONTENT_UPDATED = null;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#UIRESULT_OK}.
	         */
	        UIRESULT_OK = "0";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#UIRESULT_TIMEOUT_USER}.
	         */
	        UIRESULT_TIMEOUT_USER = "2";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#UIRESULT_CANCEL_USER}.
	         */
	        UIRESULT_CANCEL_USER = "3";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#UIRESULT_CANCEL_SW}.
	         */
	        UIRESULT_CANCEL_SW = "4";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#UIRESULT_ERROR_VIEW}.
	         */
	        UIRESULT_ERROR_VIEW = "5";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#UIRESULT_CANCEL_SW_ERROR}.
	         */
	        UIRESULT_CANCEL_SW_ERROR = "8";

	        /**
	         * Value used in {@link Wincor.UI.Service.ViewService#endView} if the ViewService receives a cancel- of display request
	         * but there is no active view.
	         * @example
	         * UI_DETAILED_RESULT: {
	         *      CANCEL: "CANCEL",
	         *      DISPLAY: "DISPLAY"
	         * }
	         * @type {Object}
	         * @const
	         */
	        UI_DETAILED_RESULT = {
	            CANCEL: "CANCEL",
	            DISPLAY: "DISPLAY"
	        };

	        /**
	         * See {@link Wincor.UI.Service.ViewService#pageTimeout}.
	         */
	        pageTimeout = -1;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#immediateTimeout}.
	         */
	        immediateTimeout = 0;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#endlessTimeout}.
	         */
	        endlessTimeout = -1;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#messageTimeout}.
	         */
	        messageTimeout = 5000;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#confirmationTimeout}.
	         */
	        confirmationTimeout = 30000;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#inputTimeout}.
	         */
	        inputTimeout = 120000;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#pinentryTimeout}.
	         */
	        pinentryTimeout= 30000;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#urlMapping}.
	         */
	        urlMapping = {
	            "softkey": "../../content_softkey/views/index.html",
	            "touch": "../../content_touch/views/index.html"
	        };
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#resultMapping}.
	         */
	        resultMapping = null;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#DEFAULT_VIEWKEY_VALUES}.
	         */
	        DEFAULT_VIEWKEY_VALUES = {};
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#DEFAULT_TIMEOUT_VALUES}.
	         */
	        DEFAULT_TIMEOUT_VALUES = {};
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#KEYWORD_MAPPING}.
	         */
	        KEYWORD_MAPPING = {};
	    
	        /**
	         * This event is sent if there are missing data keys.
	         * Data keys are often part of a viewkey configuration and thus being resolved as well.
	         * @type {Object}
	         * @eventtype native
	         * @event  Wincor.UI.Service.ViewService#EVENT_MISSING_DATA_KEYS
	         */
	        EVENT_MISSING_DATA_KEYS = null;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#CONTENT_FRAME_NAME}.
	         */
	        CONTENT_FRAME_NAME = "#extendedDesignModeContent";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#restarting}.
	         */
	        restarting = false;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#cacheHTML}.
	         */
	        cacheHTML = false;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#viewSetName}.
	         */
	        viewSetName = "";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#adaViewSet}.
	         */
	        adaViewSet = "softkey";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#initialViewSet}.
	         */
	        initialViewSet = "softkey";
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#loadingViewSet}.
	         */
	        loadingViewSet = false;
	        

	        /**
	         * See {@link Wincor.UI.Service.ViewService#currentStyleType}.
	         */
	        currentStyleType = "MercuryDark"; // this property does not include the ending slash '/', because its gonna ask by getProperty and a slash would disturb

	        /**
	         * See {@link Wincor.UI.Service.ViewService#currentStyleTypeByStylesheetKey}.
	         */
	        currentStyleTypeByStylesheetKey = "";

	        /**
	         * See {@link Wincor.UI.Service.ViewService#currentVendor}.
	         */
	        currentVendor = "default"; // this property does not include the ending slash '/', because its gonna ask by getProperty and a slash would disturb

	        /**
	         * See {@link Wincor.UI.Service.ViewService#currentResolution}.
	         */
	        currentResolution = "default"; // this property does not include the ending slash '/', because its gonna ask by getProperty and a slash would disturb
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#suspendList}.
	         */
	        suspendList = [];
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#isSuspended}.
	         */
	        isSuspended = false;
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#suspendId}.
	         */
	        suspendId = 0;

	        viewMappings = {};

	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#constructor}.
	         * Prepare `DEFAULT_VIEWKEY_VALUES`, which contains the required parameters for every viewkey configuration.
	         * Initializes other members of this class.
	         * @lifecycle service
	         */
	        constructor(...args) {
	            super(...args);

	            _logger.log(_logger.LOG_SRVC_INOUT, "> ViewServiceMock::ViewServiceMock");

	            this.CONTENT_FRAME_NAME = `#${localStorage.getItem("activeFrameName")}`;

	            this.viewContext = {
	                viewKey: null,
	                viewKeyList: [],
	                viewURL: null,
	                viewConfig: {
	                    popup: {}
	                },
	                viewID: -1
	            };
	    
	            if(localStorage.getItem("activateTimeoutsOn") !== "true" && localStorage.getItem("activateCancelBehaviourOn") !== "true") {
	                this.messageTimeout = this.inputTimeout = this.endlessTimeout = this.immediateTimeout = this.confirmationTimeout = this.pinentryTimeout = -1;
	            }
	            this.DEFAULT_VIEWKEY_VALUES = {
	                "url": "",
	                "timeout": this.messageTimeout,
	                "popup": {
	                    "oncancel": true,
	                    "ontimeout": true,
	                    "beepontimeout": false,
	                    "beepontimeoutperiod": 0
	                }
	            };

	            this.EVENT_UIRESULT = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                eventName: this.EVENT_NAME_UIRESULT,
	                viewID: -1,
	                UIResult: null
	            });
	    
	            this.EVENT_ACTIVATED = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                viewID: -1,
	                viewKey: null,
	                eventName: "UIStateActivated"
	            });
	    
	            this.EVENT_CONTENT_UPDATED = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                viewKey: null,
	                eventName: "ContentUpdated"
	            });
	    
	            this.EVENT_MISSING_DATA_KEYS = Object.assign(Object.assign({}, this.EVENT), {
	                service: this.NAME,
	                viewID: -1,
	                viewKey: null,
	                eventName: "MissingDataKeys",
	                keys: []
	            });
	    
	            this.EVENT_UIRESULT.UILastButtonPressedEPPKey = [];

	            this.reReadErrorOccurred = false;
	            this.resultMapping = {};
	            this.startURL = "../../content_softkey/views/index.html";
	            this.previousViewUrl = "";
	            this.viewMappings = {};
	    
	            this.requestMap.set("display", this.display.bind(this));
	            this.requestMap.set("updateCurrent", this.updateCurrent.bind(this));

	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::ViewServiceMock");
	        }
	        
	        /**
	         * Get the used properties from the view mapping.
	         * The method does a static analyse of the view mapping data to search for business properties.
	         * @returns {Set} the used properties
	         */
	        getUsedProperties() {
	            let extractedProps = [];
	            let keys = Object.keys(this.viewMappings), viewKey, text;
	            for(let i = keys.length - 1; i >= 0; i--) {
	                viewKey = keys[i];
	                text = JSON.stringify(this.viewMappings[viewKey]);
	                extractedProps = extractedProps.concat(this.extractPropertiesFromText(text));
	            }
	            return new Set(extractedProps);
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#getContentWindowDocument}.
	         */
	        getContentWindowDocument(frmName) {
	            const $frame = jQuery(frmName);
	            return $frame.length > 0 ? $frame.contents()[0] : window.document; // due to unit test compatibility, because there is no iframe
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#loadContentUrl}.
	         */
	        loadContentUrl(url, frmName) {
	            Wincor.UI.Content = null;
	            const $frame = jQuery(frmName);
	            $frame.attr("src", url);
	            $frame.css("display", "block");
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#navigate}.
	         */
	        navigate(url) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceMock::navigate(${url})`);
	            if(!url) {
	                _logger.error(`ViewServiceMock::navigate, Navigation canceled due to mandatory 'url' argument is invalid -
                               please check UIMapping for viewkey=${this.viewContext.viewKey}`);
	                return;
	            }

	            if(this.isRestartOnNextDisplay) {
	                this.reStartSPA(url);
	                _logger.log(_logger.LOG_ANALYSE, `< ViewServiceMock::navigate restart of SPA necessary for destination=${url}`);
	                return;
	            }

	            // determine next SPA URL
	            // manipulate url to short version for durandal
	            const queryStringObj = Wincor.QueryString.get(url);
	            const queryString = Wincor.QueryString.stringify(queryStringObj);
	            const newUrl = Wincor.QueryString.getBaseUrl(url);
	            const routeName = !newUrl.includes(".html") && !newUrl.includes(".htm") ?
	                newUrl : newUrl.replace(".html", "").replace(".htm", ""); // only the name of the html file without extension
	            const destination = {
	                url: newUrl,
	                routeName: routeName,
	                lastViewUrl: this.previousViewUrl,
	                queryString: queryString,
	                viewKey: this.viewContext.viewKey
	            };
	            this.previousViewUrl = newUrl;
	            localStorage.setItem(`currentViewId_${document.location.href}`, routeName);
	            
	            //only in toolingEDM mode we will read the json files again
	            if(Wincor.toolingEDM) {
	                Wincor.UI.Service.Provider.DataService.updateJSONData()
	                .then(() => {
	                    Wincor.UI.Service.Provider.LocalizeService.updateJSONData()
	                    .then(() => {
	                        this.fireServiceEvent(this.SERVICE_EVENTS.NAVIGATE_SPA, destination);
	                        _logger.log(_logger.LOG_SRVC_INOUT, `< ViewServiceMock::navigate destination=${JSON.stringify(destination)}`);
	                    });
	                });
	            } else {
	                this.fireServiceEvent(this.SERVICE_EVENTS.NAVIGATE_SPA, destination);
	                _logger.log(_logger.LOG_SRVC_INOUT, `< ViewServiceMock::navigate destination=${JSON.stringify(destination)}`);
	            }
	        }

	        /**
	         * Starts the SPA by loading the initially given URL into the `iframe` of the the application content.
	         *
	         * @param {string} url          The url to start with, usually _index.html_.
	         * @param {boolean=} isRestart   True, if currently a restart is forced, false or undefined otherwise.
	         */
	        startSPA(url, isRestart) {
	            _logger.log(_logger.LOG_ANALYSE, `> ViewServiceMock::startSPA url=${url}, viewSetName=${this.viewSetName}`);
	            const readyForDisplay = ext.Promises.deferred();
	            if(!isRestart && localStorage.getItem("keepViewKeyOn") === "true") {
	                const viewKeyFromStorage = localStorage.getItem(`currentViewKey_${document.location.href}`);
	                if(viewKeyFromStorage !== null && viewKeyFromStorage !== "") {
	                    this.registerForServiceEvent(this.SERVICE_EVENTS.VIEW_ACTIVATED, async() => { //this is the activated event of index.html
	                        await readyForDisplay;
	                        setTimeout(() => this.display({viewKey: viewKeyFromStorage, viewURL: localStorage.getItem(`currentViewId_${document.location.href}`)}), 250);
	                    }, this.DISPOSAL_TRIGGER_ONETIME);
	                }
	            }
	            this.loadContentUrl(url, this.CONTENT_FRAME_NAME);
	            if(!Wincor.toolingEDM) {
	                jQuery("#extendedDesignMode").fadeIn({
	                    duration: 600, easing: "easeInQuart", complete: () => {
	                        jQuery(".spinner").css("display", "none");
	                        readyForDisplay.resolve();
	                    }
	                });
	            } else {
	                jQuery(".spinner").css("display", "none");
	                readyForDisplay.resolve();
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::startSPA");
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#reStartSPA}.
	         */
	        reStartSPA(url) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceMock::reStartSPA(${url})`);
	            this.isRestartOnNextDisplay = false;
	            localStorage.setItem("restartSPA", "true");
	            jQuery("body").attr("data-restart-spa", "true");
	            this.fireServiceEvent(this.SERVICE_EVENTS.SHUTDOWN);
	            _logger.log(_logger.LOG_ANALYSE, ". | VIEW ViewServiceMock::reStartSPA restarting!");
	            this.registerForServiceEvent(this.SERVICE_EVENTS.VIEW_ACTIVATED, () => { //this is the activated event of index.html
	                // decouple from service event (do not fire service event from within handler directly!)
	                setTimeout(() => {
	                    //SPA is restarted, now load the initial url:
	                    _logger.log(_logger.LOG_ANALYSE, `. | VIEW ViewServiceMock::reStartSPA navigating to ${url}`);
	                    this.fireServiceEvent(this.SERVICE_EVENTS.VIEW_CLOSING, this.getContentWindowDocument(this.CONTENT_FRAME_NAME).location.href);
	                    this.fireBeforePageChange({});
	                    this.restarting = false;
	                    this.navigate(url);
	                    localStorage.setItem("restartSPA", "false");
	                    jQuery("body").attr("data-restart-spa", "false");
	                }, 250);
	            }, this.DISPOSAL_TRIGGER_ONETIME);
	            //Wincor.UI.Content = null;
	            this.restarting = true;
	            jQuery("#extendedDesignMode").fadeOut({ duration: 600, easing: "easeOutQuart", complete: () => this.startSPA(this.startURL, true) }); //load the new index.html of the new viewset
	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::reStartSPA");
	        }

	        /**
	         * This function is called by the business logic to display a specific view.
	         * The result will be send as event, see {@link Wincor.UI.Service.ViewService#EVENT_UIRESULT}.
	         *
	         * @param {Object} message The message contains must contain the `viewKey`.
	         * @param {Boolean=} [autoActivate=true] True if the view shall be activated, too.
	         */
	        display(message, autoActivate = true) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceMock::display() message=${JSON.stringify(message)}`);
	            this.autoActivate = autoActivate;
	            if(this.contentWindowExists()) {
	                this.endView(this.UIRESULT_CANCEL_SW, this.UI_DETAILED_RESULT.DISPLAY);  //send a GUIResult for the currently running view. endView() checks if content is running
	            }
	            
	            function triggerNavigation() {
	                if(message.viewKey && !message.viewKey.includes("_")) {
	                    if(this.viewMappings[message.viewKey]) {
	                        // toolingEDM:
	                        // Please note:
	                        // Tooling also expects that the template keys such as "AmountSelection", "Message", etc. are treated as
	                        // normal viekeys.
	                        // As we know, such templates (aka defaults) aren't valid viekeys and thus there are no viekey specific text keys, viewkey specific business data
	                        // and no flow available.
	                        // This usually leads into subsequent, unpredictable runtime problems, such as undefines, promise rejections, etc.
	                        // In order to prevent from this the idea is to redirect such a template key to its bound correspond viewkey, so e.g. "AmountSelection" template is
	                        // usually bound to "FastCashPreferenceAmountSelection" and we redirect to this key, due to this key is a valid viewkey with valid configuration and
	                        // a correct set of texts and data.
	                        // In order to satisfy tooling with the redirection all event messages sent to it via web socket connection must contain the displayed key, even
	                        // we internally work with the redirected one.
	                        // Additionally we add a the "redirectedToViewKey" attribute to each of the events to inform tooling about this circumstance.
	                        if(Wincor.toolingEDM && this.viewMappings[message.viewKey].isTemplate && !this.viewMappings[message.viewKey].fromTemplateKey) {
	                            // Please note:
	                            // We redirect the display key to the remembered known valid viewkey,
	                            // because the display key argument is a template and usually there are neither viekey specific text nor business data available for it
	                            // and then typically leads into different exceptions (undefined, promise rejections, etc.)
	                            // until to an invalid EDM state from where a browser restart might be necessary.
	                            message.viewKeyRedirect = true;
	                            message.redirectFrom = message.viewKey;
	                            message.viewKey = this.viewMappings[message.viewKey].targetViewKey;
	                            message.redirectTo = message.viewKey;
	                        }
	                        this.contentRunning = true;
	                        this.fireBeforePageChange(message);
	                        message.viewID = message.viewID || message.viewURL;
	                        this.setViewContext(message, this.viewMappings[message.viewKey]);
	                        this.navigate(this.viewContext.viewConfig.url);
	                        if(localStorage.getItem("keepViewKeyOn") === "true") {
	                            localStorage.setItem(`currentViewKey_${document.location.href}`, message.viewKey);
	                        }
	                    } else {
	                        _logger.error(`Couldn't get value for viewKey=${message.viewKey} which is unknown - please check/update ViewKey mapping !`);
	                        return false;
	                    }
	                } else {
	                    _logger.error(`Viewkey viewKey=${message.viewKey} does not meet the conventions, may contain illegal char such as '_', please check/update ViewKey mapping !`);
	                    return false;
	                }
	                _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::display");
	                return true;
	            }
	            
	            if(Wincor.toolingEDM) {
	                this.updateJSONData()
	                    .then(() => {
	                        return triggerNavigation.call(this);
	                    });
	            } else {
	                return triggerNavigation.call(this);
	            }
	        }
	    
	        /**
	         * This function is called by Tooling to read the JSON files again and update the currently displayed view.
	         * If the content was updated succesfully, we send CONTENT_UPDATED.
	         */
	        updateCurrent() {
	            //register for ACTIVATED_EVENT. If it is triggered send the CONTENT_UPDATED event, too.
	            //CONTENT_UPDATED is what Tooling is interested in, not in the ACTIVATED_EVENT.
	            //Some day we could change this code, so that we
	            // * do not call display() (which internally reads in all JSON again)
	            // * instead read in the JSON files again and re-bind every view element
	            // * then we do not need to register on ACTIVATED_EVENT anymore
	            // * but then we must find another point in time to when we send the CONTENT_UPDATED event.
	            _registrationID = this.registerForServiceEvent(this.SERVICE_EVENTS.VIEW_ACTIVATED, () => {
	                this.EVENT_CONTENT_UPDATED.viewKey = this.viewContext.viewKey;
	                this.sendEvent(this.EVENT_CONTENT_UPDATED);
	    
	                this.deregisterFromServiceEvent(_registrationID);
	            }, true);
	            
	            this.display({
	                viewKey: this.viewContext.viewKey
	            });
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#prepare}.
	         */
	        prepare(message) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceMock::display() message=${JSON.stringify(message)}`);
	            this.display(message, false);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::display");
	            return true;
	        }
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#activate}.
	         */
	        activate() {
	            setTimeout(() => this.fireServiceEvent(this.SERVICE_EVENTS.TURN_ACTIVE), 1);
	        }
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#setViewContext}.
	         */
	        setViewContext(message, viewKeyValue) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceMock::setViewContext() viewKey=${message.viewKey} value=${JSON.stringify(viewKeyValue)}`);
	            
	            function sendMessageMissingDataKeys(missingKeys) {
	                if(missingKeys.length > 0) {
	                    this.EVENT_MISSING_DATA_KEYS.viewID = this.viewContext.viewID;
	                    this.EVENT_MISSING_DATA_KEYS.viewKey = this.viewContext.viewKey;
	                    if(this.viewContext.viewKeyRedirect) {
	                        this.EVENT_MISSING_DATA_KEYS.viewKey = this.viewContext.redirectFrom; // overwrite to satisfy tooling
	                        this.EVENT_MISSING_DATA_KEYS.redirectedToViewKey = this.viewContext.redirectTo;
	                    } else {
	                        delete this.EVENT_MISSING_DATA_KEYS.redirectedToViewKey;
	                    }
	                    this.EVENT_MISSING_DATA_KEYS.keys = missingKeys;
	                    this.sendEvent(this.EVENT_MISSING_DATA_KEYS);
	                }
	            }
	    
	            this.viewContext.viewKey = message.viewKey !== "" ? message.viewKey : "*";
	            // toolingEDM
	            if(Wincor.toolingEDM) {
	                if(message.viewKeyRedirect) {
	                    this.viewContext.viewKeyRedirect = true;
	                    this.viewContext.redirectFrom = message.redirectFrom;
	                    this.viewContext.redirectTo = message.redirectTo;
	                } else {
	                    delete this.viewContext.viewKeyRedirect;
	                    delete this.viewContext.redirectFrom;
	                    delete this.viewContext.redirectTo;
	                }
	            }
	            
	            this.setViewKey(this.viewContext.viewKey); // set view key in BaseServiceMock
	            this.setViewCtx(this.viewContext); // set view context in BaseServiceMock
	            if(viewKeyValue) {
	                // TODO: 2016-03-30-workaround: view models expecting attr "placeHolder" instead of "placeholder". Remove this workaround, if tooling metadata corrected to "placeHolder"
	                if(viewKeyValue.config && viewKeyValue.config.placeholder) {
	                    viewKeyValue.config.placeHolder = viewKeyValue.config.placeholder;
	                }
	                const missingDataKeys = [];
	                this.viewContext.viewURL = this.propResolver(viewKeyValue.url, this.serviceProvider.DataService.businessData, missingDataKeys);
	                this.viewContext.viewConfig = jQuery.extend(true, {}, this.DEFAULT_VIEWKEY_VALUES, viewKeyValue);
	                if(!Wincor.toolingEDM) {
	                    this.viewContext.viewID = !this.viewContext.viewURL.includes(".htm") ? this.viewContext.viewURL : this.viewContext.viewURL.substr(0, this.viewContext.viewURL.indexOf(".htm"));
	                } else {
	                    // tooling expecting to have the viewID as an ongoing number, with each display call a unique ID is expected
	                    this.viewContext.viewID = message.viewID || -1;
	                }
	                if(this.viewContext.viewConfig) {
	                    if(localStorage.getItem("activateTimeoutsOn") === "true") {
	                        const time = jQuery.isNumeric(viewKeyValue.timeout) ? parseInt(viewKeyValue.timeout) : -1;
	                        this.viewContext.viewConfig.timeout = time;
	                        this.interactionTimeoutValue = time;
	                    } else {
	                        this.viewContext.viewConfig.timeout = -1;
	                        this.interactionTimeoutValue = this.pageTimeout;
	                    }
	                    this.viewContext.viewConfig.popup.oncancel = this.viewContext.viewConfig.popup.oncancel && localStorage.getItem("activateCancelBehaviourOn") === "true";
	                    this.viewContext.viewConfig = JSON.parse(this.propResolver(JSON.stringify(this.viewContext.viewConfig), this.serviceProvider.DataService.businessData, missingDataKeys));
	                    this.viewContext.viewConfig = this.correctJSONObject(this.viewContext.viewConfig, message.viewKey);
	                }
	                if(Wincor.toolingEDM) {
	                    sendMessageMissingDataKeys.call(this, missingDataKeys); // missing data keys from prop resolving of the view mapping for this viewkey
	                }
	                _logger.log(_logger.LOG_SRVC_DATA, `. viewKey=${this.viewContext.viewKey} viewURL=${this.viewContext.viewURL}, viewConfig: \n ${JSON.stringify(this.viewContext.viewConfig, null, " ")}`);
	            }
	            if(!this.viewContext.viewConfig) {
	                _logger.error(`Couldn't get configuration for viewKey=${message.viewKey} <-- seems to be invalid. This may lead into subsequent errors !`);
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::setViewContext");
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#correctJSONObject}.
	         */
	        correctJSONObject(result, viewKey, recursionCount = 0){
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceMock::correctJSONObject(${recursionCount}): key ${viewKey}=${JSON.stringify(result)}`);
	            const keys = Object.keys(result);
	            for(let i = 0; i < keys.length; i++) {
	                const key = keys[i];
	                const value = result[key];
	                if(typeof value === "object" && !Array.isArray(value)) {
	                    this.correctJSONObject(value, key, recursionCount + 1);
	                } else if(typeof value === "string") {
	                    result[key] = this.correctValue(value);
	                }
	            }
	            _logger.log(_logger.LOG_ANALYSE, `< ViewServiceMock::correctJSONObject(${recursionCount}): changed key ${viewKey}=${JSON.stringify(result)}`);
	            return result;
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#correctValue}.
	         */
	        correctValue(inputString) {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> ViewServiceMock::correctValue=" + inputString);
	            let value = inputString;

	            // check if defaultString could be parsed to an int
	            // REMARK: If the string only contains numbers, but begins with zero we omit the parsing and let the string as it is,
	            // otherwise we would lose the leading "0" -> (e.g. "017812345555" would be converted to 17812345555)
	    
	            const tmpString = value;

	            if (jQuery.isNumeric(tmpString) && (tmpString.length === 1 || tmpString[0] !== "0")) {
	                value = parseInt(tmpString);
	            }

	            // check if input value is a boolean
	            if(tmpString === "true") {
	                value = true;
	            } else if(tmpString === "false") {
	                value = false;
	            }

	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::correctValue returns=" + value);
	            return value;
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#offlineHandling}.
	         * */
	        offlineHandling(resultDetail) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceMock::offlineHandling(${resultDetail})`);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::offlineHandling");
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#endView}.
	         * */
	        endView(resultCode, resultDetail) {
	            _logger.log(_logger.LOG_ANALYSE, `. ViewServiceMock::endView(${resultCode}, ${resultDetail})`);
	            this.clearTimeout();
	            this.fireServiceEvent(this.SERVICE_EVENTS.REFRESH_TIMEOUT, -1);

	            if(this.contentRunning) {
	                this.contentRunning = false;
	                let value;
	                if(resultDetail === void 0 || resultDetail === null) {
	                    if(resultCode === this.UIRESULT_CANCEL_USER ||
	                       resultCode === this.UIRESULT_ERROR_VIEW ||
	                       resultCode === this.UIRESULT_CANCEL_SW ||
	                       resultCode === this.UIRESULT_CANCEL_SW_ERROR ||
	                       resultCode === this.UIRESULT_TIMEOUT_USER) {

	                        this.EVENT_UIRESULT.UIResult = resultCode;
	                        this.EVENT_UIRESULT.UIDetailedResult = "";
	                        // resultMapping
	                        if(this.resultMapping && this.resultMapping[resultCode] !== void 0) {
	                            resultDetail = `mappedFrom:${resultCode}:`;
	                            resultCode = this.resultMapping[resultCode];
	                            this.EVENT_UIRESULT.UIResult = resultCode;
	                            this.EVENT_UIRESULT.UIDetailedResult = resultDetail;
	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `. ViewService::endView resultMapping (no result detail) configured! Mapping to '${resultCode}'/'${resultDetail}'`);
	                        }
	                    } else {
	                        // Do not let this one pass! It's an error!
	                        _logger.error("ViewService::endView no resultDetail (interactionResult) argument given! Returning UIRESULT_ERROR_VIEW!");
	                        this.EVENT_UIRESULT.UIResult = this.UIRESULT_ERROR_VIEW;
	                        this.EVENT_UIRESULT.UIDetailedResult = "MISSING_INTERACTION_RESULT"; // just to be traceable
	                    }
	                } else {
	                    // resultMapping
	                    this.EVENT_UIRESULT.UIResult = resultCode;
	                    this.EVENT_UIRESULT.UIDetailedResult = resultDetail;
	                    if(this.resultMapping && this.resultMapping[resultCode] !== void 0) {
	                        resultDetail = `mappedFrom:${resultCode}:`;
	                        resultCode = this.resultMapping[resultCode];
	                        this.EVENT_UIRESULT.UIResult = resultCode;
	                        this.EVENT_UIRESULT.UIDetailedResult = resultDetail;
	                        _logger.LOG_SRVC_DATA && _logger.log(_logger.LOG_SRVC_DATA, `. ViewService::endView resultMapping (result detail given) configured! Mapping to '${resultCode}'/'${resultDetail}'`);
	                    }
	                }
	                if(resultCode === this.UIRESULT_CANCEL_USER) {
	                    value = "C";
	                } else if(resultCode === this.UIRESULT_TIMEOUT_USER) {
	                    value = "T";
	                }
	                if(value) {
	                    this.serviceProvider.DataService.setValues("PROP_TRANSACTION_STATUS", value);
	                }
	                // Do not set contentRunning later (even not after _logger.log) because when using the send-event methods of the gateway the main thread is interruptable.
	                // Then, Cancel() might be called, which also uses contentRunning. That must then aleady be false.
	                // See also comment in processDisplay() method
	                _logger.log(_logger.LOG_ANALYSE, `* | VIEW ------ endView ------ ${resultCode}/${resultDetail}`);
	                this.fireServiceEvent(this.SERVICE_EVENTS.VIEW_CLOSING, {
	                    initiator: "endView", viewKey: this.viewContext.viewKey, resultCode: resultCode, resultDetail: resultDetail
	                });
	            }
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#cancel}.
	         */
	        cancel(message) {
	            _logger.log(_logger.LOG_ANALYSE, `. ViewServiceMock::cancel('${JSON.stringify(message)}')`);
	            if(this.contentRunning) {
	                this.endView(this.UIRESULT_CANCEL_SW, this.UI_DETAILED_RESULT.CANCEL);
	            }
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#fireBeforePageChange}.
	         */
	        fireBeforePageChange(msg) {
	            _logger.log(_logger.LOG_ANALYSE, `. ViewServiceMock::fireBeforePageChange(${JSON.stringify(msg)})`);
	            this.fireServiceEvent(this.SERVICE_EVENTS.VIEW_BEFORE_CHANGE, msg);
	        }


	        /**
	         * See {@link Wincor.UI.Service.ViewService#fireActivated}.
	         * However there is no need to send {@link Wincor.UI.Service.ViewService#EVENT_ACTIVATED}, because there is no business logic.
	         *
	         */
	        fireActivated() {
	            _logger.log(_logger.LOG_ANALYSE, ". ViewServiceMock::fireActivated()");
	            const handled = this.fireServiceEvent(this.SERVICE_EVENTS.VIEW_ACTIVATED, {
	                href: this.getContentWindowDocument(this.CONTENT_FRAME_NAME).location.href,
	                viewContext: jQuery.extend(true, {}, this.viewContext)
	            });
	            
	            this.EVENT_ACTIVATED.viewID = this.viewContext.viewID;
	            this.EVENT_ACTIVATED.viewKey = this.viewContext.viewKey;
	            // toolingEDM
	            if(this.viewContext.viewKeyRedirect) {
	                this.EVENT_ACTIVATED.viewKey = this.viewContext.redirectFrom; // overwrite to satisfy tooling
	                this.EVENT_ACTIVATED.redirectedToViewKey = this.viewContext.redirectTo;
	            } else {
	                delete this.EVENT_ACTIVATED.redirectedToViewKey;
	            }
	            this.sendEvent(this.EVENT_ACTIVATED);
	            
	            if(!handled) {
	                // ada f.e will handle the timeouts by itself
	                this.refreshTimeout();
	            }
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#firePopupNotification}.
	         * However there is no need to send {@link Wincor.UI.Service.ViewService#EVENT_POPUP}, because there is no business logic.
	         */
	        firePopupNotification(active, type) {
	            _logger.log(_logger.LOG_ANALYSE, `. ViewServiceMock::firePopupNotification(${type} active: ${active})`);
	            this.fireServiceEvent(active?this.SERVICE_EVENTS.POPUP_ACTIVATED:this.SERVICE_EVENTS.POPUP_DEACTIVATED, type?type:void 0);
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#fireContentUpdated}.
	         * However there is no need to send {@link Wincor.UI.Service.ViewService#CONTENT_UPDATE}.
	         */
	        fireContentUpdated(data) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceMock::fireContentUpdated(${data})`);
	            this.fireServiceEvent(this.SERVICE_EVENTS.CONTENT_UPDATE, data);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< ViewServiceMock::fireContentUpdated`);
	        }
	    
	        /**
	         * See {@link Wincor.UI.Service.ViewService#firePrepared}.
	         * However there is no need to send {@link Wincor.UI.Service.ViewService#EVENT_PREPARED}, because there is no business logic.
	         */
	        firePrepared() {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> ViewServiceMock::firePrepared()");
	            this.fireServiceEvent(this.SERVICE_EVENTS.VIEW_PREPARED);
	            //this informs the subscribers that they  have to activate themselves
	            if (this.autoActivate) {
	                setTimeout(()=>this.fireServiceEvent(this.SERVICE_EVENTS.TURN_ACTIVE), 1);
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::firePrepared");
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#onTimeout}.
	         */
	        onTimeout() {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> ViewServiceMock::onTimeout()");
	            this.interactionTimerId = null;
	            if(!this.fireServiceEvent(this.SERVICE_EVENTS.VIEW_USERINTERACTION_TIMEOUT)) {
	                this.endView(this.UIRESULT_TIMEOUT_USER);
	            }
	            else {
	                _logger.log(_logger.LOG_ANALYSE, ". timeout was handled by one of the subscribers");
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::onTimeout");
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#refreshTimeout}.
	         */
	        refreshTimeout(newHigherTimeoutValue, force) {
	            if(localStorage.getItem("activateTimeoutsOn") !== "true") { // do nothing if timeout handling isn't desired.
	                return;
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, "> ViewServiceMock::refreshTimeout()");
	            const orgInteractionTimeoutValue = this.interactionTimeoutValue; // for the case there is a foreign timeout handler (-isHandled=true)
	            if(newHigherTimeoutValue && (force || (newHigherTimeoutValue > this.interactionTimeoutValue))) {
	                _logger.log(_logger.LOG_DETAIL, `. updating timeout from ${this.interactionTimeoutValue}ms to ${newHigherTimeoutValue}ms`);
	                this.interactionTimeoutValue = newHigherTimeoutValue;
	            }
	            const isHandled = this.fireServiceEvent(this.SERVICE_EVENTS.REFRESH_TIMEOUT, this.interactionTimeoutValue);
	            if(!isHandled) {
	                this.clearTimeout();
	                if(this.interactionTimeoutValue === this.immediateTimeout) {
	                    this.interactionTimerId = setTimeout(this.onTimeout.bind(this), 1); //1ms so that this method can return
	                } else if(this.interactionTimeoutValue > this.immediateTimeout && this.contentRunning) {
	                    this.interactionTimerId = setTimeout(this.onTimeout.bind(this), this.interactionTimeoutValue);
	                }
	            } else {
	                this.interactionTimeoutValue = orgInteractionTimeoutValue; // restore
	                _logger.log(_logger.LOG_SRVC_INOUT, ". ViewServiceMock::refreshTimeout not processed - event handled by subscriber: ");
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, `< ViewServiceMock::refreshTimeout - value: ${this.interactionTimeoutValue}`);
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#resetUserInteractionTimeout}.
	         */
	        resetUserInteractionTimeout() {
	            this.refreshTimeout();
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#getTimeoutValue}.
	         */
	        getTimeoutValue() {
	            return this.interactionTimeoutValue;
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#clearTimeout}.
	         */
	        clearTimeout() {
	            if(localStorage.getItem("activateTimeoutsOn") !== "true") { // do nothing if timeout handling isn't desired.
	                return;
	            }
	            let done = false;
	            _logger.log(_logger.LOG_SRVC_INOUT, "> ViewServiceMock::clearTimeout()");
	            if(this.interactionTimerId !== 0) {
	                window.clearTimeout(this.interactionTimerId);
	                done = true;
	                this.interactionTimerId = 0;
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, `< ViewServiceMock::clearTimeout returns done=${done}`);
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#contentWindowExists}.
	         */
	        contentWindowExists() {
	            return jQuery(this.CONTENT_FRAME_NAME).attr("src") !== "";
	        }
	    
	        /**
	         * Resizes/repositions the browser window.
	         * @param {Object} posObject        Contains attributes `top`, `left`, `width` and `height` of type number.
	         * @param {function=} callback      The callback function, which is called as soon as there is a response. Gets a number a boolean as argument -- `true` is for success.
	         */
	        resizeWindow(posObject, callback) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceMock::resizeWindow(${JSON.stringify(posObject)})`);
	            if(typeof callback === "function") {
	                callback();
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::resizeWindow");
	        }
	        
	        /**
	         * See {@link Wincor.UI.Service.ViewService#onError}, but on the contrary to that implementation, the view will not end.
	         */
	        onError(serviceName, errorType) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceMock::onError(${serviceName}, ${errorType})`);
	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::onError");
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#suspend}.
	         */
	        suspend() {
	            this.suspendId++;
	            this.suspendList.push(this.suspendId);
	            this.logger.LOG_SRVC_INOUT && this.logger.log(this.logger.LOG_SRVC_DATA, `> ViewService::suspend() isSuspended=${this.isSuspended}`);
	            // Event is only sent on first call to suspend! When already suspended we just return suspendId
	            if (!this.isSuspended) {
	                this.fireServiceEvent(this.SERVICE_EVENTS.SUSPEND);
	                this.isSuspended = true;
	                this.clearTimeout();
	            }
	            this.logger.LOG_SRVC_INOUT && this.logger.log(this.logger.LOG_SRVC_DATA, `< ViewService::suspend returns suspendId ${this.suspendId}`);
	            return this.suspendId;
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#resume}.
	         */
	        resume(suspendId) {
	            this.logger.LOG_SRVC_INOUT && this.logger.log(this.logger.LOG_SRVC_DATA, `> ViewService::resume(${suspendId}) of ${JSON.stringify(this.suspendList)}`);
	            const index = this.suspendList.indexOf(suspendId);
	            if (index > -1) {
	                this.suspendList.splice(index, 1);
	            }
	            if (this.suspendList.length === 0) {
	                this.isSuspended = false;
	                this.fireServiceEvent(this.SERVICE_EVENTS.RESUME);
	                this.refreshTimeout();
	            }
	            this.logger.LOG_SRVC_INOUT && this.logger.log(this.logger.LOG_SRVC_DATA, `< ViewService::resume - remaining:${JSON.stringify(this.suspendList)}`);
	            return !this.isSuspended;
	        }


	        /**
	         * See {@link Wincor.UI.Service.ViewService#bringToFront}, but not implemented by the mock, because there is no need for window handling.
	         */
	        bringToFront(callback) {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> ViewServiceMock::bringToFront()");
	            if(callback) {
	                callback({RC: 0});
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::bringToFront");
	        }

	        /**
	         * See {@link Wincor.UI.Service.ViewService#readConfiguration}.
	         *
	         * The Mock's implementation will just call {@link Wincor.UI.Service.ViewService#onSetup}, because in that function we will read the configuration.
	         */
	        readConfiguration() {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> ViewServiceMock::update()");
	            this.onSetup({viewSetName: this.viewSetName});
	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::update");
	        }


	        /**
	         * See {@link Wincor.UI.Service.ViewService#swapLocation}, but not implemented by the mock, because there is no need for window handling.
	         */
	        swapLocation(targetInstance="") {
	            _logger.log(_logger.LOG_DETAIL, `* ViewServiceMock::swapLocation(${targetInstance}) not implemented in mock.`);
	            return ext.Promises.Promise.resolve(0);
	        }
	        

	        /**
	         * See {@link Wincor.UI.Service.ViewService#loadViewSet}.
	         */
	        async loadViewSet(viewSetName, immediately) {
	            this.loadingViewSet = true;
	            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `> | VIEW ViewServiceMock::loadViewSet viewSetName=${viewSetName}, immediately=${immediately}`);
	            const oldViewSetName = this.viewSetName;
	            this.previousViewUrl = "";
	            this.viewSetName = viewSetName !== "" ? viewSetName : this.initialViewSet; // use initial view set if viewSetName is empty
	            // read defaultConfig and uimapping of this viewset
	            await this.onSetup({viewSetName: this.viewSetName});
	            try {
	                _logger.log(_logger.LOG_SRVC_DATA, "* ViewServiceMock::loadViewSet ready reading viewkeys of " + viewSetName);
	                this.startURL = this.urlMapping[this.viewSetName];
	                if(immediately) {
	                    _logger.log(_logger.LOG_SRVC_DATA, ". | VIEW ViewServiceMock::loadViewSet immediately restarting...");
	                    this.registerForServiceEvent(this.SERVICE_EVENTS.VIEW_ACTIVATED, () => {
	                        setTimeout(() => {
	                            this.restarting = false;
	                            _logger.log(_logger.LOG_SRVC_DATA, ". | VIEW ViewServiceMock::loadViewSet navigating");
	                            this.endView(this.UIRESULT_CANCEL_SW);
	                        }, 250);
	                    }, this.DISPOSAL_TRIGGER_ONETIME);
	                    this.restarting = true;
	                    _logger.log(_logger.LOG_SRVC_DATA, ". | VIEW ViewServiceMock::loadViewSet immediately loading into content.");
	                    // restart the SPA with the current view URL.
	                    // The real runtime would do a new display, so that at this place (in real ViewService) is a startSPA instead
	                    this.reStartSPA(this.viewContext.viewURL);
	                } else {
	                    _logger.log(_logger.LOG_SRVC_DATA, ". | VIEW ViewServiceMock::loadViewSet postponing restart");
	                    this.isRestartOnNextDisplay = true; // postpone restart
	                }
	                this.loadingViewSet = false;
	            } catch(e) {
	                this.serviceProvider.propagateError(this.NAME, "loadViewSet", e);
	                this.loadViewSet(oldViewSetName, true);
	                throw e;
	            }
	            _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::loadViewSet");
	        }
	    
	        /**
	         * This will read (again) all data from the JSON files.
	         * This was originally done in onSetup, but now moved into a separate function, to be called anytime.
	         *
	         * @async
	         */
	        async updateJSONData() {
	            this.logger.log(this.logger.LOG_SRVC_INOUT, "> ViewServiceMock::updateJSONData()");
	            const [profile, profileExtension] = await this.getToolingProfile();
	            if(profile === "") {
	                const FILE_VIEW_MAPPINGS = `../servicemocks/mockdata/${this.viewSetName}/ViewMappings.json`;
	                const FILE_VIEW_MAPPINGS_CUSTOM = `../servicemocks/mockdata/${this.viewSetName}/ViewMappingsCustom.json`;
	                const FILE_VIEW_MAPPINGS_DEFAULTS = `../servicemocks/mockdata/${this.viewSetName}/ViewMappingsDefaults.json`;
	                const FILE_VIEW_MAPPINGS_DEFAULTS_CUSTOM = `../servicemocks/mockdata/${this.viewSetName}/ViewMappingsDefaultsCustom.json`;
	                const FILE_VIEW_MAPPINGS_CONSTS = `../servicemocks/mockdata/${this.viewSetName}/ViewMappingsConsts.json`;
	                try {
	                    const mappingArray = await Promise.all([
	                        this.retrieveJSONData(FILE_VIEW_MAPPINGS),                  // 0
	                        this.retrieveJSONData(FILE_VIEW_MAPPINGS_CUSTOM),           // 1
	                        this.retrieveJSONData(FILE_VIEW_MAPPINGS_DEFAULTS),         // 2
	                        this.retrieveJSONData(FILE_VIEW_MAPPINGS_DEFAULTS_CUSTOM),  // 3
	                        this.retrieveJSONData(FILE_VIEW_MAPPINGS_CONSTS)]);         // 4
	                    delete mappingArray[1]["//"]; // remove possible comment from MappingsCustom
	                    delete mappingArray[3]["//"]; // remove possible comment from MappingsDefaultCustom
	                    this.viewMappings = Object.assign({}, mappingArray[0], mappingArray[1]);  // mapping
	                    const templateViewKeyList = Object.assign({}, mappingArray[2], mappingArray[3]);
	                    // replace viewKey default variables with their concrete values:
	                    this.replaceInMapping(this.viewMappings, templateViewKeyList); // replace with defaults (aka viewkey templates)
	                    // Tooling EDM: Add the default (aka viewkey templates) to the viewkey mapping list as well
	                    if(Wincor.toolingEDM) {
	                        Object.assign(this.viewMappings, templateViewKeyList);
	                    }
	                    // replace viewKey default variables with their concrete values:
	                    this.replaceInMapping(this.viewMappings, mappingArray[4]); // constants
	                    // delete unnecessary stuff
	                    delete this.viewMappings.Defaults;
	                    delete this.viewMappings.Index;
	                    this.viewContext.viewKeyList = []; // reset
	                    const viewKeys = Object.keys(this.viewMappings);
	                    for(let i = 0; i < viewKeys.length; i++) {
	                        const key = viewKeys[i]; // view key
	                        const value = this.viewMappings[key];
	                        if(!value.url) {
	                            throw `UIMapping: Mapping for viewKey=${key} is invalid due to missing or invalid, mandatory 'url' attribute !`;
	                        }
	                        this.viewContext.viewKeyList.push({name: key, url: value.url, viewConfig: value});
	                    }
	                    this.logger.log(this.logger.LOG_SRVC_INOUT, "< ViewServiceMock::onSetup");
	                } catch(e) {
	                    console.error(`* importReference error getting ${FILE_VIEW_MAPPINGS}, ${FILE_VIEW_MAPPINGS_CUSTOM}, ${FILE_VIEW_MAPPINGS_DEFAULTS}, ${FILE_VIEW_MAPPINGS_DEFAULTS_CUSTOM} or ${FILE_VIEW_MAPPINGS_CONSTS}`);
	                    throw e;
	                }
	            } else { //Tooling 2.0
	                const FILE_VIEW_MAPPINGS = `../servicemocks/mockdata/${this.viewSetName}/ViewMappings${profileExtension}.json`;
	                const FILE_VIEW_MAPPINGS_TEMPLATES = `../servicemocks/mockdata/${this.viewSetName}/ViewMappingsTemplates${profileExtension}.json`;
	                const FILE_VIEW_MAPPINGS_CONSTS = `../servicemocks/mockdata/${this.viewSetName}/ViewMappingsConsts${profileExtension}.json`;
	                try {
	                    const mappingArray = await Promise.all([
	                        this.retrieveJSONData(FILE_VIEW_MAPPINGS),             // 0
	                        this.retrieveJSONData(FILE_VIEW_MAPPINGS_TEMPLATES),   // 1
	                        this.retrieveJSONData(FILE_VIEW_MAPPINGS_CONSTS)]);    // 2
	                    this.viewMappings = Object.assign({}, mappingArray[0]);
	                    const templateViewKeyList = Object.assign({}, mappingArray[1]);
	                    // replace viewKey default variables with their concrete values:
	                    this.replaceTemplateUsage(this.viewMappings, templateViewKeyList); // templates
	                    // Tooling EDM: Add the default (aka viewkey templates) to the viewkey mapping list as well
	                    if(Wincor.toolingEDM) {
	                        Object.assign(this.viewMappings, templateViewKeyList);
	                    }
	                    // replace viewKey default variables with their concrete values:
	                    this.replaceInMapping(this.viewMappings, mappingArray[2]); // constants
	                    // delete unnecessary stuff
	                    delete this.viewMappings.Index;
	                    this.viewContext.viewKeyList = []; // reset
	                    const viewKeys = Object.keys(this.viewMappings);
	                    for(let i = 0; i < viewKeys.length; i++) {
	                        const key = viewKeys[i]; // view key
	                        const value = this.viewMappings[key];
	                       if (!value.url) {
	                            throw `UIMapping for tooling: Mapping for viewKey=${key} is invalid due to missing or invalid, mandatory 'url' attribute !`;
	                        }
	                        this.viewContext.viewKeyList.push({name: key, url: value.url, data: value});
	                    }
	                    this.logger.log(this.logger.LOG_SRVC_INOUT, "< ViewServiceMock::updateJSONData");
	                } catch(e) {
	                    console.error(`* importReference error getting ${FILE_VIEW_MAPPINGS}, ${FILE_VIEW_MAPPINGS_TEMPLATES} or ${FILE_VIEW_MAPPINGS_CONSTS}`);
	                    throw e;
	                }
	            }
	        }
	        
	        /**
	         * See {@link Wincor.UI.Service.BaseServiceMock#onSetup}.
	         * The ViewServiceMock implementation will read the data from the Tooling-generated JSON files.
	         * @param {Object} message
	         * @returns {Promise}
	         * @see {@link Wincor.UI.Service.BaseServiceMock#onSetup}
	         * @lifecycle service
	         */
	        onSetup(message) {
	            _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceMock::onSetup('${JSON.stringify(message)}')`);
	            if(message && message.viewSetName) { // used on further setups by loadViewSet
	                this.viewSetName = message.viewSetName;
	            } else { // this is the initial viewset setup
	                this.viewSetName = localStorage.getItem("currentViewSet") || "softkey";
	                this.initialViewSet = this.viewSetName;
	            }
	            return ext.Promises.promise(async(resolve, reject) => {
	                try {
	                    await this.updateJSONData();
	                    resolve();
	                } catch(e) {
	                    reject(e);
	                }
	                this.logger.log(this.logger.LOG_SRVC_INOUT, "< ViewServiceMock::onSetup");
	            });
	        }

	        /**
	         * Registers an "ADA state change handler" function if an 'adaViewSet' is configured.
	         * Registers a "Style Type handler" function.
	         * Reads the properties `PROP_UI_VIEWSET_KEY` and `PROP_UI_STYLE_TYPE_KEY`.
	         * If all other services are ready, it calls {@link Wincor.UI.Service.ViewService#startSPA} to load the initial URL.
	         * @returns {Promise}
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.BaseServiceMock#onServicesReady}
	         */
	        onServicesReady() {
	            _logger.log(_logger.LOG_SRVC_INOUT, "> ViewServiceMock::onServicesReady()");
	            const self = this;
	            let hasAdaStarted = false; // flag (closured by -adaStateChangeHandler) to prevent from loadingViewSet only because CCTAFW_PROP_ADA_STATUS_VALUE has been stopped without started.
	            return ext.Promises.promise((resolve, reject) => {
	                const instanceName = Wincor.UI.Service.Provider.ConfigService.configuration.instanceName;
	                Wincor.UI.Service.Provider.ConfigService.getConfiguration(`${instanceName}\\Services\\General`, ["InitialViewSet", "AdaViewSet", "CacheHTML", "BeepOnTimeoutPopup", "BeepOnTimeoutPopupPeriod"])
	                .then(configData => {
	                    // only if we don't have a current viewset either from button choose at startExtDesignmode or via query argument 'viewSet' we get config value as a fallback:
	                    if(!localStorage.getItem("currentViewSet")) {
	                        self.initialViewSet = configData["InitialViewSet"];
	                    }
	                    self.adaViewSet = configData["AdaViewSet"];
	                    // normalize/check boolean config
	                    self.cacheHTML = !!configData["CacheHTML"];
	                });
	                if(localStorage.getItem("activateTimeoutsOn") === "true") {
	                    Wincor.UI.Service.Provider.ConfigService.getConfiguration(`${instanceName}\\Services\\Timeouts`, null)
	                    .then(timeoutResults => {
	                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewServiceMock::onServicesReady(): default timeouts = ${JSON.stringify(timeoutResults)}`);
	                        self.DEFAULT_TIMEOUT_VALUES = Object.assign(self.DEFAULT_TIMEOUT_VALUES, timeoutResults);
	                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewServiceMock::onServicesReady(): this.DEFAULT_TIMEOUT_VALUES = ${JSON.stringify(self.DEFAULT_TIMEOUT_VALUES)}`);
	                        // set variables for timeouts
	                        self.pageTimeout = timeoutResults.PageTimeout;
	                        self.immediateTimeout = timeoutResults.ImmediateTimeout;
	                        self.endlessTimeout = timeoutResults.EndlessTimeout;
	                        self.messageTimeout = timeoutResults.MessageTimeout;
	                        self.confirmationTimeout = timeoutResults.ConfirmationTimeout;
	                        self.inputTimeout = timeoutResults.InputTimeout;
	                        self.pinentryTimeout = timeoutResults.PinentryTimeout;
	                    });
	                }
	                // register for ada events to auto switch viewset only if configured
	                if(self.adaViewSet) {
	                    const adaService = Wincor.UI.Service.Provider.AdaService;
	                    // Please note that this state handler will often be triggered because the business app often changes the value CCTAFW_PROP_ADA_STATUS_VALUE property.
	                    // That's why we control the updates with an own flag called -hasAdaStarted
	                    const adaStateChangedHandler = function(eventData) {
	                        self.logger.log(self.logger.LOG_ANALYSE, `* ViewServiceMock::onServicesReady::adaStateChangedHandler eventData=${eventData}, current ViewSet=${self.viewSetName}, ada ViewSet=${self.adaViewSet}`);
	                        if(eventData === "FIRSTSTARTANDACTIVATE" || eventData === "FIRSTSTART") {
	                            hasAdaStarted = true; // ADA has been really started now
	                            const startViewKey = Wincor.UI.Service.Provider.ControlPanelService.getContext()?.controlPanelData?.Ada?.StartViewKey ?? "LanguageSelection";
	                            // switch to ada view set on next view if not already active
	                            if(self.viewSetName.toLowerCase() !== self.adaViewSet.toLowerCase()) {
	                                self.logger.log(self.logger.LOG_ANALYSE, `* ViewServiceMock::onServicesReady::adaStateChangedHandler  - loading viewset for ada -> ${self.adaViewSet}`);
	                                self.loadViewSet(self.adaViewSet).then(() => {
	                                    adaService.externalAdaCommandAck(eventData); // send acknowledge with first start
	                                    self.display({viewKey: startViewKey, viewURL: "selection"}); // start e.g. language selection for ADA
	                                }).catch(cause => {
	                                    hasAdaStarted = false;
	                                    self.logger.error(`* ViewServiceMock::onServicesReady::adaStateChangedHandler error loading new view set due to ADA first start event ${cause}`);
	                                    adaService.externalAdaCommandAck(eventData); // send acknowledge with first start anyway
	                                });
	                            } else {
	                                self.logger.log(self.logger.LOG_ANALYSE, "* ViewServiceMock::onServicesReady::adaStateChangedHandler viewset for ada already active");
	                                adaService.externalAdaCommandAck(eventData); // send acknowledge with first start anyway
	                                self.display({viewKey: startViewKey, viewURL: "selection"}); // start e.g. language selection for ADA
	                            }
	                        } else if(hasAdaStarted && eventData === "LASTSTOP") { // ADA has been started before?
	                            hasAdaStarted = false;
	                            if(self.viewSetName.toLowerCase() !== self.initialViewSet.toLowerCase()) {
	                                self.logger.log(self.logger.LOG_ANALYSE, `* ViewServiceMock::onServicesReady::adaStateChangedHandler - ADA stop event, loading initial viewset -> ${self.initialViewSet}`);
	                                self.loadViewSet(self.initialViewSet, true).then(() => {
	                                    adaService.externalAdaCommandAck(eventData); // send acknowledge with last stop
	                                }).catch(cause => {
	                                    self.logger.error(`* ViewServiceMock::onServicesReady::adaStateChangedHandler error loading initial view set due to ADA last stop event ${cause}`);
	                                    adaService.externalAdaCommandAck(eventData); // send acknowledge with last stop anyway
	                                });
	                            } else {
	                                self.logger.log(self.logger.LOG_ANALYSE, "* ViewServiceMock::onServicesReady::adaStateChangedHandler viewset for ending ada already active");
	                                adaService.externalAdaCommandAck(eventData); // send acknowledge with last stop anyway
	                            }
	                        }
	                    };
	                    self.registerForServiceEvent(adaService.SERVICE_EVENTS.FIRST_START, adaStateChangedHandler, true);
	                    self.registerForServiceEvent(adaService.SERVICE_EVENTS.LAST_STOP, adaStateChangedHandler, true);
	                } else {
	                    self.logger.log(self.logger.LOG_ANALYSE, "* ViewServiceMock::onServicesReady(): no valid AdaViewSet configured... disabling automatic switching");
	                }

	                // BEGIN retrieving style type stuff -->
	                const PROP_UI_STYLE_TYPE_KEY = "PROP_UI_STYLE_TYPE_KEY";
	                let reg = -1;
	                // PROP_UI_STYLE_TYPE_KEY callback on initial/update
	                function changeStyleType(result) {
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceMock::onServicesReady::changeStyleType result=${JSON.stringify(result)}`);
	                    const styleTextKey = result[PROP_UI_STYLE_TYPE_KEY];
	                    if(styleTextKey !== null && styleTextKey !== void 0) {
	                        // Remark: Even if the styleTextKey is empty force a getText call, in such a case the result will be empty but the
	                        // StyleResourceResolver will handle this case.
	                        Wincor.UI.Service.Provider.LocalizeService.getText([styleTextKey], result => {
	                            let value = result[styleTextKey];
	                            // map value to the right default, if empty or undefined
	                            value = (value === "" || value === void 0 || value === null || value === "\\" || value === "\"\"") ? "" : value;
	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewServiceMock::onServicesReady::changeStyleType type='${value}'`);
	                            self.currentStyleTypeByStylesheetKey = value;
	                            if(!self.isRestartOnNextDisplay) {
	                                self.fireServiceEvent(self.SERVICE_EVENTS.STYLE_TYPE_CHANGED, value);
	                            } else {
	                                // viewset will change on next display - postpone event until new viewset is loaded
	                                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "* ViewServiceMock::onServicesReady::changeStyleType postponing fire STYLE_TYPE_CHANGED.");
	                                if(reg !== -1) {
	                                    self.deregisterFromServiceEvent(reg);
	                                }
	                                reg = self.registerForServiceEvent(self.SERVICE_EVENTS.VIEW_ACTIVATED, eventData => {
	                                        const href = typeof eventData === "string" ? eventData : eventData.href;
	                                    if (href && href.endsWith("index.html")) { // check for welcome and then fire style event
	                                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewServiceMock::onServicesReady::changeStyleType viewset ${self.viewSetName} loaded (welcome).`);
	                                        // decouple
	                                        setTimeout(() => {
	                                            self.fireServiceEvent(self.SERVICE_EVENTS.STYLE_TYPE_CHANGED, value);
	                                            self.deregisterFromServiceEvent(reg);
	                                            reg = -1;
	                                        }, 1);
	                                    }
	                                },
	                                true);
	                            }
	                        }, false); // no auto update on language changed
	                    } else { // PROP_UI_STYLE_TYPE_KEY not existent
	                        _logger.error(`The property=${PROP_UI_STYLE_TYPE_KEY} doesn't exist which is unexpected!`);
	                    }
	                    _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::onServicesReady::changeStyleType");
	                }
	                Wincor.UI.Service.Provider.DataService.getValues([PROP_UI_STYLE_TYPE_KEY], changeStyleType, changeStyleType, true);
	                //<-- END retrieving stylesheet folder stuff

	                // Read view set property
	                const PROP_UI_VIEWSET_KEY = "PROP_UI_VIEWSET_KEY";
	                // read property and read text key for view-set switching
	                const checkViewSetTextEntry = function(result) {
	                    const viewSetKey = result[PROP_UI_VIEWSET_KEY];
	                    _logger.LOG_INOUT && _logger.log(_logger.LOG_INOUT, `> ViewServiceMock::onServicesReady:checkViewSetTextEntry viewSetKey = ${viewSetKey}`);
	                    if(viewSetKey && viewSetKey !== "\"\"") { // got a text key?
	                        self.serviceProvider.LocalizeService.getText([viewSetKey], result => {
	                            const viewSetName = result[viewSetKey];
	                            _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewServiceMock::onServicesReady:checkViewSetTextEntry demanded view set name=${viewSetName}, current view set name=${self.viewSetName}`);
	                            if(viewSetName !== null && viewSetName !== self.viewSetName) { // only if the demanded viewset is not already the current
	                                _logger.LOG_INOUT && _logger.log(_logger.LOG_INOUT, "< ViewServiceMock::onServicesReady:checkViewSetTextEntry");
	                                return self.loadViewSet(viewSetName);
	                            }
	                        });
	                    } else if(self.viewSetName !== self.initialViewSet) {
	                        _logger.LOG_INOUT && _logger.log(_logger.LOG_INOUT, `< ViewServiceMock::onServicesReady:checkViewSetTextEntry load initial view set=${self.initialViewSet}`);
	                        return self.loadViewSet(self.initialViewSet);
	                    }
	                    _logger.LOG_INOUT && _logger.log(_logger.LOG_INOUT, "< ViewServiceMock::onServicesReady:checkViewSetTextEntry did nothing");
	                    return ext.Promises.Promise.resolve();
	                };

	                _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, "* ViewServiceMock::onServicesReady getting viewSetKey");
	                Wincor.UI.Service.Provider.DataService.getValues([PROP_UI_VIEWSET_KEY], null, result => { // changed callback
	                    _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewServiceMock::onServicesReady restarting=${self.restarting} viewSetKey changed to ${JSON.stringify(result)}`);
	                    if(!self.restarting) {
	                        checkViewSetTextEntry(result).then(resolve);
	                    } else {
	                        resolve();
	                    }
	                }, true);

	                // initial view set starting SPA...
	                // when all other services are ready, we start SPA
	                const svcNames = [];
	                const serviceDependenciesReady = self.serviceProvider.serviceNames
	                    .filter(svcName => {
	                        const isServiceToWaitFor = svcName !== self.NAME;
	                        if (isServiceToWaitFor) {
	                            svcNames.push(svcName);
	                        }
	                        return isServiceToWaitFor;
	                    })
	                    .map((svcName) => {
	                        return self.serviceProvider[svcName].whenReady;
	                    });
	                ext.Promises.Promise.all(serviceDependenciesReady)
	                    .timeout(20000) // security timeout... If there is a deadlock somewhere it will nevertheless be safe to launch now
	                    .catch(reason => {
	                        // if it is timeout only, recover and pass
	                        if(!(reason && reason.name === "TimeoutError")) {
	                            throw(reason);
	                        }
	                        _logger.error(`WARNING: ViewService::onServicesReady():\nTimeout waiting for depending services! - Please check syncing of services:\n${svcNames.join("\n")}`);
	                    })
	                    .then(() => {
	                        _logger.LOG_ANALYSE && _logger.log(_logger.LOG_ANALYSE, `* ViewService::onServicesReady(): all services ready - starting content`);
	                        if(self.viewSetName === "touch") {
	                            self.startSPA(self.urlMapping.touch);
	                            super.onServicesReady().then(resolve);
	                        } else if(self.viewSetName === "softkey") {
	                            self.startSPA(self.urlMapping.softkey);
	                            super.onServicesReady().then(resolve);
	                        } else {
	                            _logger.error("ViewServiceMock::onServicesReady initial view set name not set or unknown.");
	                            super.onServicesReady().then(reject);
	                        }
	                    });
	                _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceMock::onServicesReady");
	            });
	        }
	    }
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ ViewServiceInterface.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	const ServiceClass$s = getServiceClass$v({
	    jQuery: jQuery$3,
	    Wincor: Wincor$2,
	    BaseService: BaseService$1,
	    ext: ext$3,
	    LogProvider
	});

	const ServiceInterface$s = {
	    ViewProxy: {
	        interface: {
	            viewContext: {
	                type: 'object',
	                keys: ['viewKey', 'viewURL', 'viewConfig', 'viewID']
	            },
	            SERVICE_EVENTS: {
	                type: 'object',
	                keys: [
	                    'NAVIGATE_SPA',
	                    'VIEW_CLOSING',
	                    'VIEW_BEFORE_CHANGE',
	                    'VIEW_PREPARED',
	                    'TURN_ACTIVE',
	                    'CONTENT_UPDATE',
	                    'VIEW_ACTIVATED',
	                    'VIEW_USERINTERACTION_TIMEOUT',
	                    'STYLE_TYPE_CHANGED',
	                    'POPUP_ACTIVATED',
	                    'POPUP_DEACTIVATED',
	                    'SHUTDOWN',
	                    'SUSPEND',
	                    'RESUME'
	                ],
	                writable: false
	            },
	            EVENT_UIRESULT: {
	                type: 'object',
	                keys: ['service', 'eventName', 'viewID', 'UIResult']
	            },
	            Expand_StringDefines: {
	                attributes: [
	                    'UIRESULT_OK',
	                    'UIRESULT_TIMEOUT_USER',
	                    'UIRESULT_CANCEL_USER',
	                    'UIRESULT_CANCEL_SW',
	                    'UIRESULT_ERROR_VIEW',
	                    'UIRESULT_CANCEL_SW_ERROR'
	                ],
	                type: 'string',
	                writable: false
	            },
	            Expand_Numbers: {
	                attributes: [
	                    'messageTimeout',
	                    'immediateTimeout',
	                    'endlessTimeout',
	                    'confirmationTimeout',
	                    'inputTimeout',
	                    'pinentryTimeout'
	                ],
	                type: 'number',
	                writable: false
	            },
	            Expand_Booleans: {
	                attributes: ['cacheHTML'],
	                type: 'boolean',
	                writable: true
	            },
	            currentStyleType: {
	                type: 'string'
	            },
	            currentStyleTypeByStylesheetKey: {
	                type: 'string'
	            },
	            currentVendor: {
	                type: 'string'
	            },
	            currentResolution: {
	                type: 'string'
	            },
	            viewSetName: {
	                type: 'string'
	            },
	            CONTENT_FRAME_NAME: {
	                type: 'string'
	            },
	            isSuspended: {
	                type: 'boolean',
	                writable: false
	            },
	            Expand_StandardFunctions: {
	                attributes: [
	                    'display',
	                    'prepare',
	                    'activate',
	                    'offlineHandling',
	                    'endView',
	                    'fireActivated',
	                    'firePopupNotification',
	                    'fireContentUpdated',
	                    'firePrepared',
	                    'refreshTimeout',
	                    'getTimeoutValue',
	                    'clearTimeout',
	                    'setViewContext',
	                    'loadViewSet',
	                    'onError',
	                    'cancel'
	                ],
	                type: 'function'
	            },
	            swapLocation: {
	                type: 'function'
	            },
	            resizeWindow: {
	                type: 'function',
	                callbackArgumentIndex: 1,
	                shadowValue: "if(window.top.resizeDM) { let o=arguments[0],cb=arguments[1];window.top.resizeDM(o.top, o.left, o.width, o.height);if (cb){cb()} } else if (typeof arguments[1] === 'function') { var cb = arguments[1]; window.setTimeout(cb, 1);}"
	            },
	            navigate: {
	                type: 'function'
	            },
	            bringToFront: {
	                type: 'function'
	            },
	            readConfiguration: {
	                type: 'function'
	            },
	            getUsedProperties: {
	                type: 'function'
	            },
	            suspend: {
	                type: 'function'
	            },
	            resume: {
	                type: 'function'
	            },
	            contentRunning: {
	                type: 'boolean',
	                writable: false,
	                serviceEvent: true
	            },
	            updateJSONData: {
	                type: 'function'
	            },
	            updateCurrent: {
	                type: 'function'
	            }
	        }
	    }
	};

	var ViewService$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$s,
		ServiceClass: ServiceClass$s
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany
	 
	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.
	 
	 $MOD$ wn.UI.Service.InterfacesDesignMode.js 4.3.1-210127-21-34ae33df-1a04bc7d
	 */

	const InterfaceGeneral$1 = {
	    "Comment": "This file defines the interface for the extended-design-mode EDM of ProFlex4 UI",
	    "General": {
	        "interface": {
	            "Expand_GeneralConstants": {
	                "attributes": ["NAME", "DISPOSAL_TRIGGER_DEACTIVATE", "DISPOSAL_TRIGGER_UNLOAD", "DISPOSAL_TRIGGER_ONETIME", "DISPOSAL_TRIGGER_SHUTDOWN"],
	                "type": "string",
	                "writable": false
	            },
	            "onResponse": {
	                "type": "function",
	                "traceable": false
	            },
	            "onRequest": {
	                "type": "function",
	                "traceable": false
	            },
	            "onEvent": {
	                "type": "function",
	                "traceable": false
	            },
	            "registerForServiceEvent": {
	                "type": "function"
	            },
	            "fireServiceEvent": {
	                "type": "function",
	                "internal": false
	            },
	            "deregisterServiceEvents": {
	                "type": "function"
	            },
	            "deregisterFromServiceEvent": {
	                "type": "function"
	            },
	            "onSetup": {
	                "type": "function"
	            },
	            "onServicesReady": {
	                "type": "function"
	            },
	            "whenReady": {
	                "type": "object",
	                "writable": false
	            }
	        }
	    }
	};

	const ServiceBundle$1 = [];

	ServiceBundle$1.push(LogService$1);

	ServiceBundle$1.push(AdaService$1);

	ServiceBundle$1.push(BeepService$1);

	ServiceBundle$1.push(ConfigService$1);

	ServiceBundle$1.push(UtilityService$1);

	ServiceBundle$1.push(ControlPanelService);

	ServiceBundle$1.push(DataService$1);

	ServiceBundle$1.push(EppService$1);

	ServiceBundle$1.push(EventService$1);

	ServiceBundle$1.push(FormatService$1);

	ServiceBundle$1.push(JournalService$1);

	ServiceBundle$1.push(LocalizeService$1);

	ServiceBundle$1.push(ValidateService$1);

	ServiceBundle$1.push(VideoService$1);

	ServiceBundle$1.push(ViewService$1);

	var wn_UI_Service_InterfacesDesignMode = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceBundle: ServiceBundle$1,
		InterfaceGeneral: InterfaceGeneral$1
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany
	 
	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.
	 
	 $MOD$ wn.UI.Service.InterfacesDesignModeDirectMarketing.js 4.3.1-201130-21-086c3328-1a04bc7d
	 */

	const InterfaceGeneral$2 = {
	    "Comment": "This file defines the interface for the extended-design-mode EDM for direct marketing of ProFlex4 UI",
	    "General": {
	        "interface": {
	            "Expand_GeneralConstants": {
	                "attributes": ["NAME", "DISPOSAL_TRIGGER_DEACTIVATE", "DISPOSAL_TRIGGER_UNLOAD", "DISPOSAL_TRIGGER_ONETIME", "DISPOSAL_TRIGGER_SHUTDOWN"],
	                "type": "string",
	                "writable": false
	            },
	            "onResponse": {
	                "type": "function",
	                "traceable": false
	            },
	            "onRequest": {
	                "type": "function",
	                "traceable": false
	            },
	            "onEvent": {
	                "type": "function",
	                "traceable": false
	            },
	            "registerForServiceEvent": {
	                "type": "function"
	            },
	            "fireServiceEvent": {
	                "type": "function",
	                "internal": false
	            },
	            "deregisterServiceEvents": {
	                "type": "function"
	            },
	            "deregisterFromServiceEvent": {
	                "type": "function"
	            },
	            "onSetup": {
	                "type": "function"
	            },
	            "onServicesReady": {
	                "type": "function"
	            },
	            "whenReady": {
	                "type": "object",
	                "writable": false
	            }
	        }
	    }
	};

	const ServiceBundle$2 = [];

	ServiceBundle$2.push(LogService$1);

	ServiceBundle$2.push(AdaService$1);

	ServiceBundle$2.push(BeepService$1);

	ServiceBundle$2.push(ConfigService$1);

	ServiceBundle$2.push(UtilityService$1);

	ServiceBundle$2.push(ControlPanelService);

	ServiceBundle$2.push(DataService$1);

	ServiceBundle$2.push(EppService$1);

	ServiceBundle$2.push(EventService$1);

	ServiceBundle$2.push(FormatService$1);

	ServiceBundle$2.push(JournalService$1);

	ServiceBundle$2.push(LocalizeService$1);

	ServiceBundle$2.push(ValidateService$1);

	ServiceBundle$2.push(ViewService$1);

	var wn_UI_Service_InterfacesDesignModeDirectMarketing = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceBundle: ServiceBundle$2,
		InterfaceGeneral: InterfaceGeneral$2
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany
	 
	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.
	 
	 $MOD$ wn.UI.Service.InterfacesDirectMarketing.js 4.3.1-201130-21-086c3328-1a04bc7d
	 */

	const InterfaceGeneral$3 = {
	    "Comment": "This is the standard service interface definition file of ProFlex4 UI Direct Marketing instance",
	    "General": {
	        "interface": {
	            "Expand_GeneralConstants": {
	                "attributes": ["NAME", "DISPOSAL_TRIGGER_DEACTIVATE", "DISPOSAL_TRIGGER_UNLOAD", "DISPOSAL_TRIGGER_ONETIME", "DISPOSAL_TRIGGER_SHUTDOWN"],
	                "type": "string",
	                "writable": false
	            },
	            "onResponse": {
	                "type": "function",
	                "traceable": false
	            },
	            "onRequest": {
	                "type": "function",
	                "traceable": false
	            },
	            "onEvent": {
	                "type": "function",
	                "traceable": false
	            },
	            "registerForServiceEvent": {
	                "type": "function"
	            },
	            "fireServiceEvent": {
	                "type": "function",
	                "internal": false
	            },
	            "deregisterServiceEvents": {
	                "type": "function"
	            },
	            "deregisterFromServiceEvent": {
	                "type": "function"
	            },
	            "onSetup": {
	                "type": "function"
	            },
	            "onServicesReady": {
	                "type": "function"
	            },
	            "whenReady": {
	                "type": "object",
	                "writable": false
	            }
	        }
	    }
	};

	const ServiceBundle$3 = [];

	ServiceBundle$3.push(LogService);

	ServiceBundle$3.push(AdaService);

	ServiceBundle$3.push(BeepService);

	ServiceBundle$3.push(ConfigService);

	ServiceBundle$3.push(UtilityService);

	ServiceBundle$3.push(DataService);

	ServiceBundle$3.push(EppService);

	ServiceBundle$3.push(EventService);

	ServiceBundle$3.push(FormatService);

	ServiceBundle$3.push(JournalService);

	ServiceBundle$3.push(LocalizeService);

	ServiceBundle$3.push(ValidateService);

	ServiceBundle$3.push(ViewService);

	var wn_UI_Service_InterfacesDirectMarketing = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceBundle: ServiceBundle$3,
		InterfaceGeneral: InterfaceGeneral$3
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.


	$MOD$ wn.UI.Service.ViewServiceHeadless.js 4.3.1-210203-21-60d725a2-1a04bc7d

	*/

	/**
	 * @module
	 */
	const getServiceClass$w = ({ Wincor, LogProvider, ViewService }) => {
	    /**
	     * The logger.
	     *
	     * @type {Wincor.UI.Diagnostics.LogProvider}
	     * @const
	     */
	    const _logger = LogProvider;

	    return class ViewServiceHeadless extends ViewService {
	        /**
	         * The logical name of this service as used in the service-provider.
	         * @const
	         * @type {string}
	         * @default ViewService
	         */
	        NAME = "ViewService";

	        /**
	         * Internal flag PF4 mode active or not
	         */
	        PF4Active = false;

	        /**
	         * Initialize members
	         * @lifecycle service
	         * @see {@link Wincor.UI.Service.ViewService#constructor}.
	         */
	        constructor(...args) {
	            super(...args);
	            this.contentRunning = false;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewServiceHeadless::ViewServiceHeadless");
	            // read
	            this.ViewActionMap = {};
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceHeadless::ViewServiceHeadless");
	        }

	        /**
	         * Override to intercept calls
	         * @override
	         * @param  {...any} args Any original arguments are passed through to base.
	         */
	        processDisplay(...args) {
	            super.processDisplay(...args);
	            this.contentRunning = true;
	        }

	        /**
	         * This function override directly calls super.display() in case of PF4Mode is active.
	         * Otherwise it shortcuts / hooks into display calls to views / viewKeys and either directly resolves with "OK"
	         * or uses endless timeout to let content do call to endView with appropriate results.
	         * Default handling is defined in ViewServiceHeadless#ViewActionMap.
	         * @override
	         * @param  {...any} args Any original arguments are passed through to base if PF4Active is set.
	         * @async
	         */
	        async display(...args) {
	            if (this.PF4Active) return super.display(...args);
	            let message = args[0];
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceHeadless::display(...)\n${JSON.stringify(message, null, " ")}`);
	            this.EVENT_UIRESULT.UILastButtonPressedEPPKey = [];
	            this.viewContext.viewID = message.viewID;
	            this.viewContext.viewURL = this.urlMapping[message.viewKey].url;
	            this.viewContext.viewKey = message.viewKey;
	            this.contentRunning = true;
	            await this.confirmDisplay();
	            const viewUrl = this.viewContext.viewURL;
	            const vk = message.viewKey;
	            let actionConfig = this.ViewActionMap.VIEW_KEYS[vk] || this.ViewActionMap.VIEWS[viewUrl];

	            if (actionConfig) {
	                if (actionConfig.timeout >= 0) {
	                    let res = actionConfig.result || 0;
	                    let extRes = actionConfig.extendedResult || "";
	                    _logger.log(_logger.LOG_SRVC_DATA, `. ViewServiceHeadless::display - setting result <${res}/${extRes}> in ${actionConfig.timeout} seconds`);
	                    setTimeout(this.endView.bind(this, res, extRes), actionConfig.timeout);
	                } else {
	                    _logger.log(_logger.LOG_SRVC_DATA, `. ViewServiceHeadless::display - endless timeout... waiting for cancellation`);
	                }
	            }
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceHeadless::display");
	        }

	        /**
	         * Any original arguments are passed through to base.
	         * @param {string} res
	         * @param {string=} extRes
	         */
	        endView(res, extRes) {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceHeadless::endView(${res}, ${extRes})`);
	            super.endView(res, extRes);
	            this.contentRunning = false;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceHeadless::endView");
	        }

	        /**
	         * Fires Wincor.UI.Service.ViewService#SERVICE_EVENT.SHUTDOWN
	         */
	        shutdown() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "> ViewServiceHeadless::shutdown()");
	            this.fireServiceEvent(this.SERVICE_EVENTS.SHUTDOWN);
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceHeadless::shutdown");
	        }

	        /**
	         * Confirms a call to 'display' by:
	         * Sending Wincor.UI.Service.ViewService#SERVICE_EVENT.VIEW_PREPARED
	         * Waiting for Wincor.UI.Service.ViewService#SERVICE_EVENT.TURN_ACTIVE
	         * Sending Wincor.UI.Service.ViewService#SERVICE_EVENT.VIEW_ACTIVATED
	         * This is necessary to fulfill the state machine requirements of our lifecycle
	         * @async
	         */
	        async confirmDisplay() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceHeadless::confirmDisplay() PF4Active=${this.PF4Active}`);
	            return new Promise(resolve => {
	                this.registerForServiceEvent(
	                    this.SERVICE_EVENTS.TURN_ACTIVE,
	                    () => {
	                        this.fireActivated();
	                        _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, "< ViewServiceHeadless::confirmDisplay");
	                        resolve();
	                    },
	                    this.DISPOSAL_TRIGGER_ONETIME
	                );
	                this.firePrepared();
	            });
	        }

	        /**
	         * Switches mode to PF4.
	         * All functionality for flowrunner is switched off and PF4 can be loaded by a call to Wincor.UI.Service.ViewService#loadViewSet
	         * @param {String} [frameName=pf4content] HTML Id of the frame to be used for PF4 content
	         */
	        activatePF4(frameName = "pf4content") {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceHeadless::activatePF4(${frameName})`);
	            this.PF4Active = true;
	            this.CONTENT_FRAME_NAME = `#${frameName}`;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< ViewServiceHeadless::activatePF4 '${this.CONTENT_FRAME_NAME}'`);
	        }

	        /**
	         * Switches off PF4 mode.
	         * All functionality for flowrunner is switched on again.
	         */
	        deactivatePF4() {
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `> ViewServiceHeadless::deactivatePF4()`);
	            this.PF4Active = false;
	            _logger.LOG_SRVC_INOUT && _logger.log(_logger.LOG_SRVC_INOUT, `< ViewServiceHeadless::deactivatePF4`);
	        }
	    };
	};

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ ViewServiceInterfaceHeadless.js 4.3.1-210203-21-60d725a2-1a04bc7d
	*/

	const ServiceClass$t = getServiceClass$w({
	    Wincor: Wincor$2,
	    LogProvider,
	    ViewService: ServiceClass$e
	});

	const ServiceInterface$t = jQuery$2.extend(true, {}, ServiceInterface$e, {
	    ViewProxy: {
	        interface: {
	            ViewActionMap: {
	                type: "object"
	            },
	            activatePF4: {
	                type: "function"
	            },
	            deactivatePF4: {
	                type: "function"
	            },
	            confirmDisplay: {
	                type: "function"
	            },
	            shutdown: {
	                type: "function"
	            }
	        }
	    }
	});

	var ViewService$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceInterface: ServiceInterface$t,
		ServiceClass: ServiceClass$t
	});

	/**
	 @preserve
	 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
	 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

	 This software is the confidential and proprietary information
	 of Diebold Nixdorf.
	 You shall not disclose such Confidential Information and shall
	 use it only in accordance with the terms of the license agreement
	 you entered into with Diebold Nixdorf.

	 $MOD$ wn.UI.Service.InterfacesHeadless.js 4.3.1-210127-21-34ae33df-1a04bc7d
	*/

	// replace standard ViewService with headless
	const ServiceBundle$4 = ServiceBundle.map(bundleItem => {
	    let serviceName = Object.keys(bundleItem.ServiceInterface)[0].replace("Proxy", "Service");
	    return serviceName === "ViewService" ? ViewService$2 : bundleItem;
	});

	var wn_UI_Service_InterfacesHeadless = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ServiceBundle: ServiceBundle$4,
		InterfaceGeneral: InterfaceGeneral
	});

});
//# sourceMappingURL=CoreBundle.amd.js.map
