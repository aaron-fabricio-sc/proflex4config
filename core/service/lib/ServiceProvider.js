/**
 @preserve
 Copyright (c) 2001-2020 by Wincor Nixdorf International GmbH,
 Heinz-Nixdorf-Ring 1, 33106 Paderborn, Germany

 This software is the confidential and proprietary information
 of Diebold Nixdorf.
 You shall not disclose such Confidential Information and shall
 use it only in accordance with the terms of the license agreement
 you entered into with Diebold Nixdorf.



$MOD$ ServiceProvider.js 4.3.1-210212-21-06af7f4f-1a04bc7d
 */
const deferredInitObjects={};let PROVIDER;const ServiceProvider=({Wincor:e,jQuery:r,ext:o,LogProvider:i,BaseProxyClass:t,GatewayProvider:s}={})=>{let n,c,a;return PROVIDER=PROVIDER||new class{NAME="ServiceProvider";serviceNames=[];services={};baseUrl="";constructor(){this.LogProvider=i,this.serviceNames.push("LogProvider"),this.proxyConfiguration={},this.masterConfig=[]}addService(r){console.log(`adding proxy ${r.NAME}`);const i=this.proxyConfiguration[r.NAME].__NAME;let t,s={},n=this.masterConfig.find((e=>e.serviceName===i));n&&(t=n.bundle.ServiceClass,s=n.bundle.ConstructorDependencies||{});const c=new t(i,Object.assign({ServiceProvider:this},s));return r.initializeService(this.proxyConfiguration[r.NAME],this.proxyConfiguration.General,c).then((i=>(r.initializeService=void 0,r.ensureInterface=void 0,o.Promises.promise(((o,t)=>{const s=r.getServiceName();this.services[r.NAME]=s,this.serviceNames.push(s);const n=new Proxy(r,{get:(o,i)=>i in o?o[i]:(e.UI.Diagnostics.LogProvider.error(`Access to unknown property '${i}' of ServiceProxy<${r.getServiceName()}>!`),null),has:(e,r)=>r in e}),c={get:()=>n,set:o=>{let i;try{i=JSON.stringify(o)}catch(e){i=o}e.UI.Diagnostics.LogProvider.error(`Someone tried to reassign proxy reference to '${i}' on ServiceProxy<${r.getServiceName()}>!`)}};if(this[s]=n,Object.defineProperty(this,s,c),deferredInitObjects[s]=i,"LogService"===s){const i=e.UI.Diagnostics.LogProvider;r.readCurrentTraceBitStates().then((()=>{i.setLogger(r),i.log(i.LOG_ANALYSE,"* DUMPING ConsoleLogger queue"),e.UI.Diagnostics.ConsoleLogger.messageStack.forEach((e=>{e[0]?i.error(e[1]):i.log(i.LOG_ANALYSE,e[1])})),o()}))}else o()})))))}importedFiles=[];async createMasterConfig(e){try{return console.log("> ServiceProvider::createMasterConfig()"),e.forEach((e=>{try{if(e.ServiceClass.prototype.NAME){const r=`ServiceProvider::createMasterConfig: Old ServiceBundle found: ${JSON.stringify(e,null," ")} prototype class creation not supported, use native classes instead.`;throw console.error(r),r}const o=e.ServiceInterface;if(!o){const r=`ServiceProvider::createMasterConfig: Inconsistent ServiceBundle: ${JSON.stringify(e,null," ")}`;throw console.error(r),r}let i=Object.keys(o)[0],t=i.replace("Proxy","Service");o[i].__NAME=t,r.extend(!0,this.proxyConfiguration,o),this.masterConfig.push({serviceName:t,interfaceName:i,bundle:e}),console.log(`ServiceProvider::createMasterConfig: added proxy config of '${t}'`)}catch(e){throw console.error(e),e}})),r.extend(!0,this.proxyConfiguration,a),console.log("< ServiceProvider::createMasterConfig"),this.masterConfig}catch(e){throw console.error(e),e}}setBaseUrl(e){console.log(`> ServiceProvider::setBaseUrl(${e})`),this.baseUrl=e,console.log("< ServiceProvider::setBaseUrl")}async loadServices(r,i){let c;n=r,a=i;const l={},v={},d=["General","Version","Import","Comment"];try{await this.createMasterConfig(r),c=Object.keys(this.proxyConfiguration).filter((e=>{let r=!0;return d.forEach((function(o){e.substr(0,o.length)===o&&(r=!1)})),r})).map((e=>{let r;return this.proxyConfiguration[e].proxy?(r=this.proxyConfiguration[e].proxy,l[r]=e):(r=e,this.proxyConfiguration[e].proxy=t),r})),console.log("finished loading proxy configuration..."),console.log("proxies: "+c);const i=c.indexOf("LogProxy");i>=0&&(c.splice(i,1),c.splice(0,0,"LogProxy")),console.log("sorted proxies: "+c),await o.Promises.serializeProcessing(c,(e=>{const r=e;return console.log("loading '"+e+"'..."),o.Promises.promise(((i,s)=>{o.Promises.Promise.resolve(this.proxyConfiguration[e].proxy).then((o=>{console.log(`...finished loading '${e}'`);try{let e;e=new class extends t{NAME=r},this.addService(e).then(i)}catch(r){console.log(`loadServices failed (${e}): ${r}`),o||console.log("parameter arg is undefined"),s()}}),(()=>{console.error(`could not find ${e}`),s()}))}))})),e.UI.Service.BaseService&&(e.UI.Service.BaseService=void 0),e.UI.Service.PTService&&(e.UI.Service.PTService=void 0),e.UI.Service.BaseProxy&&(e.UI.Service.BaseProxy=void 0);const n=Object.assign(Object.assign({},e.UI.Gateway.prototype.EVENT),{service:"ViewService",eventName:"BrowserReady"}),a=[];for(const[e,r]of Object.entries(deferredInitObjects))console.log(`${e}: ${r.id}`),a.push(r.promise);const g=s.getGateway();g&&g.sendEvent(n),console.log("loadServices successful"),v.init=o.Promises.Promise.all(a)}catch(e){throw e}return v}async setup(r){this.LogProvider.log(this.LogProvider.LOG_SRVC_INOUT,`> ServiceProvider::onSetup(${JSON.stringify(r)})`);const i=this.serviceNames.map((e=>{if(this[e].onSetup){this.LogProvider.log(this.LogProvider.LOG_DETAIL,`. calling onSetup of service: ${e})`);let o=this[e].onSetup.call(this[e],r);return o&&"function"!=typeof o.then&&(this.LogProvider.error(`Implementation error! Service <${e}::onSetup(...) implemented but not returning promise!>`),o=!0),o}return!0})),t=[];try{try{let e=-1;await Promise.race([o.Promises.Promise.all(i),new Promise(((r,o)=>{e=setTimeout(o,15e3)})).catch((e=>{throw e}))]).then((()=>{clearTimeout(e)})),console.log("ServiceProvider: onSetup callbacks completed")}catch(e){throw`onSetup promise failed ${e}`}c=r.instanceName;let n=this.serviceNames.map((e=>this[e].onServicesReady?(this.LogProvider.log(this.LogProvider.LOG_DETAIL,`. calling onServicesReady of service: ${e})`),this[e].onServicesReady.call(this[e]).then((()=>{this.LogProvider.log(this.LogProvider.LOG_DETAIL,`. onServicesReady of service: ${e} resolved... resolving whenReady promise`),t.push(e),deferredInitObjects[e].resolve()}))):(deferredInitObjects[e]&&(this.LogProvider.log(this.LogProvider.LOG_DETAIL,`. skip onServicesReady of service: ${e} ... resolving whenReady promise`),t.push(e),deferredInitObjects[e].resolve()),!0)));try{let e=-1;await Promise.race([o.Promises.Promise.all(n)],new Promise(((r,o)=>{e=setTimeout(o,15e3)})).then((()=>{clearTimeout(e)}))),console.log("ServiceProvider: onServiceReady callbacks completed")}catch(e){throw`onServicesReady promise failed ${e}`}const a=Object.assign(Object.assign({},e.UI.Gateway.prototype.EVENT),{service:"ViewService",eventName:"BrowserInitialized"}),l=s.getGateway();l&&l.sendEvent(a)}catch(r){let o=`failed setting up services! Unfinished: <${this.serviceNames.filter((e=>this[e].whenReady&&!t.includes(e)))}>\n${r} ${r.stack?r.stack:""}`;const i=Object.assign(Object.assign({},e.UI.Gateway.prototype.EVENT),{service:"ViewService",eventName:"BrowserFailed",eventData:o}),n=s.getGateway();throw n?n.sendEvent(i):console.error(o),o}}propagateError(e,r,o){let i="";const t=this,s=this.serviceNames.map((function(e){return t[e]}));if(o)i=`${o.message} + \n + ${o} ${o.stack?o.stack:""}`;else try{throw new Error("GeneratedStack")}catch(e){i=`${(o=e).message}\n${o.stack}\n`}this.LogProvider.error(`ServiceProvider received exception ${r}  from '${e}': '${i}'`),s.forEach((function(i){if(Object.prototype.hasOwnProperty.call(i,"onError")&&"function"==typeof i.onError)try{i.onError(e,r,o)}catch(e){t.LogProvider.error("Exception in ServiceProvider::propagateError when calling '"+i+"'.onError! \n"+e.message)}}))}hasService(e){return-1!==this.serviceNames.indexOf(e)}getServiceNames(){return this.serviceNames.filter((function(){return!0}))}getInstanceName(){return c}},e.UI.Service.Provider=e.UI.Service.Provider||PROVIDER,PROVIDER};export default ServiceProvider;